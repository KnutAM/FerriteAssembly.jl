var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = FerriteAssembly","category":"page"},{"location":"#FerriteAssembly","page":"Home","title":"FerriteAssembly","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The goal of FerriteAssembly  is to provide a simple structure to perform assembly in  Ferrite.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Sequential and threaded assembly of both the DofHandler and MixedDofHandler are supported.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package work by exporting the doassemble! function, and requires the  user to define either element_routine! (calculate both Ke and re), or just element_residual! (calculate only re).  In the latter case, Ke is calculated by  ForwardDiff.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"An advanced option to scale the unknowns, residual, and jacobian exists  (currently undocumented)","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#A-first-example","page":"Home","title":"A first example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We take a slightly modified element routine from Ferrite.jl's heat equation  example. We assume that we already have defined dh::DofHandler and our  cellvalues::CellScalarValues according to that example.  We start by defining the material (that normally contains material parameters but those are hard-coded in the example)","category":"page"},{"location":"","page":"Home","title":"Home","text":"struct ThermalMaterial end","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, we define our element_routine! for that material as ","category":"page"},{"location":"","page":"Home","title":"Home","text":"function FerriteAssembly.element_routine!(\n    Ke::AbstractMatrix, re::AbstractVector, \n    ae_new::AbstractVector, ae_old::AbstractVector,\n    state, material::ThermalMaterial, \n    cellvalues::CellScalarValues, \n    dh_fh::Union{DofHandler,FieldHandler}, Δt, materialcache\n    )\n    n_basefuncs = getnbasefunctions(cellvalues)\n    # Loop over quadrature points\n    for q_point in 1:getnquadpoints(cellvalues)\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:n_basefuncs\n            δu  = shape_value(cellvalues, q_point, i)\n            ∇δu = shape_gradient(cellvalues, q_point, i)\n            # Add body load contribution to re\n            re[i] += -δu * dΩ\n            # Loop over trial shape functions\n            for j in 1:n_basefuncs\n                ∇u = shape_gradient(cellvalues, q_point, j)\n                # Add contribution to Ke\n                Ke[i, j] += (∇δu ⋅ ∇u) * dΩ\n            end\n        end\n    end\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can now create the global vectors and matrices, as well as the time step","category":"page"},{"location":"","page":"Home","title":"Home","text":"K = create_sparsity_pattern(dh)\na=zeros(ndofs(dh)); aold=copy(a);\nr = zeros(ndofs(dh))\nΔt=1.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"In general, each integration point (or cell if desired by the user) can have a state. In this case, we have no such state variables, and just create a vector of nothing:","category":"page"},{"location":"","page":"Home","title":"Home","text":"states = [[nothing for _ in 1:getnquadpoints(cellvalues)] for _ in 1:getncells(dh.grid)]","category":"page"},{"location":"","page":"Home","title":"Home","text":"(For this case, states = [nothing for _ in 1:getncells(dh.grid)] would suffice).  The next step is gathering all variables that are modified for each cell,  but don't belong to each cell, in the cellbuffer:","category":"page"},{"location":"","page":"Home","title":"Home","text":"cellbuffer = CellBuffer(dh, cellvalues, ThermalMaterial())","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that cellvalues can be a Tuple or NamedTuple, this is useful for coupled  problems with multiple fields.  We then define our assembler and do the assembly","category":"page"},{"location":"","page":"Home","title":"Home","text":"assembler = start_assemble(K,r)\ndoassemble!(assembler, cellbuffer, states, dh, a, aold, Δt)","category":"page"},{"location":"#Threaded-assembly","page":"Home","title":"Threaded assembly","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To do the assembly in the example above threaded,  we need to color the grid to avoid race conditions. This can be done with Ferrite.jl's create_coloring function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"colors = create_coloring(dh.grid)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We must also create threaded versions of the cellbuffer and assembler,","category":"page"},{"location":"","page":"Home","title":"Home","text":"cellbuffers = create_threaded_CellBuffers(CellBuffer(dh, cellvalues, ThermalMaterial()))\nassemblers = create_threaded_assemblers(K, r)","category":"page"},{"location":"","page":"Home","title":"Home","text":"And then we can call doassemble! as","category":"page"},{"location":"","page":"Home","title":"Home","text":"doassemble!(assemblers, cellbuffers, states, colors, dh, a, aold, Δt)","category":"page"},{"location":"#Detailed-API-description","page":"Home","title":"Detailed API description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"One of the element methods should be overloaded for a given combination of cellvalues and material.","category":"page"},{"location":"","page":"Home","title":"Home","text":"FerriteAssembly.element_routine!\nFerriteAssembly.element_residual!","category":"page"},{"location":"#FerriteAssembly.element_routine!","page":"Home","title":"FerriteAssembly.element_routine!","text":"element_routine!(\n    Ke::AbstractMatrix, re::AbstractVector, \n    ae::AbstractVector, ae_old::AbstractVector,\n    state, material, cellvalues, \n    dh_fh::Union{DofHandler,FieldHandler}, Δt, materialcache\n    )\n\nThe main function to be overloaded for the specific material and cellvalues. This function should modify the residual r and the element stiffness matrix Ke, such that Ke=∂(re)/∂(ae), where ae are the element degrees of freedom. ae_old  are the corresponding old values \n\nstate should contain a state description for the element.  Typically, state will be a vector with a state variable for each  integration point, but it can also be any other type for each element.  On input, these are the old values and should be mutated to the updated  value for the current time step. \nThe user defined material variable usually contain the material parameters\ncellvalues should contain the cell values for the given element.  It can also be a tuple or named tuple of cellvalues. \nWhen the regular DofHandler is used, dh_fh::DofHandler is passed to the element  routine. However, if the MixedDofHandler is used, one of its fieldhandlers are passed  as dh_fh::FieldHandler. This gives the option to call dof_range(dh_fh, field::Symbol)  for multi-field problems. \nFinally, a time increment Δt and an optional materialcache are passed  into the element as well.\n\n\n\n\n\n","category":"function"},{"location":"#FerriteAssembly.element_residual!","page":"Home","title":"FerriteAssembly.element_residual!","text":"element_residual!(\n    re::AbstractVector, \n    ae::AbstractVector, ae_old::AbstractVector,\n    state, material, cellvalues, \n    dh_fh::Union{DofHandler,FieldHandler}, Δt, materialcache\n    )\n\nTo calculate the element tangent stiffness Ke automatically by using ForwardDiff, it is possible to overload element_residual! instead of element_routine!. See  element_routine! for a description of the input parameters. \n\nNote that in order for this function to work, care must be taken when mutating values to not change their types. When mutating the state, ensure to call ForwardDiff.value() on those values. Warning: Only do this at a point when the calculation of re is  unaffected by the values in state, otherwise Ke will be wrong. \n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"Variables that are used and modified for each cell of a certain type,  but that don't belong to a specific cell, are collected in a CellBuffer.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CellBuffer","category":"page"},{"location":"#FerriteAssembly.CellBuffer","page":"Home","title":"FerriteAssembly.CellBuffer","text":"CellBuffer(numdofs::Int, numnodes::Int, ::Val{dim}, cellvalues, material, cache=nothing)\n\nCreate a cell cache for an element with numdofs degrees of freedom and numnodes nodes with dimension dim. Add the given cellvalues, material,  and cache to the CellBuffer as well. \n\nCellBuffer(dh::DofHandler, cellvalues, material, cache=nothing)\n\nUse dh to get numdofs, numnodes, and dim, before calling the above method definition. \n\nCellBuffer(dh::MixedDofHandler, fh::FieldHandler, cellvalues, material, cache=nothing)\n\nUse dh and fh to get numdofs, numnodes, and dim,  before calling the first CellBuffer method definition. \n\nCellBuffer(dh::MixedDofHandler, cellvalues::Tuple, material, cache=nothing)\nCellBuffer(dh::MixedDofHandler, cellvalues::Tuple, materials::Tuple, cache=nothing)\nCellBuffer(dh::MixedDofHandler, cellvalues::Tuple, materials::Tuple, caches::Tuple)\n\nReturn a tuple of CellBuffers for each FieldHandler in dh.fieldhandlers. cellvalues[i] corresponds to dh.fieldhandlers[i], and so does  materials[i] and caches[i]. If only one material (not a tuple) is given,  the same is used for all fieldhandlers, and the same goes for cache. \n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"For parallel assembly, we need a vector of CellBuffers:  One CellBuffer for each thread. For the MixedDofHandler, we first loop over the type of cells, so we need a tuple that contains a vector of CellBuffers.  Construction of this via deepcopy is implemented as ","category":"page"},{"location":"","page":"Home","title":"Home","text":"create_threaded_CellBuffers","category":"page"},{"location":"#FerriteAssembly.create_threaded_CellBuffers","page":"Home","title":"FerriteAssembly.create_threaded_CellBuffers","text":"create_threaded_CellBuffers(c::CellBuffer; nthreads=Threads.nthreads())\ncreate_threaded_CellBuffers(cs::Tuple; nthreads=Threads.nthreads())\n\nConvenience function for creating cell buffers for each thread.  The standard workflow is to first call CellBuffer with the  dof handler. For DofHandler this will give a CellBuffer,  and for MixedDofHandler this gives a tuple of CellBuffers.  In both cases, the output can be given to create_threaded_CellBuffers to produce the appropriate result required by the threaded versions of doassemble!.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"Similarily, we need a vector of assemblers that is convieniently  created by calling ","category":"page"},{"location":"","page":"Home","title":"Home","text":"create_threaded_assemblers","category":"page"},{"location":"#FerriteAssembly.create_threaded_assemblers","page":"Home","title":"FerriteAssembly.create_threaded_assemblers","text":"create_threaded_assemblers(K, r; nthreads=Threads.nthreads())\n\nConvenience function for creating a nthreads long vector with the  output of start_assemble as elements\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"Once everything is set up, one can call the function which will actually  do the assembly:","category":"page"},{"location":"","page":"Home","title":"Home","text":"doassemble!","category":"page"},{"location":"#FerriteAssembly.doassemble!","page":"Home","title":"FerriteAssembly.doassemble!","text":"doassemble!(\n    assembler::Ferrite.AbstractSparseAssembler, cellbuffer::CellBuffer, \n    s::AbstractVector, dh::DofHandler, \n    a::AbstractVector, aold::AbstractVector, Δt::Number\n    )\n\nSequential assembly of cells with the dh::DofHandler.\n\nassembler is obtained from Ferrite.jl's start_assemble(K,r) function\ncellbuffer contains buffers for the specific cell.  See  CellBuffer for more info. \ns is a vector of state variables, where each element contains state variables for each cellnr. \na and aold are the current and old unknowns. \nΔt is the time increment passed into each element routine\n\n\n\n\n\ndoassemble!(\n    assemblers::Vector{<:Ferrite.AbstractSparseAssembler},\n    cellbuffers::Vector{<:CellBuffer}, \n    s::AbstractVector, \n    colored_sets::Vector{Vector{Int}}, dh::DofHandler, \n    a::AbstractVector, aold::AbstractVector, Δt::Number\n    )\n\nThreaded assembly of cells with the dh::DofHandler.\n\nassemblers are assemblers for each thread, which can be obtained with the create_threaded_assemblers function. \ncellbuffers contains buffers for the specific cell, for each thread. This can be created by create_threaded_CellBuffers.  See also CellBuffer for more info.\ns, a, aold, and Δt are the same as for the  sequential doassemble!\ncolored_sets are cellsets for each color\n\n\n\n\n\ndoassemble!(\n    assembler::Ferrite.AbstractSparseAssembler, \n    cellbuffers::Tuple, states::Tuple, \n    dh::MixedDofHandler, \n    a::AbstractVector, aold::AbstractVector, Δt::Number\n    )\n\nSequential assembly of cells with the dh::MixedDofHandler.\n\ncellbuffers contains buffers for the specific cell in each FieldHandler in dh.fieldhandlers See  CellBuffer for more info. \nstates is a tuple which contains vectors of state variables,  one vector for each FieldHandler in dh.fieldhandlers.  Each vector element contains the state variables for one Cell.  Note that the vector index corresponds to the cellnr in the grid,  and not in the cellset of the FieldHandler  (as this is a Set and the order is not guaranteed). Unless all cells have the same type of the state, it might make sense to use a sparse vector. \nassembler, a, aold, and Δt are the same as for the DofHandler case. \n\n\n\n\n\ndoassemble!(\n    assemblers::Vector{<:Ferrite.AbstractSparseAssembler},\n    cellbuffers::Tuple, \n    states::Tuple, \n    colored_sets::Vector{Vector{Int}}, dh::MixedDofHandler, \n    a::AbstractVector, aold::AbstractVector, Δt::Number\n    )\n\nThreaded assembly of cells with the dh::MixedDofHandler.\n\nassemblers and colored_sets are the same as for the threaded DofHandler case.\nstates are the same as for the sequential MixedDofHandler case.\ncellbuffers contains vectors Vector{CellBuffer} for the cell type in  each FieldHandler in dh.fieldhandlers. The vector element corresponds to each  thread. This can be created by create_threaded_CellBuffers.  See also CellBuffer for more info.\na, aold, and Δt are the same as for the DofHandler case.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Internal-API","page":"Internal API","title":"Internal API","text":"","category":"section"},{"location":"internals/","page":"Internal API","title":"Internal API","text":"Note that the internal API may change without being considered a breaking change!","category":"page"},{"location":"internals/","page":"Internal API","title":"Internal API","text":"FerriteAssembly.assemble_cell!\nFerriteAssembly.inner_doassemble!\nFerriteAssembly.assemble_cell_reinited!\nFerriteAssembly._copyto!","category":"page"},{"location":"internals/#FerriteAssembly.assemble_cell!","page":"Internal API","title":"FerriteAssembly.assemble_cell!","text":"assemble_cell!(assembler, cellbuffer, dh::DofHandler, cellnr, a, aold, state, Δt)\nassemble_cell!(assembler, cellbuffer, dh::MixedDofHandler, fh::FieldHandler, cellnr, a, aold, state, Δt)\n\nInternal function to that reinitializes the cellbuffer and calls assemble_cell_reinited!.\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly.inner_doassemble!","page":"Internal API","title":"FerriteAssembly.inner_doassemble!","text":"inner_doassemble!(\n    assembler, cellbuffer::CellBuffer, state, \n    dh::MixedDofHandler, fh::FieldHandler, a, aold, Δt\n    )\n\nSequential assembly of cells corresponding to the given fh  from dh.fieldhandlers.  Internal function that is called from the sequential version  of doassemble! for the MixedDofHandler\n\n\n\n\n\ninner_doassemble!(\n    assemblers::Vector{<:Ferrite.AbstractSparseAssembler},\n    cellbuffers::Vector{<:CellBuffer}, \n    states::AbstractVector, colored_sets::Vector{Vector{Int}}, \n    dh::MixedDofHandler, fh::FieldHandler, a, aold, Δt)\n\nParallel assembly of cells corresponding to the given fh from  dh.fieldhandlers. Internal function that is called from the parallel version of  doassemble! for the MixedDofHandler\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly.assemble_cell_reinited!","page":"Internal API","title":"FerriteAssembly.assemble_cell_reinited!","text":"assemble_cell_reinited!(assembler, cellbuffer::CellBuffer, dh_fh::Union{DofHandler,FieldHandler}, state, Δt)\n\nInternal function that assembles the cell described by the reinitialized cellbuffer. This function is called  in all cases: Parallel or sequential and DofHandler or MixedDofHandler\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly._copyto!","page":"Internal API","title":"FerriteAssembly._copyto!","text":"_copyto!(dest::Vector, src::Vector, inds::Vector{Int})\n\nInternal function for faster copying of global values into the element values.  Equivalent to dest .= src[inds]\n\n\n\n\n\n","category":"function"},{"location":"scaling/#Scaling","page":"Scaling","title":"Scaling","text":"","category":"section"},{"location":"scaling/","page":"Scaling","title":"Scaling","text":"Note that this part just exposes temporary docstrings  and the interface might change.","category":"page"},{"location":"scaling/","page":"Scaling","title":"Scaling","text":"Reminder: Might make sense to rename \"primary\" to \"unknowns\"? This would go better along with FESolvers","category":"page"},{"location":"scaling/","page":"Scaling","title":"Scaling","text":"FerriteAssembly.scale_primary_global!\nFerriteAssembly.unscale_primary_global!\nFerriteAssembly.unscale_primary!\nFerriteAssembly.scale_residual!","category":"page"},{"location":"scaling/#FerriteAssembly.scale_primary_global!","page":"Scaling","title":"FerriteAssembly.scale_primary_global!","text":"scale_primary_global!(a::AbstractVector, material, dofs_tuple::NamedTuple)\n\nScale the global degrees of freedom a to normalize and make unitless \n\n\n\n\n\n","category":"function"},{"location":"scaling/#FerriteAssembly.unscale_primary_global!","page":"Scaling","title":"FerriteAssembly.unscale_primary_global!","text":"unscale_primary_global!(a, material, dofs_tuple::NamedTuple)\n\nUnscale the global degrees of freedom a to get correct values for e.g. postprocessing. \n\n\n\n\n\n","category":"function"},{"location":"scaling/#FerriteAssembly.unscale_primary!","page":"Scaling","title":"FerriteAssembly.unscale_primary!","text":"unscale_primary!(ae::AbstractVector, m::AbstractMaterial, dh_fh::Union{DofHandler, FieldHandler})\n\nRemove scaling factor on the element degrees of freedom ae \n\n\n\n\n\n","category":"function"},{"location":"scaling/#FerriteAssembly.scale_residual!","page":"Scaling","title":"FerriteAssembly.scale_residual!","text":"scale_residual!(Ke::AbstractMatrix, re::AbstractVector, m::AbstractMaterial, dh_fh::Union{DofHandler, FieldHandler})\n\nScale the element stiffness, Ke, and residual, re to normalize wrt. units \n\n\n\n\n\n","category":"function"}]
}
