var documenterSearchIndex = {"docs":
[{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"EditURL = \"https://github.com/KnutAM/FerriteAssembly.jl/blob/main/docs/src/literate/plasticity.jl\"","category":"page"},{"location":"examples/plasticity/#Plasticity","page":"Plasticity","title":"Plasticity","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This example shows how any material following the MaterialModelsBase.jl interface can be assembled with FerriteAssembly.jl. We start by the required packages","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"using Tensors, MaterialModelsBase, Ferrite, FerriteAssembly","category":"page"},{"location":"examples/plasticity/#Material-model","page":"Plasticity","title":"Material model","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We use the simple plasticity model from Ferrite.jl's example. First, we define the required material struct","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"struct J2Plasticity{T, S <: SymmetricTensor{4, 3, T}} <: AbstractMaterial\n    G::T  # Shear modulus\n    K::T  # Bulk modulus\n    σ₀::T # Initial yield limit\n    H::T  # Hardening modulus\n    Dᵉ::S # Elastic stiffness tensor\nend\nfunction elastic_conversion(E, ν)\n    δ(i,j) = i == j ? 1.0 : 0.0 # helper function\n    G = E / 2(1 + ν)\n    K = E / 3(1 - 2ν)\n\n    Isymdev(i,j,k,l) = 0.5*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k)) - 1.0/3.0*δ(i,j)*δ(k,l)\n    temp(i,j,k,l) = 2.0G *( 0.5*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k)) + ν/(1.0-2.0ν)*δ(i,j)*δ(k,l))\n    Dᵉ = SymmetricTensor{4, 3}(temp)\n    return Dᵉ, G, K\nend\nfunction J2Plasticity(E, ν, σ₀, H)\n    Dᵉ, G, K = elastic_conversion(E, ν)\n    return J2Plasticity(G, K, σ₀, H, Dᵉ)\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"And the state variable struct","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"struct MaterialState{T, S <: SecondOrderTensor{3, T}} <: AbstractMaterialState\n    ϵᵖ::S # plastic strain\n    σ::S # stress\n    k::T # hardening variable\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Then the initial material state function","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function MaterialModelsBase.initial_material_state(::J2Plasticity)\n    return MaterialState(zero(SymmetricTensor{2,3}), zero(SymmetricTensor{2,3}), 0.0)\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"And finally the material_response function","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function MaterialModelsBase.material_response(\n    material::J2Plasticity, ϵ::SymmetricTensor{2,3}, state::MaterialState,\n    Δt, cache=get_cache(material), args...; kwargs...)\n    # unpack some material parameters\n    G = material.G\n    H = material.H\n\n    # We use (•)ᵗ to denote *trial*-values\n    σᵗ = material.Dᵉ ⊡ (ϵ - state.ϵᵖ) # trial-stress\n    sᵗ = dev(σᵗ)         # deviatoric part of trial-stress\n    J₂ = 0.5 * sᵗ ⊡ sᵗ  # second invariant of sᵗ\n    σᵗₑ = sqrt(3.0*J₂)   # effective trial-stress (von Mises stress)\n    σʸ = material.σ₀ + H * state.k # Previous yield limit\n\n    φᵗ  = σᵗₑ - σʸ # Trial-value of the yield surface\n\n    if φᵗ < 0.0 # elastic loading\n        return σᵗ, material.Dᵉ, MaterialState(state.ϵᵖ, σᵗ, state.k)\n    else # plastic loading\n        h = H + 3G\n        μ =  φᵗ / h   # plastic multiplier\n\n        c1 = 1 - 3G * μ / σᵗₑ\n        s = c1 * sᵗ           # updated deviatoric stress\n        σ = s + vol(σᵗ)       # updated stress\n\n        # Compute algorithmic tangent stiffness ``D = \\frac{\\Delta \\sigma }{\\Delta \\epsilon}``\n        κ = H * (state.k + μ) # drag stress\n        σₑ = material.σ₀ + κ  # updated yield surface\n\n        δ(i,j) = i == j ? 1.0 : 0.0\n        Isymdev(i,j,k,l)  = 0.5*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k)) - 1.0/3.0*δ(i,j)*δ(k,l)\n        Q(i,j,k,l) = Isymdev(i,j,k,l) - 3.0 / (2.0*σₑ^2) * s[i,j]*s[k,l]\n        b = (3G*μ/σₑ) / (1.0 + 3G*μ/σₑ)\n\n        Dtemp(i,j,k,l) = -2G*b * Q(i,j,k,l) - 9G^2 / (h*σₑ^2) * s[i,j]*s[k,l]\n        D = material.Dᵉ + SymmetricTensor{4, 3}(Dtemp)\n\n        # Return new state\n        Δϵᵖ = 3/2 * μ / σₑ * s # plastic strain\n        ϵᵖ = state.ϵᵖ + Δϵᵖ    # plastic strain\n        k = state.k + μ        # hardening variable\n        return σ, D, MaterialState(ϵᵖ, σ, k)\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Element-routine","page":"Plasticity","title":"Element routine","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"The element routine for any material that follows the MaterialModelsBase.jl interface can be coded as follows:","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function FerriteAssembly.element_routine!(\n    Ke::AbstractMatrix, re::AbstractVector, state::Vector{<:AbstractMaterialState},\n    ae::AbstractVector, material::AbstractMaterial, cellvalues::CellVectorValues, dh_fh, Δt, buffer::CellBuffer)\n    cache = buffer.cache\n    n_basefuncs = getnbasefunctions(cellvalues)\n    for q_point in 1:getnquadpoints(cellvalues)\n        # For each integration point, compute stress and material stiffness\n        ϵ = function_symmetric_gradient(cellvalues, q_point, ae) # Total strain\n        σ, D, state[q_point] = material_response(material, ϵ, state[q_point], Δt, cache)\n\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:n_basefuncs\n            δϵ = shape_symmetric_gradient(cellvalues, q_point, i)\n            re[i] += (δϵ ⊡ σ) * dΩ ## add internal force to residual\n            for j in 1:n_basefuncs\n                Δϵ = shape_symmetric_gradient(cellvalues, q_point, j)\n                Ke[i, j] += δϵ ⊡ D ⊡ Δϵ * dΩ\n            end\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Note that the boundary traction was not included, as this can be handled separately with FerriteNeumann.jl","category":"page"},{"location":"examples/plasticity/#Assembly","page":"Plasticity","title":"Assembly","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"With all required functions defined, we can now setup and assemble the finite element problem","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"material = J2Plasticity(200.0e9, 0.3, 200.0e6, 10.0e9);\ngrid = generate_grid(Tetrahedron, (20,2,4), zero(Vec{3}), Vec((10.0,1.0,1.0)));\ncellvalues = CellVectorValues(\n    QuadratureRule{3,RefTetrahedron}(2), Lagrange{3, RefTetrahedron, 1}());\ndh = DofHandler(grid); push!(dh, :u, 3); close!(dh); # Create dofhandler\nK = create_sparsity_pattern(dh);\nr = zeros(ndofs(dh));\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Using the create_states function, we can easily create the storage of state variables suitable for the chosen dof handler","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"states = create_states(dh, _->initial_material_state(material), cellvalues);\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"And then we create the buffer for saving cell-related variables","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"buffer = CellBuffer(dh, cellvalues, material, nothing, get_cache(material));\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Finally, with an initial guess of displacements, a, we can create the assembler and do the assembly","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"a = zeros(ndofs(dh))\nassembler = start_assemble(K,r)\ndoassemble!(assembler, buffer, states, dh, a);\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FerriteAssembly","category":"page"},{"location":"#FerriteAssembly","page":"Home","title":"FerriteAssembly","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The goal of FerriteAssembly  is to provide a simple structure to perform assembly in  Ferrite.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Sequential and threaded assembly of both the DofHandler and MixedDofHandler are supported.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package works by exporting the doassemble! function, and require the  user to define either element_routine! (calculate both Ke and re), or just element_residual! (calculate only re).  In the latter case, Ke is calculated by  ForwardDiff.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dispatch is typically done on a user-defined material struct, and possible as well on cellvalues (potentially a NamedTuple/Tuple). State variables and current dof-values for the cell are directly available in the element_routine! Old dof-values for the cell, user-defined cache and cell_load types, cell coordinates and more  are available through the CellBuffer type given as additional input. ","category":"page"},{"location":"#A-minimal-example","page":"Home","title":"A minimal example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Include the example here, but modify the Literate output to suit being embedded\nusing Literate, Markdown\nfilename = \"firstexample_literate\"\nLiterate.markdown(filename*\".jl\")\ncontents = read(filename*\".md\", String)\nLiterate.script(filename*\".jl\"; name=\"firstexample\")\nrm(filename*\".jl\")\nrm(filename*\".md\")\nheader_end = last(findnext(\"```\", contents, 4))+1\nMarkdown.parse(replace(contents[header_end:end], \n    \"*This page was generated using [Literate.jl]\"=>\"*The examples were generated using [Literate.jl]\")\n    )","category":"page"},{"location":"#Detailed-API-description","page":"Home","title":"Detailed API description","text":"","category":"section"},{"location":"#Overloaded-element-routine","page":"Home","title":"Overloaded element routine","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"One of the element methods should be overloaded for a given combination of cellvalues and material.","category":"page"},{"location":"","page":"Home","title":"Home","text":"FerriteAssembly.element_routine!\nFerriteAssembly.element_residual!","category":"page"},{"location":"#FerriteAssembly.element_routine!","page":"Home","title":"FerriteAssembly.element_routine!","text":"element_routine!(\n    Ke::AbstractMatrix, re::AbstractVector, state,\n    ae::AbstractVector, material, cellvalues, \n    dh_fh::Union{DofHandler,FieldHandler}, Δt, buffer\n    )\n\nThe main function to be overloaded for the specific material and cellvalues. This function should modify the element stiffness matrix Ke and the residual re.\n\nstate should contain a state description for the element.  Typically, state will be a vector with a state variable for each  integration point, but it can also be any other type for each element.  On input, these are the old values and should be mutated to the updated  value for the current time step and guess for ae. \nThe user defined material variable usually contain the material parameters. \ncellvalues should contain the CellValues for the given element.  It can also be a tuple or named tuple of cellvalues. \nWhen the regular DofHandler is used, dh_fh::DofHandler is passed to the element  routine. However, if the MixedDofHandler is used, one of its fieldhandlers are passed  as dh_fh::FieldHandler. This gives the option to call dof_range(dh_fh, field::Symbol)  for multi-field problems. \nΔt is time increment given to doassemble\nbuffer is normally CellBuffer (if given to doassemble). Then, it can be used to get \nbuffer.ae_old: The old values of the displacements (if aold::Nothing is passed to  doassemble, buffer.ae_old will be NaNs)\nbuffer.cell_load: The cell_load passed to CellBuffer, typically used for  body loads or source terms. \nbuffer.cache: The cache passed to CellBuffer, typically used to gather all  preallocations if such are necessary\ngetcoordinates(buffer)::Vector{Vec}: The cell's coordinates\ncelldofs(buffer)::Vector{Int}: The cell's global degrees of freedom numbers\n\n\n\n\n\n","category":"function"},{"location":"#FerriteAssembly.element_residual!","page":"Home","title":"FerriteAssembly.element_residual!","text":"element_residual!(\n    re::AbstractVector, state, \n    ae::AbstractVector, material, cellvalues, \n    dh_fh::Union{DofHandler,FieldHandler}, Δt, buffer\n    )\n\nTo calculate the element tangent stiffness Ke automatically by using ForwardDiff, it is possible to overload element_residual! instead of element_routine!. See  element_routine! for a description of the input parameters. \n\nNote that in order for this function to work, care must be taken when mutating values to not change their types. When mutating the state, ensure to call ForwardDiff.value() on those values. Warning: Only do this at a point when the calculation of re is  unaffected by the values in state, otherwise Ke will be wrong. \n\n\n\n\n\n","category":"function"},{"location":"#CellBuffer","page":"Home","title":"CellBuffer","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Variables that are used and modified for each cell of a certain type,  but that don't belong to a specific cell, are collected in a CellBuffer.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CellBuffer","category":"page"},{"location":"#FerriteAssembly.CellBuffer","page":"Home","title":"FerriteAssembly.CellBuffer","text":"CellBuffer(\n    numdofs::Int, numnodes::Int, ::Val{dim}, \n    cellvalues, material, cell_load=nothing, cache=nothing)\n\nCreate a cell cache for an element with numdofs degrees of freedom and numnodes nodes with dimension dim. Add the given cellvalues, material,  and cache to the CellBuffer as well. \n\nCellBuffer(\n    dh::DofHandler, \n    cellvalues, material, cell_load=nothing, cache=nothing)\n\nUse dh to get numdofs, numnodes, and dim, before calling the above method definition. \n\nCellBuffer(\n    dh::MixedDofHandler, fh::FieldHandler, \n    cellvalues, material, cell_load=nothing, cache=nothing)\n\nUse dh and fh to get numdofs, numnodes, and dim,  before calling the first CellBuffer method definition. \n\nCellBuffer(\n    dh::MixedDofHandler, cellvalues, \n    material, cell_load=nothing, cache=nothing)\n\nReturn a tuple of CellBuffers for each FieldHandler in dh.fieldhandlers. cellvalues[i] corresponds to dh.fieldhandlers[i], and so does  materials[i], cell_load[i] and caches[i]. If only one CellValues, material, cell_load, and/or cache is given (not as a ::Tuple), the same is used for all fieldhandlers.  If a tuple of cellvalues (or materials/cell_load/caches) should be used for each cell,  and the same tuple should be used for each fieldhandler,  then it must be given as a tuple of tuples.  (Often, it is better to give a NamedTuple of e.g. CellValues to be used for every fieldhandler)\n\nThe Ferrite.jl functions getcoordinates(::CellBuffer) and celldofs(::CellBuffer) are defined and can  be used inside an element routine to get the current cell's coordinates and dof-numbers. \n\n\n\n\n\n","category":"type"},{"location":"#State-variables","page":"Home","title":"State variables","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The initial state variables may vary depending on the position in the grid. Furthermore, the datastructure depends on the type of dof handler, so a convenience function exists that creates the correct variable","category":"page"},{"location":"","page":"Home","title":"Home","text":"create_states","category":"page"},{"location":"#FerriteAssembly.create_states","page":"Home","title":"FerriteAssembly.create_states","text":"create_states(dh::DofHandler, \n    statefun::Function=Returns(nothing), \n    cellvalues::Union{CellValues,Nothing}=nothing)\n\ncreate_states(dh::DofHandler, \n    statefun::Function, \n    cellvalues::Union{CellValues,Nothing},\n    cellset)\n\nCreates a Vector of states for each cell in dh, where a state=statefun(x::Vec) and x is  the coordinate in the grid. If isnothing(cellvalues), then the statefun is called once for  the average nodal coordinate of each cell. Otherwise, it is called once per quadrature point in  cellvalues for that cell.\n\nIf a cellset is given a Dict{Int,typeof(statefun(x))} is returned, mapping the cellnr to the  state for the cellnumbers in cellset.  This is typically used if multiple materials are used on the same grid,  and in this case statefun and cellvalues must be given \n\n\n\n\n\ncreate_states(dh::MixedDofHandler, \n    statefun::Union{Function,Tuple}=Returns(nothing), \n    cellvalues::Union{CellValues,Tuple,Nothing}=nothing,\n    cellset=nothing\n    )\n\nCreates a Tuple of the output of the following function for each fieldhandler in dh. If statefuns and/or cellvalues are not tuples, the same value is used for each fieldhandler. \n\ncreate_states(dh::MixedDofHandler, fh::FieldHandler, \n    statefun::Function, cellvalues::Union{Nothing,CellValues}, cellset)\n\nReturns a Dict{Int} with states for each cell in fh's cellset and keys corresponding to the global cellid If isnothing(cellvalues), then the statefun(x::Vec) is called once for the average nodal coordinate x of each cell.  Otherwise, it is called once for each quadrature point location x given by cellvalues for that cell.  If a cellset!=nothing is given, states are only created for the intersection of that cellset and the fieldhandlers cellset \n\n\n\n\n\n","category":"function"},{"location":"#doassemble!","page":"Home","title":"doassemble!","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Once everything is set up, one can call the function which will actually  do the assembly:","category":"page"},{"location":"","page":"Home","title":"Home","text":"doassemble!","category":"page"},{"location":"#FerriteAssembly.doassemble!","page":"Home","title":"FerriteAssembly.doassemble!","text":"doassemble!(\n    assembler::Ferrite.AbstractSparseAssembler, cellbuffer::CellBuffer, \n    s::AbstractVector, dh::DofHandler, \n    a=nothing, aold=nothing, Δt=nothing\n    )\n\nSequential assembly of cells with the dh::DofHandler.\n\nassembler is obtained from Ferrite.jl's start_assemble(K,r) function\ncellbuffer contains buffers for the specific cell.  See  CellBuffer for more info. \ns is a collection (vector, dict, etc.) of state variables, where indexing  by cellnr gives the state variables for that cell. \na and aold are the current and old unknowns (can be set to nothing if not used)\nΔt is the time increment passed into each element routine\n\n\n\n\n\ndoassemble!(\n    assemblers::Vector{<:Ferrite.AbstractSparseAssembler},\n    cellbuffers::Vector{<:CellBuffer}, states, \n    colored_sets::Vector{Vector{Int}}, dh::DofHandler, \n    a=nothing, aold=nothing, Δt=nothing\n    )\n\nThreaded assembly of cells with the dh::DofHandler.\n\nassemblers are assemblers for each thread, which can be obtained with the create_threaded_assemblers function. \ncellbuffers contains buffers for the specific cell, for each thread. This can be created by create_threaded_CellBuffers.  See also CellBuffer for more info.\nstates, a, aold, and Δt are the same as for the  sequential doassemble!\ncolored_sets are cellsets for each color\n\n\n\n\n\ndoassemble!(\n    assembler::Ferrite.AbstractSparseAssembler, \n    cellbuffers::Tuple, states::Tuple, \n    dh::MixedDofHandler, \n    a=nothing, aold=nothing, Δt=nothing\n    )\n\nSequential assembly of cells with the dh::MixedDofHandler.\n\ncellbuffers contains buffers for the specific cell in each FieldHandler in dh.fieldhandlers See  CellBuffer for more info. \nstates is a tuple which contains a collection of state variables,  one vector for each FieldHandler in dh.fieldhandlers.  Each element in the collection, i.e. states[cellnr], contains the  state variables for one Cell with global number cellnr.  Unless all cells have the same type of the state, it might make sense to use a  Dict{Int,State} where the key refers to the global number. \nassembler, a, aold, and Δt are the same as for the DofHandler case. \n\n\n\n\n\ndoassemble!(\n    assemblers::Vector{<:Ferrite.AbstractSparseAssembler},\n    cellbuffers::Tuple, \n    states::Tuple, \n    colored_sets::Vector{Vector{Int}}, dh::MixedDofHandler, \n    a::AbstractVector, aold::AbstractVector, Δt::Number\n    )\n\nThreaded assembly of cells with the dh::MixedDofHandler.\n\nassemblers and colored_sets are the same as for the threaded DofHandler case.\nstates are the same as for the sequential MixedDofHandler case.\ncellbuffers contains vectors Vector{CellBuffer} for the cell type in  each FieldHandler in dh.fieldhandlers. The vector element corresponds to each  thread. This can be created by create_threaded_CellBuffers.  See also CellBuffer for more info.\na, aold, and Δt are the same as for the DofHandler case.\n\n\n\n\n\n","category":"function"},{"location":"#Threaded-assembly","page":"Home","title":"Threaded assembly","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For parallel assembly, we need a vector of CellBuffers and assemblers,  one for each thread. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the MixedDofHandler, the outer loop is over the type of cells, so we need a tuple that contains vectors of CellBuffers.  Construction of this via deepcopy is implemented as","category":"page"},{"location":"","page":"Home","title":"Home","text":"create_threaded_CellBuffers","category":"page"},{"location":"#FerriteAssembly.create_threaded_CellBuffers","page":"Home","title":"FerriteAssembly.create_threaded_CellBuffers","text":"create_threaded_CellBuffers(c::CellBuffer; nthreads=Threads.nthreads())\ncreate_threaded_CellBuffers(cs::Tuple; nthreads=Threads.nthreads())\n\nConvenience function for creating cell buffers for each thread.  The standard workflow is to first call CellBuffer with the  dof handler. For DofHandler this will give a CellBuffer,  and for MixedDofHandler this gives a tuple of CellBuffers.  In both cases, the output can be given to create_threaded_CellBuffers to produce the appropriate result required by the threaded versions of doassemble!.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"A vector of assemblers that is convieniently created by calling ","category":"page"},{"location":"","page":"Home","title":"Home","text":"create_threaded_assemblers","category":"page"},{"location":"#FerriteAssembly.create_threaded_assemblers","page":"Home","title":"FerriteAssembly.create_threaded_assemblers","text":"create_threaded_assemblers(K, r; nthreads=Threads.nthreads())\n\nConvenience function for creating a nthreads long vector with the  output of start_assemble as elements\n\n\n\n\n\n","category":"function"},{"location":"internals/#Internal-API","page":"Internal API","title":"Internal API","text":"","category":"section"},{"location":"internals/","page":"Internal API","title":"Internal API","text":"Note that the internal API may change without being considered a breaking change!","category":"page"},{"location":"internals/","page":"Internal API","title":"Internal API","text":"FerriteAssembly.assemble_cell!\nFerriteAssembly.inner_doassemble!\nFerriteAssembly.assemble_cell_reinited!\nFerriteAssembly._copydofs!\nFerriteAssembly._maketuple\nFerriteAssembly.create_state\nFerriteAssembly.reinit!\nFerriteAssembly.intersect_nothing","category":"page"},{"location":"internals/#FerriteAssembly.assemble_cell!","page":"Internal API","title":"FerriteAssembly.assemble_cell!","text":"assemble_cell!(assembler, cellbuffer, dh::DofHandler, cellnr, a, aold, state, Δt)\nassemble_cell!(assembler, cellbuffer, dh::MixedDofHandler, fh::FieldHandler, cellnr, a, aold, state, Δt)\n\nInternal function to that reinitializes the cellbuffer and calls assemble_cell_reinited!.\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly.inner_doassemble!","page":"Internal API","title":"FerriteAssembly.inner_doassemble!","text":"inner_doassemble!(\n    assembler, cellbuffer::CellBuffer, states, \n    dh::MixedDofHandler, fh::FieldHandler, a, aold, Δt\n    )\n\nSequential assembly of cells corresponding to the given fh  from dh.fieldhandlers.  Internal function that is called from the sequential version  of doassemble! for the MixedDofHandler\n\n\n\n\n\ninner_doassemble!(\n    assemblers::Vector{<:Ferrite.AbstractSparseAssembler},\n    cellbuffers::Vector{<:CellBuffer}, states, \n    colored_sets::Vector{Vector{Int}}, \n    dh::MixedDofHandler, fh::FieldHandler, a, aold, Δt)\n\nParallel assembly of cells corresponding to the given fh from  dh.fieldhandlers. Internal function that is called from the parallel version of  doassemble! for the MixedDofHandler\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly.assemble_cell_reinited!","page":"Internal API","title":"FerriteAssembly.assemble_cell_reinited!","text":"assemble_cell_reinited!(assembler, cellbuffer, dh_fh::Union{DofHandler,FieldHandler}, state, Δt)\n\nInternal function that assembles the cell described by the reinitialized cellbuffer. This function is called  in all cases: Parallel or sequential and DofHandler or MixedDofHandler\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly._copydofs!","page":"Internal API","title":"FerriteAssembly._copydofs!","text":"_copydofs!(edofs::Vector, gdofs::Vector, inds::Vector{Int})\n\nInternal function for faster copying of global values into the element values.  Equivalent to edofs .= gdofs[inds]     _copydofs!(edofs::Vector, gdofs::Nothing, inds::Vector{Int})\n\nFill edofs with NaN\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly._maketuple","page":"Internal API","title":"FerriteAssembly._maketuple","text":"_maketuple(t, n)\n\nIf t is a tuple, check that length(t)=n and return t.  Otherwise, return a tuple of length n with t as every element\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly.create_state","page":"Internal API","title":"FerriteAssembly.create_state","text":"create_state(statefun, cell, cv::Nothing)\ncreate_state(statefun, cell, cv::CellValues)\n\nInternal functions for calling statefun(x) for the cell center  if cv::Nothing or for each quadrature point if cv::CellValues.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Ferrite.reinit!","page":"Internal API","title":"Ferrite.reinit!","text":"Ferrite.reinit!(c::CellBuffer, dh::AbstractDofHandler, cellnum::Int, anew, aold)\n\nReinitialize the c::CellBuffer for cell number cellnum. The global degree of freedom vectors anew (current) and aold are used to update the cell degree of freedom vectors in c. If the global vectors are instead ::Nothing, the corresponding cell values are set to NaN The element stiffness, c.Ke, and residual, c.re, are also zeroed. \n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly.intersect_nothing","page":"Internal API","title":"FerriteAssembly.intersect_nothing","text":"intersect_nothing(a, b)\n\nA faster intersect if cellset::Nothing, otherwise calls Base.intersect\n\n\n\n\n\n","category":"function"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"EditURL = \"https://github.com/KnutAM/FerriteAssembly.jl/blob/main/docs/src/literate/mixed_materials.jl\"","category":"page"},{"location":"examples/mixed_materials/#Multiple-materials","page":"Multiple materials","title":"Multiple materials","text":"","category":"section"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"This example shows how to use two different materials on a grid with the same cells everywhere. Hence, the only difference is the type of material and the state variables. We start by including the necessary packages, as well as the J2Plasticity.jl and MaterialModelsBaseElement.jl files from the previous example.","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"using Tensors, MaterialModelsBase, Ferrite, FerriteAssembly\ninclude(\"J2Plasticity.jl\");\ninclude(\"MaterialModelsBaseElement.jl\");\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"Then, we also define an elastic material","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"struct ElasticMaterial{T<:SymmetricTensor{4,3}} <: AbstractMaterial\n    D::T\nend\nfunction ElasticMaterial(;E, ν)\n    D, _, _ = elastic_conversion(E, ν)\n    return ElasticMaterial(D)\nend;\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"This material requires not state, so MaterialModelsBase.jl's NoMaterialState will be created by default. Hence, we only need to define the material_response","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"function MaterialModelsBase.material_response(\n    material::ElasticMaterial, ϵ::SymmetricTensor{2,3}, state,\n    Δt, cache=get_cache(material), args...; kwargs...)\n    σ = material.D ⊡ ϵ\n    return σ, material.D, NoMaterialState()\nend;\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"The same element_routine! as before can be used, defined in MaterialModelsBaseElement.jl. Hence, we just need to define the materials, grid, cellvalues etc.","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"material_pl = J2Plasticity(200.0e9, 0.3, 200.0e6, 10.0e9);\nmaterial_el = ElasticMaterial(E=200.0e9, ν=0.3);\ngrid = generate_grid(Tetrahedron, (20,2,4), zero(Vec{3}), Vec((10.0,1.0,1.0)));\ncellvalues = CellVectorValues(\n    QuadratureRule{3,RefTetrahedron}(2), Lagrange{3, RefTetrahedron, 1}());\ndh = DofHandler(grid); push!(dh, :u, 3); close!(dh); # Create dofhandler\nK = create_sparsity_pattern(dh);\nr = zeros(ndofs(dh));\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"We then define the cellsets where we have each material","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"addcellset!(grid, \"elastic\", x -> x[1] <= 5.0+eps())\nset_el = getcellset(grid, \"elastic\");\naddcellset!(grid, \"plastic\", setdiff(1:getncells(grid), set_el));\nset_pl = getcellset(grid, \"plastic\");\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"The key to handling multiple materials, with different state variables, using the regular DofHandler or a single FieldHandler (in the MixedDofHandler case) is to create multiple state variables, and call doassemble! for each of them:","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"states_el = create_states(dh, _->initial_material_state(material_el), cellvalues, set_el);\nstates_pl = create_states(dh, _->initial_material_state(material_pl), cellvalues, set_pl);\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"We also need buffers for each material","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"buffer_el = CellBuffer(dh, cellvalues, material_el, nothing, get_cache(material_el));\nbuffer_pl = CellBuffer(dh, cellvalues, material_pl, nothing, get_cache(material_pl));\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"And then we define the displacements and the assembler, before assembling","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"a = zeros(ndofs(dh))\nassembler = start_assemble(K, r)\ndoassemble!(assembler, buffer_el, states_el, dh, a; cellset=set_el);\ndoassemble!(assembler, buffer_pl, states_pl, dh, a; cellset=set_pl);\n\nusing Test #hide\nK_ref = create_sparsity_pattern(dh); #hide\nr_ref = zeros(ndofs(dh)); #hide\nstates = create_states(dh, _->initial_material_state(material_el), cellvalues); #hide\na_ref = zeros(ndofs(dh)) #hide\nassembler_ref = start_assemble(K_ref,r_ref) #hide\ndoassemble!(assembler_ref, buffer_el, states, dh, a_ref); #hide\n@test K ≈ K_ref; #hide\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"This page was generated using Literate.jl.","category":"page"}]
}
