var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = FerriteAssembly","category":"page"},{"location":"#FerriteAssembly","page":"Home","title":"FerriteAssembly","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The goal of FerriteAssembly  is to provide a simple structure to perform assembly in  Ferrite.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Both the DofHandler and MixedDofHandler are supported. Currently only sequential assembly, but this will be extended  to threaded assembly.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package work by exporting the doassemble! function, and requires the  user to define either element_routine! (calculate both Ke and re), or just element_residual! (calculate only re).  In the latter case, Ke is calculated by  ForwardDiff.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"An advanced option to scale the unknowns, residual, and jacobian exists  (currently undocumented)","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#A-first-example","page":"Home","title":"A first example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We take a slightly modified element routine from Ferrite.jl's heat equation  example. We assume that we already have defined dh::DofHandler and our  cellvalues::CellScalarValues according to that example. We then define","category":"page"},{"location":"","page":"Home","title":"Home","text":"struct ThermalMaterial end\nmaterial = ThermalMaterial()","category":"page"},{"location":"","page":"Home","title":"Home","text":"and our element_routine! for that material as ","category":"page"},{"location":"","page":"Home","title":"Home","text":"function FerriteAssembly.element_routine!(\n    Ke::AbstractMatrix, re::AbstractVector, \n    ae_new::AbstractVector, ae_old::AbstractVector,\n    state::AbstractVector, material::ThermalMaterial, \n    cellvalues::CellScalarValues, \n    dh_fh::Union{DofHandler,FieldHandler}, Δt, materialcache\n    )\n    n_basefuncs = getnbasefunctions(cellvalues)\n    # Loop over quadrature points\n    for q_point in 1:getnquadpoints(cellvalues)\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:n_basefuncs\n            δu  = shape_value(cellvalues, q_point, i)\n            ∇δu = shape_gradient(cellvalues, q_point, i)\n            # Add body load contribution to re\n            re[i] += -δu * dΩ\n            # Loop over trial shape functions\n            for j in 1:n_basefuncs\n                ∇u = shape_gradient(cellvalues, q_point, j)\n                # Add contribution to Ke\n                Ke[i, j] += (∇δu ⋅ ∇u) * dΩ\n            end\n        end\n    end\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can now create the global vectors and matrices, as well as the time step","category":"page"},{"location":"","page":"Home","title":"Home","text":"K = create_sparsity_pattern(dh)\na=zeros(ndofs(dh)); aold=copy(a);\nr = zeros(ndofs(dh))\nΔt=1.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"Before we can assemble, we need our cellcache (to avoid unecessary allocations  inside the assembly loop). But this is created automatically from the DofHandler:","category":"page"},{"location":"","page":"Home","title":"Home","text":"cache = CellCache(dh)","category":"page"},{"location":"","page":"Home","title":"Home","text":"And then we can assemble our system by calling ","category":"page"},{"location":"","page":"Home","title":"Home","text":"doassemble!(K, r, a, aold, states, dh, cv, material, Δt, cache)","category":"page"},{"location":"#Detailed-API-description","page":"Home","title":"Detailed API description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"One of the element methods should be overloaded for a given combination of cellvalues and material.","category":"page"},{"location":"","page":"Home","title":"Home","text":"FerriteAssembly.element_routine!\nFerriteAssembly.element_residual!","category":"page"},{"location":"#FerriteAssembly.element_routine!","page":"Home","title":"FerriteAssembly.element_routine!","text":"element_routine!(\n    Ke::AbstractMatrix, re::AbstractVector, \n    ae::AbstractVector, ae_old::AbstractVector,\n    state, material, cellvalues, \n    dh_fh::Union{DofHandler,FieldHandler}, Δt, materialcache\n    )\n\nThe main function to be overloaded for the specific material and cellvalues. This function should modify the residual r and the element stiffness matrix Ke, such that Ke=∂(re)/∂(ae), where ae are the element degrees of freedom. ae_old  are the corresponding old values \n\nstate should contain a state description for the element.  Typically, state will be a vector with a state variable for each  integration point, but it can also be any other type for each element.  On input, these are the old values and should be mutated to the updated  value for the current time step. \nThe user defined material variable usually contain the material parameters\ncellvalues should contain the cell values for the given element.  It can also be a tuple or named tuple of cellvalues. \nWhen the regular DofHandler is used, dh_fh::DofHandler is passed to the element  routine. However, if the MixedDofHandler is used, one of its fieldhandlers are passed  as dh_fh::FieldHandler. This gives the option to call dof_range(dh_fh, field::Symbol)  for multi-field problems. \nFinally, a time increment Δt and an optional materialcache are passed  into the element as well.\n\n\n\n\n\n","category":"function"},{"location":"#FerriteAssembly.element_residual!","page":"Home","title":"FerriteAssembly.element_residual!","text":"element_residual!(\n    re::AbstractVector, \n    ae::AbstractVector, ae_old::AbstractVector,\n    state, material, cellvalues, \n    dh_fh::Union{DofHandler,FieldHandler}, Δt, materialcache\n    )\n\nTo calculate the element tangent stiffness Ke automatically by using ForwardDiff, it is possible to overload element_residual! instead of element_routine!. See  element_routine! for a description of the input parameters. \n\nNote that in order for this function to work, care must be taken when mutating values to not change their types. When mutating the state, ensure to call ForwardDiff.value() on those values. Warning: Only do this at a point when the calculation of re is  unaffected by the values in state, otherwise Ke will be wrong. \n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"The allocations are reduced by saving all variables to a cellcache,  which is automatically created by giving it the dof handler:","category":"page"},{"location":"","page":"Home","title":"Home","text":"CellCache","category":"page"},{"location":"#FerriteAssembly.CellCache","page":"Home","title":"FerriteAssembly.CellCache","text":"CellCache(n::Int, materialcache=nothing)\n\nCreate a cell cache for an element with n degrees of freedom, as well as with materialcache\n\nCellCache(dh::DofHandler, materialcache=nothing)\n\nCreate a cell cache with the number of element degrees of freedom  according to the dof handler dh, as well as with materialcache\n\nCellCache(dh::MixedDofHandler, fh::FieldHandler, materialcache=nothing)\n\nCreate a cell cache with the number of element degrees of freedom  according to the mixed dof handler dh for its fieldhandler fh. Include also the materialcache\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"Once everything is set up, one can call the function which will actually  do the assembly:","category":"page"},{"location":"","page":"Home","title":"Home","text":"doassemble!","category":"page"},{"location":"#FerriteAssembly.doassemble!","page":"Home","title":"FerriteAssembly.doassemble!","text":"doassemble!(\n    K::AbstractMatrix, r::AbstractVector, a::AbstractVector, \n    aold::AbstractVector, s::AbstractVector, dh::DofHandler, \n    cellvalues, material, Δt::Number, cache::CellCache, \n    cellset=nothing\n    )\n\nAssemble all cells by using dh::DofHandler.\n\nK, and r are the global stiffness matrix and residual  vector to be calculated. \na and aold are the current and old unknowns. \ns is a vector of state variables, where each element contains state variables for each cellid.  If cellset is given (see below), the number is still the cellid, and in some cases it might make sense to pass a sparse vector. \ncellvalues are passed on to the element routine  after calling Ferrite.reinit!. (Multiple cellvalues  can be given as a Tuple or NamedTuple, and all elements will be reinitialized)\nThe user-defined material and the time increment Δt are passed into the element routine. \ncache is described in CellCache.\ncellset can be used to only assemble parts of the  cells, if e.g. we have different materials for different parts  of the grid. cellset=nothing implies assembly of all cells. \n\n\n\n\n\ndoassemble!(\n    K::AbstractMatrix, r::AbstractVector, anew::AbstractVector, \n    aold::AbstractVector, state::Tuple, dh::MixedDofHandler, \n    cellvalues::Tuple, materials::Tuple, Δt::Number, caches::Tuple,\n    fullcellset=nothing\n    )\n\nAssemble all cells by using dh::MixedDofHandler. In this case,  we first loop over each fieldhandler in dh. Therefore,  some variables must now be given as tuples, where each element corresponds  to the values in the specific fieldhandler. \n\nK, and r are the global stiffness matrix and residual  vector to be calculated. \na and aold are the current and old unknowns. \ns is a tuple of vectors of state variables. Each element, s[i], corresponds to the ith element in dh.fieldhandlers.  The jth element of s[i]::AbstractVector, contains the state variables  for cellid=j. If the state-type differs for multiple fieldhandlers, it  might make sense to use sparse vectors. \ncellvalues is a tuple with one element for each fieldhandler.  For each fieldhandler i, cellvalues[i] is passed to the element  routine after calling Ferrite.reinit!. (Multiple cellvalues can  be given by making cellvalues[i] a Tuple or NamedTuple.  All elements will be reinitialized)\nThe user-defined material and the time increment Δt are passed into the element routine. Finally,\ncaches is a tuple with CellCache-elements, which are  described in CellCache.\nfullcellset can be used to only assemble part of the grid. \n\n\n\n\n\n","category":"function"},{"location":"internals/#Internal-API","page":"Internal API","title":"Internal API","text":"","category":"section"},{"location":"internals/","page":"Internal API","title":"Internal API","text":"Note that the internal API may change without being considered a breaking change!","category":"page"},{"location":"internals/","page":"Internal API","title":"Internal API","text":"FerriteAssembly.assemble_cell!\nFerriteAssembly.inner_doassemble!","category":"page"},{"location":"internals/#FerriteAssembly.assemble_cell!","page":"Internal API","title":"FerriteAssembly.assemble_cell!","text":"assemble_cell!(\n    assembler, cell, cellvalues, material, \n    state, anew, aold, dh_fh, Δt, cellcache)\n\nAssemble the specific cell, provides a function barrier and uniform  initialization of cellvalues, zero out element stiffness and residual, and scaling of primary and residual values\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly.inner_doassemble!","page":"Internal API","title":"FerriteAssembly.inner_doassemble!","text":"inner_doassemble!(\n    assembler, fh::FieldHandler, cellvalues, material, \n    s::AbstractVector, dh::MixedDofHandler, \n    anew::AbstractVector, aold::AbstractVector, \n    Δt::Number, cache::CellCache, fullcellset\n    )\n\nInner assembling loop using the MixedDofHandler dh for a specific field fh. Normally not called by the user, only called from doassemble!(K, r, a, ..., dh::MixedDofHandler, ...)\n\n\n\n\n\n","category":"function"},{"location":"scaling/#Scaling","page":"Scaling","title":"Scaling","text":"","category":"section"},{"location":"scaling/","page":"Scaling","title":"Scaling","text":"Note that this part just exposes temporary docstrings  and the interface might change.","category":"page"},{"location":"scaling/","page":"Scaling","title":"Scaling","text":"Reminder: Might make sense to rename \"primary\" to \"unknowns\"? This would go better along with FESolvers","category":"page"},{"location":"scaling/","page":"Scaling","title":"Scaling","text":"FerriteAssembly.scale_primary_global!\nFerriteAssembly.unscale_primary_global!\nFerriteAssembly.unscale_primary!\nFerriteAssembly.scale_residual!","category":"page"},{"location":"scaling/#FerriteAssembly.scale_primary_global!","page":"Scaling","title":"FerriteAssembly.scale_primary_global!","text":"scale_primary_global!(a::AbstractVector, material, dofs_tuple::NamedTuple)\n\nScale the global degrees of freedom a to normalize and make unitless \n\n\n\n\n\n","category":"function"},{"location":"scaling/#FerriteAssembly.unscale_primary_global!","page":"Scaling","title":"FerriteAssembly.unscale_primary_global!","text":"unscale_primary_global!(a, material, dofs_tuple::NamedTuple)\n\nUnscale the global degrees of freedom a to get correct values for e.g. postprocessing. \n\n\n\n\n\n","category":"function"},{"location":"scaling/#FerriteAssembly.unscale_primary!","page":"Scaling","title":"FerriteAssembly.unscale_primary!","text":"unscale_primary!(ae::AbstractVector, m::AbstractMaterial, dh_fh::Union{DofHandler, FieldHandler})\n\nRemove scaling factor on the element degrees of freedom ae \n\n\n\n\n\n","category":"function"},{"location":"scaling/#FerriteAssembly.scale_residual!","page":"Scaling","title":"FerriteAssembly.scale_residual!","text":"scale_residual!(Ke::AbstractMatrix, re::AbstractVector, m::AbstractMaterial, dh_fh::Union{DofHandler, FieldHandler})\n\nScale the element stiffness, Ke, and residual, re to normalize wrt. units \n\n\n\n\n\n","category":"function"}]
}
