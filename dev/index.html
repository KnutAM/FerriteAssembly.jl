<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · FerriteAssembly.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://KnutAM.github.io/FerriteAssembly.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>FerriteAssembly.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#A-minimal-example"><span>A minimal example</span></a></li><li><a class="tocitem" href="#Detailed-API-description"><span>Detailed API description</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="examples/plasticity/">Plasticity</a></li><li><a class="tocitem" href="examples/mixed_materials/">Multiple materials</a></li></ul></li><li><a class="tocitem" href="internals/">Internal API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="FerriteAssembly"><a class="docs-heading-anchor" href="#FerriteAssembly">FerriteAssembly</a><a id="FerriteAssembly-1"></a><a class="docs-heading-anchor-permalink" href="#FerriteAssembly" title="Permalink"></a></h1><p>The goal of <a href="https://github.com/KnutAM/FerriteAssembly.jl">FerriteAssembly</a>  is to provide a simple structure to perform assembly in  <a href="https://github.com/Ferrite-FEM/Ferrite.jl/">Ferrite.jl</a>.</p><p>Sequential and threaded assembly of both the <code>DofHandler</code> and <code>MixedDofHandler</code> are supported.</p><p>The package works by exporting the <code>doassemble!</code> function, and require the  user to define either <code>element_routine!</code> (calculate both <code>Ke</code> and <code>re</code>), or just <code>element_residual!</code> (calculate only <code>re</code>).  In the latter case, <code>Ke</code> is calculated by  <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a></p><p>Dispatch is typically done on a user-defined <code>material</code> struct, and possible as well on <code>cellvalues</code> (potentially a <code>NamedTuple/Tuple</code>). State variables and current dof-values for the cell are directly available in the <code>element_routine!</code> Old dof-values for the cell, user-defined <code>cache</code> and <code>cell_load</code> types, cell coordinates and more  are available through the <code>CellBuffer</code> type given as additional input. </p><h2 id="A-minimal-example"><a class="docs-heading-anchor" href="#A-minimal-example">A minimal example</a><a id="A-minimal-example-1"></a><a class="docs-heading-anchor-permalink" href="#A-minimal-example" title="Permalink"></a></h2><p>The full example can be downloaded <a href="firstexample.jl">here</a>.</p><p>First we create the dofhandler and cellvalues as in <a href="https://ferrite-fem.github.io/Ferrite.jl/stable/examples/heat_equation/"><code>Ferrite.jl</code>&#39;s heat equation example</a></p><pre><code class="language- hljs">using Ferrite, FerriteAssembly
dh = DofHandler(generate_grid(Quadrilateral, (20, 20))); push!(dh, :u, 1); close!(dh)
cellvalues = CellScalarValues(QuadratureRule{2, RefCube}(2), Lagrange{2, RefCube, 1}())</code></pre><p>We start by defining the material (that normally contains material parameters but are hard-coded in the example)</p><pre><code class="language- hljs">struct ThermalMaterial end</code></pre><p>and then define our <code>element_routine!</code> for that material as</p><pre><code class="language- hljs">function FerriteAssembly.element_routine!(
    Ke::AbstractMatrix, re::AbstractVector, state,
    ae::AbstractVector, material::ThermalMaterial, cellvalues::CellScalarValues,
    dh_fh, Δt, buffer::CellBuffer
    )
    n_basefuncs = getnbasefunctions(cellvalues)
    # Loop over quadrature points
    for q_point in 1:getnquadpoints(cellvalues)
        dΩ = getdetJdV(cellvalues, q_point)
        for i in 1:n_basefuncs
            δu  = shape_value(cellvalues, q_point, i)
            ∇δu = shape_gradient(cellvalues, q_point, i)
            # Add body load contribution to re
            re[i] += -δu * dΩ
            # Loop over trial shape functions
            for j in 1:n_basefuncs
                ∇u = shape_gradient(cellvalues, q_point, j)
                # Add contribution to Ke
                Ke[i, j] += (∇δu ⋅ ∇u) * dΩ
            end
        end
    end
end</code></pre><p>which is basically the same as in <code>Ferrite.jl</code>&#39;s example.</p><p>We can now create the global vectors and matrices.</p><pre><code class="language- hljs">K = create_sparsity_pattern(dh)
r = zeros(ndofs(dh))</code></pre><p>In general, each integration point (or cell if desired by the user) can have a <code>state</code>. In this case, we have no state variables, but the interface still requires them. We can then create states of <code>nothing</code> by</p><pre><code class="language- hljs">states = create_states(dh)</code></pre><p>See <a href="#FerriteAssembly.create_states"><code>create_states</code></a> for more detailed options of creating actual state variables.</p><p>The next step is gathering all variables that are shared for all elements, but may be modified for or by each element in the <code>cellbuffer</code>:</p><pre><code class="language- hljs">cellbuffer = CellBuffer(dh, cellvalues, ThermalMaterial())</code></pre><p>Note that <code>cellvalues</code> can be a <code>Tuple</code> or <code>NamedTuple</code>, this is useful for coupled problems with multiple fields.</p><p>We then define our <code>assembler</code> and do the assembly</p><pre><code class="language- hljs">assembler = start_assemble(K,r)
doassemble!(assembler, cellbuffer, states, dh)</code></pre><h3>Threaded assembly</h3><p>To do the assembly in the example above threaded, we need to color the grid to avoid race conditions. This can be done with <code>Ferrite.jl</code>&#39;s <code>create_coloring</code> function:</p><pre><code class="language- hljs">colors = create_coloring(dh.grid)</code></pre><p>We must also create threaded versions of the <code>cellbuffer</code> and <code>assembler</code>,</p><pre><code class="language- hljs">cellbuffers = create_threaded_CellBuffers(CellBuffer(dh, cellvalues, ThermalMaterial()))
assemblers = create_threaded_assemblers(K, r)</code></pre><p>And then we can call <code>doassemble!</code> as</p><pre><code class="language- hljs">doassemble!(assemblers, cellbuffers, states, dh, colors)</code></pre><hr/><p><em>The examples were generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><h2 id="Detailed-API-description"><a class="docs-heading-anchor" href="#Detailed-API-description">Detailed API description</a><a id="Detailed-API-description-1"></a><a class="docs-heading-anchor-permalink" href="#Detailed-API-description" title="Permalink"></a></h2><h3 id="Overloaded-element-routine"><a class="docs-heading-anchor" href="#Overloaded-element-routine">Overloaded element routine</a><a id="Overloaded-element-routine-1"></a><a class="docs-heading-anchor-permalink" href="#Overloaded-element-routine" title="Permalink"></a></h3><p>One of the element methods should be overloaded for a given combination of <code>cellvalues</code> and <code>material</code>.  Note that the <code>cellvalues</code> are already <code>reinit!</code>:ed when passed to the element routines. </p><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.element_routine!" href="#FerriteAssembly.element_routine!"><code>FerriteAssembly.element_routine!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">element_routine!(
    Ke::AbstractMatrix, re::AbstractVector, state,
    ae::AbstractVector, material, cellvalues, 
    dh_fh::Union{DofHandler,FieldHandler}, Δt, buffer
    )</code></pre><p>The main function to be overloaded for the specific <code>material</code> and <code>cellvalues</code>. This function should modify the element stiffness matrix <code>Ke</code> and the residual <code>re</code>.</p><ul><li><code>state</code> should contain a state description for the element.  Typically, <code>state</code> will be a vector with a state variable for each  integration point, but it can also be any other type for each element.  On input, these are the old values and should be mutated to the updated  value for the current time step and guess for <code>ae</code>. </li><li>The user defined <code>material</code> variable usually contain the material parameters. </li><li><code>cellvalues</code> should contain the <code>CellValues</code> for the given element.  It can also be a tuple or named tuple of cellvalues. </li><li>When the regular <code>DofHandler</code> is used, <code>dh_fh::DofHandler</code> is passed to the element  routine. However, if the <code>MixedDofHandler</code> is used, one of its fieldhandlers are passed  as <code>dh_fh::FieldHandler</code>. This gives the option to call <code>dof_range(dh_fh, field::Symbol)</code>  for multi-field problems. </li><li><code>Δt</code> is time increment given to <code>doassemble</code></li><li><code>buffer</code> is normally <code>CellBuffer</code> (if given to <code>doassemble</code>). Then, it can be used to get <ul><li><code>buffer.ae_old</code>: The old values of the displacements (if <code>aold::Nothing</code> is passed to  <code>doassemble</code>, <code>buffer.ae_old</code> will be <code>NaN</code>s)</li><li><code>buffer.cell_load</code>: The <code>cell_load</code> passed to <code>CellBuffer</code>, typically used for  body loads or source terms. </li><li><code>buffer.cache</code>: The <code>cache</code> passed to <code>CellBuffer</code>, typically used to gather all  preallocations if such are necessary</li><li><code>getcoordinates(buffer)::Vector{Vec}</code>: The cell&#39;s coordinates</li><li><code>celldofs(buffer)::Vector{Int}</code>: The cell&#39;s global degrees of freedom numbers</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/581940f2e2a2d873d7e9b75eaade0b785774a71a/src/FerriteAssembly.jl#L14-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.element_residual!" href="#FerriteAssembly.element_residual!"><code>FerriteAssembly.element_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">element_residual!(
    re::AbstractVector, state, 
    ae::AbstractVector, material, cellvalues, 
    dh_fh::Union{DofHandler,FieldHandler}, Δt, buffer
    )</code></pre><p>To calculate the element tangent stiffness <code>Ke</code> automatically by using <code>ForwardDiff</code>, it is possible to overload <code>element_residual!</code> instead of <code>element_routine!</code>. See  <a href="#FerriteAssembly.element_routine!"><code>element_routine!</code></a> for a description of the input parameters. </p><p>Note that in order for this function to work, care must be taken when mutating values to not change their types. When mutating the <code>state</code>, ensure to call <code>ForwardDiff.value()</code> on those values. <em>Warning</em>: Only do this at a point when the calculation of <code>re</code> is  unaffected by the values in <code>state</code>, otherwise <code>Ke</code> will be wrong. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/581940f2e2a2d873d7e9b75eaade0b785774a71a/src/FerriteAssembly.jl#L72-L87">source</a></section></article><h3 id="CellBuffer"><a class="docs-heading-anchor" href="#CellBuffer"><code>CellBuffer</code></a><a id="CellBuffer-1"></a><a class="docs-heading-anchor-permalink" href="#CellBuffer" title="Permalink"></a></h3><p>Variables that are used and modified for each cell of a certain type,  but that don&#39;t belong to a specific cell, are collected in a <code>CellBuffer</code>.</p><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.CellBuffer" href="#FerriteAssembly.CellBuffer"><code>FerriteAssembly.CellBuffer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CellBuffer(
    numdofs::Int, numnodes::Int, ::Val{dim}, 
    cellvalues, material, cell_load=nothing, cache=nothing) -&gt; CellBuffer</code></pre><p>Create a cell cache for an element with <code>numdofs</code> degrees of freedom and <code>numnodes</code> nodes with dimension <code>dim</code>. Add the given <code>cellvalues</code>, <code>material</code>,  and <code>cache</code> to the <code>CellBuffer</code> as well. </p><pre><code class="nohighlight hljs">CellBuffer(
    dh::DofHandler, 
    cellvalues, material, cell_load=nothing, cache=nothing) -&gt; CellBuffer</code></pre><p>Use <code>dh</code> to get <code>numdofs</code>, <code>numnodes</code>, and <code>dim</code>, before calling the above method definition. </p><pre><code class="nohighlight hljs">CellBuffer(
    dh::MixedDofHandler, fh::FieldHandler, 
    cellvalues, material, cell_load=nothing, cache=nothing) -&gt; CellBuffer</code></pre><p>Use <code>dh</code> and <code>fh</code> to get <code>numdofs</code>, <code>numnodes</code>, and <code>dim</code>,  before calling the first <code>CellBuffer</code> method definition. </p><pre><code class="nohighlight hljs">CellBuffer(
    dh::MixedDofHandler, cellvalues, 
    material, cell_load=nothing, cache=nothing) -&gt; NTuple{N,&lt;:CellBuffer}</code></pre><p>Return a tuple of <code>CellBuffer</code>s for each <code>FieldHandler</code> in <code>dh.fieldhandlers</code>. <code>cellvalues[i]</code> corresponds to <code>dh.fieldhandlers[i]</code>, and so does  <code>materials[i]</code>, <code>cell_load[i]</code> and <code>caches[i]</code>. If only one <code>CellValues</code>, <code>material</code>, <code>cell_load</code>, and/or <code>cache</code> is given (not as a <code>::Tuple</code>), the same is used for all <code>fieldhandlers</code>.  If a tuple of <code>cellvalues</code> (or materials/cell_load/caches) should be used for each cell,  and the same tuple should be used for each fieldhandler,  then it must be given as a tuple of tuples.  (Often, it is better to give a <code>NamedTuple</code> of e.g. <code>CellValues</code> to be used for every fieldhandler)</p><p>The <code>Ferrite.jl</code> functions <code>getcoordinates(::CellBuffer)</code> and <code>celldofs(::CellBuffer)</code> are defined and can  be used inside an element routine to get the current cell&#39;s coordinates and dof-numbers. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/581940f2e2a2d873d7e9b75eaade0b785774a71a/src/CellBuffer.jl#L14-L51">source</a></section></article><h3 id="State-variables"><a class="docs-heading-anchor" href="#State-variables">State variables</a><a id="State-variables-1"></a><a class="docs-heading-anchor-permalink" href="#State-variables" title="Permalink"></a></h3><p>The initial state variables may vary depending on the position in the grid. Furthermore, the datastructure depends on the type of dof handler, so a convenience function exists that creates the correct variable</p><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.create_states" href="#FerriteAssembly.create_states"><code>FerriteAssembly.create_states</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_states(dh::DofHandler, 
    statefun::Function=Returns(nothing), 
    cellvalues::Union{CellValues,Nothing}=nothing
    ) -&gt; Vector</code></pre><p>Creates a <code>Vector</code> of states for each cell in <code>dh</code>, where a <code>state=statefun(x::Vec)</code> and <code>x</code> is  the coordinate in the grid. If <code>isnothing(cellvalues)</code>, then the <code>statefun</code> is called once for  the average nodal coordinate of each cell. Otherwise, it is called once per quadrature point in  <code>cellvalues</code> for that cell.</p><pre><code class="nohighlight hljs">create_states(dh::DofHandler, 
    statefun::Dict{String,Function}, 
    cellvalues::Union{Dict{String},CellValues,Nothing}}=nothing
    ) -&gt; Dict{String,Dict{Int}}

create_states(dh::MixedDofHandler, 
    statefun::Dict{String,Function}, 
    cellvalues::Union{Dict{String},CellValues,Nothing}}=nothing
    ) -&gt; Dict{String,NTuple{N,Dict{Int}}}</code></pre><p>If a <code>isa(statefun,Dict)</code>, then given a <code>Dict{String,Dict{Int}}</code> is returned, one for each cellset in the grid corresponding to the keys of <code>statefun</code>.  The elements are then <code>Dict</code>s that map the cellnr to the state for each cell  in the cellset. If <code>cellvalues::Dict</code> is given, the keys should match  <code>statefun</code>. Otherwise, the same cellvalues are assumed for each statefun. This is typically used if multiple materials are used on the same grid.</p><pre><code class="nohighlight hljs">create_states(dh::MixedDofHandler, 
    statefun::Union{Function,Tuple}=Returns(nothing), 
    cellvalues::Union{CellValues,Tuple,Nothing}=nothing,
    cellset=nothing
    ) -&gt; NTuple{N,Dict{Int}}</code></pre><p>Creates a <code>Tuple</code> of the output of the following function for each fieldhandler in <code>dh</code>. If <code>statefuns</code> and/or <code>cellvalues</code> are not tuples, the same value is used for each fieldhandler. </p><pre><code class="nohighlight hljs">create_states(dh::MixedDofHandler, fh::FieldHandler, 
    statefun::Function, cellvalues::Union{Nothing,CellValues}, cellset
    ) -&gt; Dict{Int}</code></pre><p>Returns a <code>Dict{Int}</code> with states for each cell in <code>fh</code>&#39;s <code>cellset</code> and keys corresponding to the global <code>cellid</code> If <code>isnothing(cellvalues)</code>, then the <code>statefun(x::Vec)</code> is called once for the average nodal coordinate <code>x</code> of each cell.  Otherwise, it is called once for each quadrature point location <code>x</code> given by <code>cellvalues</code> for that cell.  If a <code>cellset!=nothing</code> is given, states are only created for the intersection of that <code>cellset</code> and the fieldhandlers <code>cellset</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/581940f2e2a2d873d7e9b75eaade0b785774a71a/src/states.jl#L20-L65">source</a></section></article><h3 id="doassemble!"><a class="docs-heading-anchor" href="#doassemble!"><code>doassemble!</code></a><a id="doassemble!-1"></a><a class="docs-heading-anchor-permalink" href="#doassemble!" title="Permalink"></a></h3><p>Once everything is set up, one can call the function which will actually  do the assembly:</p><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.doassemble!" href="#FerriteAssembly.doassemble!"><code>FerriteAssembly.doassemble!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">doassemble!(
    assembler::Ferrite.AbstractSparseAssembler, cellbuffer::CellBuffer, 
    s::AbstractVector, dh::DofHandler, 
    a=nothing, aold=nothing, Δt=nothing
    )</code></pre><p>Sequential assembly of cells with the <code>dh::DofHandler</code>.</p><ul><li><code>assembler</code> is obtained from <code>Ferrite.jl</code>&#39;s <code>start_assemble(K,r)</code> function</li><li><code>cellbuffer</code> contains buffers for the specific cell.  See  <a href="#FerriteAssembly.CellBuffer"><code>CellBuffer</code></a> for more info. </li><li><code>s</code> is a collection (vector, dict, etc.) of state variables, where indexing  by <code>cellnr</code> gives the state variables for that cell. </li><li><code>a</code> and <code>aold</code> are the current and old unknowns (can be set to <code>nothing</code> if not used)</li><li><code>Δt</code> is the time increment passed into each element routine</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/581940f2e2a2d873d7e9b75eaade0b785774a71a/src/assembly.jl#L10-L26">source</a></section><section><div><pre><code class="nohighlight hljs">doassemble!(
    assemblers::Vector{&lt;:Ferrite.AbstractSparseAssembler},
    cellbuffers::Vector{&lt;:CellBuffer}, states, 
    dh::DofHandler, colored_sets::Vector{Vector{Int}}, 
    a=nothing, aold=nothing, Δt=nothing
    )</code></pre><p>Threaded assembly of cells with the <code>dh::DofHandler</code>.</p><ul><li><code>assemblers</code> are assemblers for each thread, which can be obtained with the <a href="#FerriteAssembly.create_threaded_assemblers"><code>create_threaded_assemblers</code></a> function. </li><li><code>cellbuffers</code> contains buffers for the specific cell, for each thread. This can be created by <a href="#FerriteAssembly.create_threaded_CellBuffers"><code>create_threaded_CellBuffers</code></a>.  See also <a href="#FerriteAssembly.CellBuffer"><code>CellBuffer</code></a> for more info.</li><li><code>states</code>, <code>a</code>, <code>aold</code>, and <code>Δt</code> are the same as for the  sequential <code>doassemble!</code></li><li><code>colored_sets</code> are cellsets for each color</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/581940f2e2a2d873d7e9b75eaade0b785774a71a/src/assembly.jl#L41-L59">source</a></section><section><div><pre><code class="nohighlight hljs">doassemble!(
    assembler::Ferrite.AbstractSparseAssembler, 
    cellbuffers::Tuple, states::Tuple, 
    dh::MixedDofHandler, 
    a=nothing, aold=nothing, Δt=nothing
    )</code></pre><p>Sequential assembly of cells with the <code>dh::MixedDofHandler</code>.</p><ul><li><code>cellbuffers</code> contains buffers for the specific cell in each <code>FieldHandler</code> in <code>dh.fieldhandlers</code> See  <a href="#FerriteAssembly.CellBuffer"><code>CellBuffer</code></a> for more info. </li><li><code>states</code> is a tuple which contains a collection of state variables,  one vector for each <code>FieldHandler</code> in <code>dh.fieldhandlers</code>.  Each element in the collection, i.e. <code>states[cellnr]</code>, contains the  state variables for one <code>Cell</code> with global number <code>cellnr</code>.  Unless all cells have the same type of the state, it might make sense to use a  Dict{Int,State} where the key refers to the global number. </li><li><code>assembler</code>, <code>a</code>, <code>aold</code>, and <code>Δt</code> are the same as for the <code>DofHandler</code> case. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/581940f2e2a2d873d7e9b75eaade0b785774a71a/src/assembly.jl#L76-L95">source</a></section><section><div><pre><code class="nohighlight hljs">doassemble!(
    assemblers::Vector{&lt;:Ferrite.AbstractSparseAssembler},
    cellbuffers::Tuple, 
    states::Tuple, 
    dh::MixedDofHandler, colored_sets::Vector{Vector{Int}}, 
    a::AbstractVector, aold::AbstractVector, Δt::Number
    )</code></pre><p>Threaded assembly of cells with the <code>dh::MixedDofHandler</code>.</p><ul><li><code>assemblers</code> and <code>colored_sets</code> are the same as for the threaded <code>DofHandler</code> case.</li><li><code>states</code> are the same as for the sequential <code>MixedDofHandler</code> case.</li><li><code>cellbuffers</code> contains vectors <code>Vector{CellBuffer}</code> for the cell type in  each <code>FieldHandler</code> in <code>dh.fieldhandlers</code>. The vector element corresponds to each  thread. This can be created by <a href="#FerriteAssembly.create_threaded_CellBuffers"><code>create_threaded_CellBuffers</code></a>.  See also <a href="#FerriteAssembly.CellBuffer"><code>CellBuffer</code></a> for more info.</li><li><code>a</code>, <code>aold</code>, and <code>Δt</code> are the same as for the <code>DofHandler</code> case.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/581940f2e2a2d873d7e9b75eaade0b785774a71a/src/assembly.jl#L106-L124">source</a></section></article><h3 id="Threaded-assembly"><a class="docs-heading-anchor" href="#Threaded-assembly">Threaded assembly</a><a id="Threaded-assembly-1"></a><a class="docs-heading-anchor-permalink" href="#Threaded-assembly" title="Permalink"></a></h3><p>For parallel assembly, we need a vector of <code>CellBuffer</code>s and assemblers,  one for each thread. </p><p>For the <code>MixedDofHandler</code>, the outer loop is over the type of cells, so we need a tuple that contains vectors of <code>CellBuffer</code>s.  Construction of this via <code>deepcopy</code> is implemented as</p><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.create_threaded_CellBuffers" href="#FerriteAssembly.create_threaded_CellBuffers"><code>FerriteAssembly.create_threaded_CellBuffers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_threaded_CellBuffers(c::CellBuffer; nthreads=Threads.nthreads())
create_threaded_CellBuffers(cs::Tuple; nthreads=Threads.nthreads())</code></pre><p>Convenience function for creating a vector with cell buffers for each thread.  The standard workflow is to first call <code>CellBuffer</code> with the  dof handler. For <code>DofHandler</code> this will give a <code>CellBuffer</code>,  and for <code>MixedDofHandler</code> this gives a tuple of <code>CellBuffer</code>s.  In both cases, the output can be given to <code>create_threaded_CellBuffers</code> to produce the appropriate result required by the threaded versions of <a href="#FerriteAssembly.doassemble!"><code>doassemble!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/581940f2e2a2d873d7e9b75eaade0b785774a71a/src/CellBuffer.jl#L137-L148">source</a></section></article><p>A vector of assemblers that is convieniently created by calling </p><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.create_threaded_assemblers" href="#FerriteAssembly.create_threaded_assemblers"><code>FerriteAssembly.create_threaded_assemblers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_threaded_assemblers(K, r; nthreads=Threads.nthreads())</code></pre><p>Convenience function for creating a <code>nthreads</code> long vector with the  output of <code>start_assemble</code> as elements</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/581940f2e2a2d873d7e9b75eaade0b785774a71a/src/assembly.jl#L2-L7">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="examples/plasticity/">Plasticity »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Saturday 22 October 2022 19:21">Saturday 22 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
