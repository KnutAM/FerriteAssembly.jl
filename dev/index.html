<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · FerriteAssembly.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://KnutAM.github.io/FerriteAssembly.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>FerriteAssembly.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#A-first-example"><span>A first example</span></a></li><li><a class="tocitem" href="#Detailed-API-description"><span>Detailed API description</span></a></li></ul></li><li><a class="tocitem" href="scaling/">Scaling</a></li><li><a class="tocitem" href="internals/">Internal API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="FerriteAssembly"><a class="docs-heading-anchor" href="#FerriteAssembly">FerriteAssembly</a><a id="FerriteAssembly-1"></a><a class="docs-heading-anchor-permalink" href="#FerriteAssembly" title="Permalink"></a></h1><p>The goal of <a href="https://github.com/KnutAM/FerriteAssembly.jl">FerriteAssembly</a>  is to provide a simple structure to perform assembly in  <a href="https://github.com/Ferrite-FEM/Ferrite.jl/">Ferrite.jl</a>.</p><p>Both the <code>DofHandler</code> and <code>MixedDofHandler</code> are supported. Currently only sequential assembly, but this will be extended  to threaded assembly.</p><p>The package work by exporting the <code>doassemble!</code> function, and requires the  user to define either <code>element_routine!</code> (calculate both <code>Ke</code> and <code>re</code>), or just <code>element_residual!</code> (calculate only <code>re</code>).  In the latter case, <code>Ke</code> is calculated by  <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a></p><p>An advanced option to scale the unknowns, residual, and jacobian exists  (currently undocumented)</p><ul><li><a href="#FerriteAssembly">FerriteAssembly</a></li><li class="no-marker"><ul><li><a href="#A-first-example">A first example</a></li><li><a href="#Detailed-API-description">Detailed API description</a></li></ul></li><li><a href="internals/#Internal-API">Internal API</a></li><li><a href="scaling/#Scaling">Scaling</a></li></ul><h2 id="A-first-example"><a class="docs-heading-anchor" href="#A-first-example">A first example</a><a id="A-first-example-1"></a><a class="docs-heading-anchor-permalink" href="#A-first-example" title="Permalink"></a></h2><p>We take a slightly modified element routine from <code>Ferrite.jl</code>&#39;s heat equation  <a href="https://ferrite-fem.github.io/Ferrite.jl/stable/examples/heat_equation/">example</a>. We assume that we already have defined <code>dh::DofHandler</code> and our  <code>cellvalues::CellScalarValues</code> according to that example. We then define</p><pre><code class="language-julia hljs">struct ThermalMaterial end
material = ThermalMaterial()</code></pre><p>and our <code>element_routine!</code> for that material as </p><pre><code class="language-julia hljs">function FerriteAssembly.element_routine!(
    Ke::AbstractMatrix, re::AbstractVector, 
    ae_new::AbstractVector, ae_old::AbstractVector,
    state::AbstractVector, material::ThermalMaterial, 
    cellvalues::CellScalarValues, 
    dh_fh::Union{DofHandler,FieldHandler}, Δt, materialcache
    )
    n_basefuncs = getnbasefunctions(cellvalues)
    # Loop over quadrature points
    for q_point in 1:getnquadpoints(cellvalues)
        dΩ = getdetJdV(cellvalues, q_point)
        for i in 1:n_basefuncs
            δu  = shape_value(cellvalues, q_point, i)
            ∇δu = shape_gradient(cellvalues, q_point, i)
            # Add body load contribution to re
            re[i] += -δu * dΩ
            # Loop over trial shape functions
            for j in 1:n_basefuncs
                ∇u = shape_gradient(cellvalues, q_point, j)
                # Add contribution to Ke
                Ke[i, j] += (∇δu ⋅ ∇u) * dΩ
            end
        end
    end
end</code></pre><p>We can now create the global vectors and matrices, as well as the time step</p><pre><code class="language-julia hljs">K = create_sparsity_pattern(dh)
a=zeros(ndofs(dh)); aold=copy(a);
r = zeros(ndofs(dh))
Δt=1.0</code></pre><p>Before we can assemble, we need our <code>cellcache</code> (to avoid unecessary allocations  inside the assembly loop). But this is created automatically from the DofHandler:</p><pre><code class="language-julia hljs">cache = CellCache(dh)</code></pre><p>And then we can assemble our system by calling </p><pre><code class="language-julia hljs">doassemble!(K, r, a, aold, states, dh, cv, material, Δt, cache)</code></pre><h2 id="Detailed-API-description"><a class="docs-heading-anchor" href="#Detailed-API-description">Detailed API description</a><a id="Detailed-API-description-1"></a><a class="docs-heading-anchor-permalink" href="#Detailed-API-description" title="Permalink"></a></h2><p>One of the element methods should be overloaded for a given combination of <code>cellvalues</code> and <code>material</code>.</p><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.element_routine!" href="#FerriteAssembly.element_routine!"><code>FerriteAssembly.element_routine!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">element_routine!(
    Ke::AbstractMatrix, re::AbstractVector, 
    ae::AbstractVector, ae_old::AbstractVector,
    state, material, cellvalues, 
    dh_fh::Union{DofHandler,FieldHandler}, Δt, materialcache
    )</code></pre><p>The main function to be overloaded for the specific <code>material</code> and <code>cellvalues</code>. This function should modify the residual <code>r</code> and the element stiffness matrix <code>Ke</code>, such that <code>Ke=∂(re)/∂(ae)</code>, where <code>ae</code> are the element degrees of freedom. <code>ae_old</code>  are the corresponding old values </p><ul><li><code>state</code> should contain a state description for the element.  Typically, <code>state</code> will be a vector with a state variable for each  integration point, but it can also be any other type for each element.  On input, these are the old values and should be mutated to the updated  value for the current time step. </li><li>The user defined <code>material</code> variable usually contain the material parameters</li><li><code>cellvalues</code> should contain the cell values for the given element.  It can also be a tuple or named tuple of cellvalues. </li><li>When the regular <code>DofHandler</code> is used, <code>dh_fh::DofHandler</code> is passed to the element  routine. However, if the <code>MixedDofHandler</code> is used, one of its fieldhandlers are passed  as <code>dh_fh::FieldHandler</code>. This gives the option to call <code>dof_range(dh_fh, field::Symbol)</code>  for multi-field problems. </li><li>Finally, a time increment <code>Δt</code> and an optional <code>materialcache</code> are passed  into the element as well.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/28f2d237827292970c726401f529c32dbc45d83e/src/FerriteAssembly.jl#L10-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.element_residual!" href="#FerriteAssembly.element_residual!"><code>FerriteAssembly.element_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">element_residual!(
    re::AbstractVector, 
    ae::AbstractVector, ae_old::AbstractVector,
    state, material, cellvalues, 
    dh_fh::Union{DofHandler,FieldHandler}, Δt, materialcache
    )</code></pre><p>To calculate the element tangent stiffness <code>Ke</code> automatically by using <code>ForwardDiff</code>, it is possible to overload <code>element_residual!</code> instead of <code>element_routine!</code>. See  <a href="#FerriteAssembly.element_routine!"><code>element_routine!</code></a> for a description of the input parameters. </p><p>Note that in order for this function to work, care must be taken when mutating values to not change their types. When mutating the <code>state</code>, ensure to call <code>ForwardDiff.value()</code> on those values. <em>Warning</em>: Only do this at a point when the calculation of <code>re</code> is  unaffected by the values in <code>state</code>, otherwise <code>Ke</code> will be wrong. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/28f2d237827292970c726401f529c32dbc45d83e/src/FerriteAssembly.jl#L68-L84">source</a></section></article><p>The allocations are reduced by saving all variables to a cellcache,  which is automatically created by giving it the dof handler:</p><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.CellCache" href="#FerriteAssembly.CellCache"><code>FerriteAssembly.CellCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CellCache(n::Int, materialcache=nothing)</code></pre><p>Create a cell cache for an element with <code>n</code> degrees of freedom, as well as with <code>materialcache</code></p><pre><code class="nohighlight hljs">CellCache(dh::DofHandler, materialcache=nothing)</code></pre><p>Create a cell cache for an element with <code>n=ndofs_per_cell(dh)</code>, as well as with <code>materialcache</code>. </p><pre><code class="nohighlight hljs">CellCache(dh::MixedDofHandler, fh::FieldHandler, materialcache=nothing)</code></pre><p>Create a cell cache for an element with <code>n</code> degrees of freedom,  as well as with <code>materialcache</code>. Here, <code>n</code> is the number of degrees of  freedom for the cells in <code>fh.cellset</code>.</p><pre><code class="nohighlight hljs">CellCache(dh::MixedDofHandler, materialcache=nothing)
CellCache(dh::MixedDofHandler, materialcache::Tuple)</code></pre><p>Returns a tuple of <code>CellCache</code>s for each <code>FieldHandler</code> in <code>dh.fieldhandlers</code>. If <code>materialcache::Tuple</code> is given, <code>materialcache[i]</code> is assigned to the  <code>CellCache</code> corresponding to <code>dh.fieldhandlers[i]</code>. Otherwise, <code>materialcache</code> is assigned to each <code>CellCache</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/28f2d237827292970c726401f529c32dbc45d83e/src/CellCache.jl#L9-L33">source</a></section></article><p>Once everything is set up, one can call the function which will actually  do the assembly:</p><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.doassemble!" href="#FerriteAssembly.doassemble!"><code>FerriteAssembly.doassemble!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">doassemble!(
    K::AbstractMatrix, r::AbstractVector, a::AbstractVector, 
    aold::AbstractVector, s::AbstractVector, dh::DofHandler, 
    cellvalues, material, Δt::Number, cache::CellCache
    )</code></pre><p>Assemble all cells by using <code>dh::DofHandler</code>.</p><ul><li><code>K</code>, and <code>r</code> are the global stiffness matrix and residual  vector to be calculated. </li><li><code>a</code> and <code>aold</code> are the current and old unknowns. </li><li><code>s</code> is a vector of state variables, where each element contains state variables for each <code>cellid</code>.  If <code>cellset</code> is given (see below), the number is still the <code>cellid</code>, and in some cases it might make sense to pass a sparse vector. </li><li><code>cellvalues</code> are passed on to the element routine  after calling <code>Ferrite.reinit!</code>. (Multiple cellvalues  can be given as a <code>Tuple</code> or <code>NamedTuple</code>, and all elements will be reinitialized)</li><li>The user-defined <code>material</code> and the time increment <code>Δt</code> are passed into the element routine. </li><li><code>cache</code> is described in <a href="#FerriteAssembly.CellCache"><code>CellCache</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/28f2d237827292970c726401f529c32dbc45d83e/src/assembly.jl#L1-L24">source</a></section><section><div><pre><code class="nohighlight hljs">doassemble!(
    K::AbstractMatrix, r::AbstractVector, anew::AbstractVector, 
    aold::AbstractVector, state::Tuple, dh::MixedDofHandler, 
    cellvalues::Tuple, materials::Tuple, Δt::Number, caches::Tuple
    )</code></pre><p>Assemble all cells by using <code>dh::MixedDofHandler</code>. In this case,  we first loop over each <code>fieldhandler</code> in <code>dh</code>. Therefore,  some variables must now be given as tuples, where each element corresponds  to the values in the specific <code>fieldhandler</code>. </p><ul><li><code>K</code>, and <code>r</code> are the global stiffness matrix and residual  vector to be calculated. </li><li><code>a</code> and <code>aold</code> are the current and old unknowns. </li><li><code>s</code> is a tuple of vectors of state variables. Each element, <code>s[i]</code>, corresponds to the <code>i</code>th element in <code>dh.fieldhandlers</code>.  The <code>j</code>th element of <code>s[i]::AbstractVector</code>, contains the state variables  for <code>cellid=j</code>. If the state-type differs for multiple fieldhandlers, it  might make sense to use sparse vectors. </li><li><code>cellvalues</code> is a tuple with one element for each fieldhandler.  For each fieldhandler <code>i</code>, <code>cellvalues[i]</code> is passed to the element  routine after calling <code>Ferrite.reinit!</code>. (Multiple cellvalues can  be given by making <code>cellvalues[i]</code> a <code>Tuple</code> or <code>NamedTuple</code>.  All elements will be reinitialized)</li><li>The user-defined <code>material</code> and the time increment <code>Δt</code> are passed into the element routine. Finally,</li><li><code>caches</code> is a tuple with <code>CellCache</code>-elements, which are  described in <a href="#FerriteAssembly.CellCache"><code>CellCache</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/28f2d237827292970c726401f529c32dbc45d83e/src/assembly.jl#L37-L66">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="scaling/">Scaling »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 19 October 2022 13:14">Wednesday 19 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
