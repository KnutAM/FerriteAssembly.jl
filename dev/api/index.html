<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · FerriteAssembly.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://KnutAM.github.io/FerriteAssembly.jl/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FerriteAssembly.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/plasticity/">Plasticity</a></li><li><a class="tocitem" href="../examples/mixed_materials/">Multiple materials</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Element-routines"><span>Element routines</span></a></li><li><a class="tocitem" href="#CellBuffer"><span>CellBuffer</span></a></li><li><a class="tocitem" href="#State-variables"><span>State variables</span></a></li><li><a class="tocitem" href="#doassemble!"><span><code>doassemble!</code></span></a></li><li><a class="tocitem" href="#Threaded-assembly"><span>Threaded assembly</span></a></li><li><a class="tocitem" href="#Residual-scaling"><span>Residual scaling</span></a></li></ul></li><li><a class="tocitem" href="../datastructures/">Datastructures</a></li><li><a class="tocitem" href="../internals/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/main/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>Methods that should be overloaded and exported functions are described on this page. It may also be useful to checkout the <a href="../datastructures/#Data-structures">Data structures</a>.</p><h2 id="Element-routines"><a class="docs-heading-anchor" href="#Element-routines">Element routines</a><a id="Element-routines-1"></a><a class="docs-heading-anchor-permalink" href="#Element-routines" title="Permalink"></a></h2><p>One of the element methods should be overloaded for a given combination of <code>cellvalues</code> and <code>material</code>.  Note that the <code>cellvalues</code> are already <code>reinit!</code>:ed when passed to the element routines. </p><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.element_routine!" href="#FerriteAssembly.element_routine!"><code>FerriteAssembly.element_routine!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">element_routine!(
    Ke::AbstractMatrix, re::AbstractVector, state,
    ae::AbstractVector, material, cellvalues, 
    dh_fh, Δt, buffer
    )</code></pre><p>The main function to be overloaded for the specific <code>material</code> and <code>cellvalues</code>. This function should modify the element stiffness matrix <code>Ke</code> and the residual <code>re</code>.</p><ul><li><code>state</code> should contain a state description for the element.  Typically, <code>state</code> will be a vector with a state variable for each  integration point, but it can also be any other type for each element.  On input, these are the old values and should be mutated to the updated  value for the current time step and guess for <code>ae</code>. </li><li>The user defined <code>material</code> variable usually contain the material parameters. </li><li><code>cellvalues</code> should contain the <code>CellValues</code> for the given element.  It can also be a tuple or named tuple of cellvalues. </li><li>When the regular <code>DofHandler</code> is used, <code>dh_fh::DofHandler</code> is passed to the element  routine. However, if the <code>MixedDofHandler</code> is used, one of its fieldhandlers are passed  as <code>dh_fh::FieldHandler</code>. This gives the option to call <code>dof_range(dh_fh, field::Symbol)</code>  for multi-field problems. <strong>Note:</strong> Please do not rely on <code>dh_fh</code> for anything but <code>dof_range</code>, as <code>dh_fh</code> may be replaced with another type that only supports <code>dof_range</code>.</li><li><code>Δt</code> is time increment given to <code>doassemble</code></li><li><code>buffer::Union{CellBuffer, AutoDiffCellBuffer}</code> can be used to get <ul><li><code>getcoordinates(buffer)::Vector{Vec}</code>: The cell&#39;s coordinates</li><li><code>celldofs(buffer)::Vector{Int}</code>: The cell&#39;s global degrees of freedom numbers</li><li><code>FerriteAssembly.get_aeold(buffer)</code>: <code>aold[celldofs]</code> (if <code>aold::Nothing</code> is passed to  <code>doassemble</code>, a vector, <code>[NaN for d in celldofs]</code> is returned)</li><li><code>FerriteAssembly.get_load(buffer)</code>: The <code>cell_load</code> in the buffer, typically used for   body loads or source terms. </li><li><code>FerriteAssembly.get_cache(buffer)</code>: The <code>cache</code> in the buffer - typically used to gather all   preallocations if such are necessary</li></ul></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.element_residual!" href="#FerriteAssembly.element_residual!"><code>FerriteAssembly.element_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">element_residual!(
    re::AbstractVector, state, 
    ae::AbstractVector, material, cellvalues, 
    dh_fh, Δt, buffer
    )</code></pre><p>To calculate the element tangent stiffness <code>Ke</code> automatically by using <code>ForwardDiff</code>, it is possible to overload <code>element_residual!</code> instead of <code>element_routine!</code>. See  <a href="#FerriteAssembly.element_routine!"><code>element_routine!</code></a> for a description of the input parameters. </p><p>Note that in order for this function to work, care must be taken when mutating values to not change their types. When mutating the <code>state</code>, ensure to call <code>ForwardDiff.value()</code> on those values. <em>Warning</em>: Only do this at a point when the calculation of <code>re</code> is  unaffected by the values in <code>state</code>, otherwise <code>Ke</code> will be wrong. </p></div></section></article><h2 id="CellBuffer"><a class="docs-heading-anchor" href="#CellBuffer">CellBuffer</a><a id="CellBuffer-1"></a><a class="docs-heading-anchor-permalink" href="#CellBuffer" title="Permalink"></a></h2><p>Variables that are used and modified for each cell of a certain type,  but that don&#39;t belong to a specific cell, are collected in a <code>CellBuffer</code>.</p><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.CellBuffer" href="#FerriteAssembly.CellBuffer"><code>FerriteAssembly.CellBuffer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CellBuffer(
    numdofs::Int, numnodes::Int, ::Val{dim}, 
    cellvalues, material, cell_load=nothing, cache=nothing) -&gt; CellBuffer</code></pre><p>Create a cell cache for an element with <code>numdofs</code> degrees of freedom and <code>numnodes</code> nodes with dimension <code>dim</code>. Add the given <code>cellvalues</code>, <code>material</code>,  and <code>cache</code> to the <code>CellBuffer</code> as well. Note that this constructor is normally  not used, and is instead called from <a href="#FerriteAssembly.setup_cellbuffer"><code>setup_cellbuffer</code></a>. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.setup_cellbuffer" href="#FerriteAssembly.setup_cellbuffer"><code>FerriteAssembly.setup_cellbuffer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setup_cellbuffer(
    dh::DofHandler, cellvalues, material, 
    cell_load=nothing, cache=nothing)</code></pre><p>Creates a single <code>CellBuffer</code> for use with the standard <code>DofHandler</code> and a single material.</p></div></section><section><div><pre><code class="nohighlight hljs">setup_cellbuffer(
    dh::MixedDofHandler, cellvalues, material, 
    cell_load=nothing, cache=nothing)</code></pre><p>Return a tuple of <code>CellBuffer</code>s for each <code>FieldHandler</code> in <code>dh.fieldhandlers</code>. <code>cellvalues[i]</code> corresponds to <code>dh.fieldhandlers[i]</code>, and so does  <code>materials[i]</code>, <code>cell_load[i]</code> and <code>caches[i]</code>. If only one <code>CellValues</code>, <code>material</code>, <code>cell_load</code>, and/or <code>cache</code> is given (not as a <code>::Tuple</code>), the same is used for all <code>fieldhandlers</code>.  If a tuple of <code>cellvalues</code> (or materials/cell_load/caches) should be used for each cell,  and the same tuple should be used for each fieldhandler,  then it must be given as a tuple of tuples.  (Often, it is better to give a <code>NamedTuple</code> of e.g. <code>CellValues</code> to be used for every fieldhandler)</p><p>The <code>Ferrite.jl</code> functions <code>getcoordinates(::CellBuffer)</code> and <code>celldofs(::CellBuffer)</code> are defined and can  be used inside an element routine to get the current cell&#39;s coordinates and dof-numbers. </p></div></section><section><div><pre><code class="nohighlight hljs">setup_cellbuffer(dh::AbstractDofHandler, cv, materials::Dict, 
    cell_load=nothing, cache=nothing)</code></pre><p>Return a <code>Dict{String}</code> for each <code>material</code> in <code>materials</code>. If any of <code>cv</code>, <code>cell_load</code>, or <code>cache</code> is not a <code>Dict</code>, the same value  is used for each <code>CellBuffer</code>. If <code>Dict</code>s are used, the keys must match  those in <code>materials</code>. The return type depends on the <code>dh</code>:</p><ul><li><code>dh::DofHandler</code>: <code>Dict{String,&lt;:CellBuffer}</code></li><li><code>dh::MixedDofHandler</code>: <code>Dict{String,NTuple{N,CellBuffer}</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.AutoDiffCellBuffer" href="#FerriteAssembly.AutoDiffCellBuffer"><code>FerriteAssembly.AutoDiffCellBuffer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AutoDiffCellBuffer(cb::CellBuffer, cellstates, dh_fh::Union{DofHandler,FieldHandler})</code></pre><p><code>cellstates</code> should be the states for the relevant cells in <code>dh_fh</code>.  An <code>AutoDiffCellBuffer</code> wraps a <code>CellBuffer</code> and behaves the same way  wrt defined functions, i.e. all <code>get*</code> functions defined for <code>CellBuffer</code> are also defined for <code>AutoDiffCellBuffer</code>.  When used for automatic differentiation, only the wrapped <code>CellBuffer</code>  is passed to <code>element_residual!</code>.  As a backup solution if direct field access is used, the function  <a href="#FerriteAssembly.getCellBuffer"><code>getCellBuffer</code></a> returns the <code>CellBuffer</code> for both a <code>CellBuffer</code>  and an <code>AutoDiffCellBuffer</code>. </p><p>Note that this constructor is normally not used,  but called from the <a href="#FerriteAssembly.setup_ad_cellbuffer"><code>setup_ad_cellbuffer</code></a> function.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.setup_ad_cellbuffer" href="#FerriteAssembly.setup_ad_cellbuffer"><code>FerriteAssembly.setup_ad_cellbuffer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setup_ad_cellbuffer(states, dh::AbstractDofHandler, args...)</code></pre><p>Create a special cell buffer that improves performance when using  automatic differentiation to calculate the element stiffness. The exact same  inputs as for <a href="#FerriteAssembly.setup_cellbuffer"><code>setup_cellbuffer</code></a> should be used, except that the  <code>states</code> variable that is passed to <code>doassemble!</code> should be prepended to the  argument list.  </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.getCellBuffer" href="#FerriteAssembly.getCellBuffer"><code>FerriteAssembly.getCellBuffer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getCellBuffer(b::Union{CellBuffer,AutoDiffCellBuffer})</code></pre><p>Return the <code>CellBuffer</code> if <code>isa(b,CellBuffer)</code>, else, return the <code>CellBuffer</code> wrapped by <code>b::AutoDiffCellBuffer</code>, i.e. <code>b.cb</code></p></div></section></article><h3 id="Access-functions"><a class="docs-heading-anchor" href="#Access-functions">Access functions</a><a id="Access-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Access-functions" title="Permalink"></a></h3><p>The following access functions can be used to extract information from the  <code>CellBuffer</code></p><article class="docstring"><header><a class="docstring-binding" id="Ferrite.getcoordinates" href="#Ferrite.getcoordinates"><code>Ferrite.getcoordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Ferrite.getcoordinates(c::CellBuffer)</code></pre><p><code>Ferrite.jl</code>&#39;s <code>getcoordinates</code> function is overloaded on the <code>CellBuffer</code> to return  the current cell&#39;s nodal coordinates. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.get_aeold" href="#FerriteAssembly.get_aeold"><code>FerriteAssembly.get_aeold</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteAssembly.get_aeold(c::CellBuffer)</code></pre><p>Get the old element dof-values for the current cell</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.get_load" href="#FerriteAssembly.get_load"><code>FerriteAssembly.get_load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteAssembly.get_load(c::CellBuffer)</code></pre><p>Get the user specified body load given to <code>CellBuffer</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.get_cache" href="#FerriteAssembly.get_cache"><code>FerriteAssembly.get_cache</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteAssembly.get_cache(c::CellBuffer)</code></pre><p>Get the user-specified <code>cache</code> given to the <code>CellBuffer</code></p></div></section></article><h2 id="State-variables"><a class="docs-heading-anchor" href="#State-variables">State variables</a><a id="State-variables-1"></a><a class="docs-heading-anchor-permalink" href="#State-variables" title="Permalink"></a></h2><p>The initial state variables may vary depending on the position in the grid. Furthermore, the datastructure depends on the type of dof handler, so a convenience function exists that creates the correct variable structure. </p><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.create_states" href="#FerriteAssembly.create_states"><code>FerriteAssembly.create_states</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_states(dh::DofHandler, material=nothing, cellvalues=nothing, a=nothing)</code></pre><p>Create the state variables for the given <code>dh</code>, <code>material</code>, <code>cellvalues</code>, and global  dof vector <code>a</code>. <code>material</code> and <code>cellvalues</code> can be a Dict{String}, in which case they  should have the same keys, corresponding to cellsets in the grid.  This follows the same structure as for creating a <code>CellBuffer</code>. The function <code>create_cell_state</code> is called for each cell. </p></div></section><section><div><pre><code class="nohighlight hljs">create_states(dh::MixedDofHandler, material=nothing, cellvalues=nothing, a=nothing)</code></pre><p>Create the state variables for the given <code>dh</code>, <code>material</code>, <code>cellvalues</code>, and global dof vector <code>a</code>. </p><p><code>material</code> and <code>cellvalues</code> follow the same input structure as to <code>setup_cellbuffer</code>.  I.e., they can be tuples with the same length as <code>fh.fieldhandlers</code>.  Note that if <code>cellvalues::Tuple</code> is desired to be passed into the <code>create_cell_state</code> function, it must be wrapped in an outer ntuple with the same length as <code>fh.fieldhandlers</code>. (But using a <code>NamedTuple</code> is recommended to avoid this problem). </p><p>For multiple materials, <code>material::Dict{String}</code>, and <code>cellvalues</code> can optionally be that as well,  but then they must have the same keys. This follows the same structure as for creating a <code>CellBuffer</code>. The function <code>create_cell_state</code> is called for each cell. </p><p>The order of each call to <code>create_cell_state</code> is fixed for a given input, i.e. the loops are only  over sorted <code>Set</code>s and <code>Dict</code> keys. (Useful if using <code>StableRNGs.jl</code> for random variations to obtain reproducible results)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.create_cell_state" href="#FerriteAssembly.create_cell_state"><code>FerriteAssembly.create_cell_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_cell_state(material, cellvalues, x, ae)</code></pre><p>Defaults to returning <code>nothing</code>.</p><p>Overload this function to create the state which should be passed  into the <code>element_routine!</code>/<code>element_residual!</code> for the given  material and cellvalues.  As for the element routines, <code>ae</code>, is filled with <code>NaN</code> unless the global degree of freedom vector is given to the  <a href="#FerriteAssembly.create_states"><code>create_states</code></a> function. </p></div></section></article><h2 id="doassemble!"><a class="docs-heading-anchor" href="#doassemble!"><code>doassemble!</code></a><a id="doassemble!-1"></a><a class="docs-heading-anchor-permalink" href="#doassemble!" title="Permalink"></a></h2><p>Once everything is set up, one can call the function which will actually  do the assembly:</p><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.doassemble!" href="#FerriteAssembly.doassemble!"><code>FerriteAssembly.doassemble!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">doassemble!(
    assembler::Ferrite.AbstractSparseAssembler, cellbuffer::AbstractCellBuffer, 
    s::AbstractVector, dh::DofHandler, 
    a=nothing, aold=nothing, Δt=nothing, scaling=nothing; cellset=1:ncells
    )</code></pre><p>Sequential assembly of cells with the <code>dh::DofHandler</code>.</p><ul><li><code>assembler</code> is obtained from <code>Ferrite.jl</code>&#39;s <code>start_assemble(K,r)</code> function</li><li><code>cellbuffer</code> contains buffers for the specific cell.  See  <a href="#FerriteAssembly.CellBuffer"><code>CellBuffer</code></a> for more info. </li><li><code>s</code> is a collection (vector, dict, etc.) of state variables, where indexing  by <code>cellnr</code> gives the state variables for that cell. </li><li><code>a</code> and <code>aold</code> are the current and old unknowns (can be set to <code>nothing</code> if not used)</li><li><code>Δt</code> is the time increment passed into each element routine</li><li><code>scaling</code> allows including element data in order to scale the residuals,  see <a href="#Residual-scaling">Residual scaling</a></li></ul></div></section><section><div><pre><code class="nohighlight hljs">doassemble!(
    assemblers::Vector{&lt;:Ferrite.AbstractSparseAssembler},
    cellbuffers::Vector{&lt;:AbstractCellBuffer}, states, 
    dh::DofHandler, colored_sets::Vector{Vector{Int}}, 
    a=nothing, aold=nothing, Δt=nothing, 
    scalings::Vector=create_threaded_scalings(nothing);
    cellset=nothing
    )</code></pre><p>Threaded assembly of cells with the <code>dh::DofHandler</code>.</p><ul><li><code>assemblers</code> are assemblers for each thread, which can be obtained with the <a href="#FerriteAssembly.create_threaded_assemblers"><code>create_threaded_assemblers</code></a> function. </li><li><code>cellbuffers</code> contains buffers for the specific cell, for each thread. This can be created by <a href="#FerriteAssembly.create_threaded_CellBuffers"><code>create_threaded_CellBuffers</code></a>.  See also <a href="#FerriteAssembly.CellBuffer"><code>CellBuffer</code></a> for more info.</li><li><code>states</code>, <code>a</code>, <code>aold</code>, and <code>Δt</code> are the same as for the  sequential <code>doassemble!</code></li><li><code>colored_sets</code> are cellsets for each color</li></ul></div></section><section><div><pre><code class="nohighlight hljs">doassemble!(
    assembler::Ferrite.AbstractSparseAssembler, 
    cellbuffers::Tuple, states::Tuple, 
    dh::MixedDofHandler, 
    a=nothing, aold=nothing, Δt=nothing, scaling=nothing;
    kwargs...
    )</code></pre><p>Sequential assembly of cells with the <code>dh::MixedDofHandler</code>.</p><ul><li><code>cellbuffers</code> contains buffers for the specific cell in each <code>FieldHandler</code> in <code>dh.fieldhandlers</code> See  <a href="#FerriteAssembly.CellBuffer"><code>CellBuffer</code></a> for more info. </li><li><code>states</code> is a tuple which contains a collection of state variables,  one vector for each <code>FieldHandler</code> in <code>dh.fieldhandlers</code>.  Each element in the collection, i.e. <code>states[cellnr]</code>, contains the  state variables for one <code>Cell</code> with global number <code>cellnr</code>.  Unless all cells have the same type of the state, it might make sense to use a  Dict{Int,State} where the key refers to the global number. </li><li><code>assembler</code>, <code>a</code>, <code>aold</code>, and <code>Δt</code> are the same as for the <code>DofHandler</code> case. </li></ul></div></section><section><div><pre><code class="nohighlight hljs">doassemble!(
    assemblers::Vector{&lt;:Ferrite.AbstractSparseAssembler},
    cellbuffers::Tuple, 
    states::Tuple, 
    dh::MixedDofHandler, colored_sets::Vector{Vector{Int}}, 
    a::AbstractVector, aold::AbstractVector, Δt::Number, 
    scalings::Vector=create_threaded_scalings(nothing);
    kwargs...)</code></pre><p>Threaded assembly of cells with the <code>dh::MixedDofHandler</code>.</p><ul><li><code>assemblers</code> and <code>colored_sets</code> are the same as for the threaded <code>DofHandler</code> case.</li><li><code>states</code> are the same as for the sequential <code>MixedDofHandler</code> case.</li><li><code>cellbuffers</code> contains vectors <code>Vector{AbstractCellBuffer}</code> for the cell type in  each <code>FieldHandler</code> in <code>dh.fieldhandlers</code>. The vector element corresponds to each  thread. This can be created by <a href="#FerriteAssembly.create_threaded_CellBuffers"><code>create_threaded_CellBuffers</code></a>.  See also <a href="#FerriteAssembly.CellBuffer"><code>CellBuffer</code></a> for more info.</li><li><code>a</code>, <code>aold</code>, and <code>Δt</code> are the same as for the <code>DofHandler</code> case.</li></ul></div></section></article><h2 id="Threaded-assembly"><a class="docs-heading-anchor" href="#Threaded-assembly">Threaded assembly</a><a id="Threaded-assembly-1"></a><a class="docs-heading-anchor-permalink" href="#Threaded-assembly" title="Permalink"></a></h2><p>For parallel assembly, we need a vector of <code>CellBuffer</code>s and assemblers,  one for each thread. </p><p>For the <code>MixedDofHandler</code>, the outer loop is over the type of cells, so we need a tuple that contains vectors of <code>CellBuffer</code>s.  Construction of this via <code>deepcopy</code> is implemented as</p><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.create_threaded_CellBuffers" href="#FerriteAssembly.create_threaded_CellBuffers"><code>FerriteAssembly.create_threaded_CellBuffers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_threaded_CellBuffers(c::CellBuffer; nthreads=Threads.nthreads())
create_threaded_CellBuffers(cs::Tuple; nthreads=Threads.nthreads())
create_threaded_CellBuffers(cs::Dict{String}; nthreads=Threads.nthreads())</code></pre><p>Convenience function for creating a vector with cell buffers for each thread.  The standard workflow is to first call <code>CellBuffer</code> with the  dof handler. For <code>DofHandler</code> this will give a <code>CellBuffer</code>,  and for <code>MixedDofHandler</code> this gives a tuple of <code>CellBuffer</code>s.  In both cases, the output can be given to <code>create_threaded_CellBuffers</code> to produce the appropriate result required by the threaded versions of <a href="#FerriteAssembly.doassemble!"><code>doassemble!</code></a>. Similarily for a grid with mixed materials created by a dictionary of materials,  just pass the created CellBuffer to this function, and the output is what  <code>doassemble!</code> expects. </p></div></section></article><p>A vector of assemblers that is convieniently created by calling </p><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.create_threaded_assemblers" href="#FerriteAssembly.create_threaded_assemblers"><code>FerriteAssembly.create_threaded_assemblers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_threaded_assemblers(K, r; nthreads=Threads.nthreads())</code></pre><p>Convenience function for creating a <code>nthreads</code> long vector with the  output of <code>start_assemble</code> as elements</p></div></section></article><h2 id="Residual-scaling"><a class="docs-heading-anchor" href="#Residual-scaling">Residual scaling</a><a id="Residual-scaling-1"></a><a class="docs-heading-anchor-permalink" href="#Residual-scaling" title="Permalink"></a></h2><p>There are many options for how to scale the residual in finite element simulations. This package does not intend to implement many different options, but does give the  user the option to calculate scaling contributions from each cell, which may be useful. By defining a <code>scaling</code> that is passed to <a href="#FerriteAssembly.doassemble!"><code>doassemble!</code></a>, this can be updated in each cell.  One type of scaling, <a href="#FerriteAssembly.ElementResidualScaling"><code>ElementResidualScaling</code></a>, is included as described below. Its code can be used as a template  for how to include custom scaling that works on the element level. </p><p>In general, a scaling must support the <a href="#FerriteAssembly.update_scaling!"><code>update_scaling!</code></a> function. For consistency it is also nice, but not required, to support <a href="#FerriteAssembly.reset_scaling!"><code>reset_scaling!</code></a>. This function must, however, be called by the user before assembly (to allow consistent separated assembly using different cellsets). </p><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.update_scaling!" href="#FerriteAssembly.update_scaling!"><code>FerriteAssembly.update_scaling!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_scaling!(scaling, re, dh_fh, cellbuffer)</code></pre><p>This function should add the contribution from the element residual vector <code>re</code> to the scaling factors in <code>scaling</code>.  The cellbuffer is included, which contains extra information if needed. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.reset_scaling!" href="#FerriteAssembly.reset_scaling!"><code>FerriteAssembly.reset_scaling!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reset_scaling!(scaling)</code></pre><p>This function should reset the scaling factors, such that the values don&#39;t accumulate if used  in multiple iterations/time steps. </p></div></section></article><p>Additionally, <a href="#FerriteAssembly.create_threaded_scalings"><code>create_threaded_scalings</code></a> can be used to copy one scaling to each thread when using with parallel assembly. </p><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.create_threaded_scalings" href="#FerriteAssembly.create_threaded_scalings"><code>FerriteAssembly.create_threaded_scalings</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_threaded_scalings(scaling; nthreads=Threads.nthreads()) -&gt; Vector</code></pre><p>Makes <code>nthreads</code> deepcopies of <code>scaling</code>, such that it can be used for threaded assembly. Note: If creating your own scaling, it might make sense to define  <code>Base.sum(::Vector{&lt;:MyScalingType})</code> to sum scalings after threaded assembly. </p></div></section></article><h3 id="ElementResidualScaling"><a class="docs-heading-anchor" href="#ElementResidualScaling">ElementResidualScaling</a><a id="ElementResidualScaling-1"></a><a class="docs-heading-anchor-permalink" href="#ElementResidualScaling" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.ElementResidualScaling" href="#FerriteAssembly.ElementResidualScaling"><code>FerriteAssembly.ElementResidualScaling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ElementResidualScaling(dh::AbstractDofHandler, p=2, T=Float64)</code></pre><p>Create tolerance scaling based on the sum of the p-norm of each cell&#39;s residual vector,  separately for each field. I.e. pseudo-code for field <code>:u</code> the scaling <code>factor::T</code> is</p><pre><code class="nohighlight hljs">for each cell
    element_routine!(Ke, re, args...) # Calculate re
    factor += sum(abs.(re[dof_range(dh, :u)]).^p)^(1/p)</code></pre></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/mixed_materials/">« Multiple materials</a><a class="docs-footer-nextpage" href="../datastructures/">Datastructures »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 6 April 2023 21:57">Thursday 6 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
