<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Workers · FerriteAssembly.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://KnutAM.github.io/FerriteAssembly.jl/UserAPI/Workers/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">FerriteAssembly.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../design/">Design</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/plasticity/">Plasticity</a></li><li><a class="tocitem" href="../../examples/mixed_materials/">Multiple materials</a></li><li><a class="tocitem" href="../../ExampleElements/">Example elements</a></li></ul></li><li><a class="tocitem" href="../../MaterialModelsBase/">Builtin elements</a></li><li><span class="tocitem">User API</span><ul><li><a class="tocitem" href="../Setup/">Setup</a></li><li><a class="tocitem" href="../StateVariables/">State variables</a></li><li class="is-active"><a class="tocitem" href>Workers</a><ul class="internal"><li><a class="tocitem" href="#System-matrix-and-vector"><span>System matrix and vector</span></a></li><li><a class="tocitem" href="#Integration"><span>Integration</span></a></li></ul></li><li><a class="tocitem" href="../CellBuffer/">CellBuffer</a></li><li><a class="tocitem" href="../ResidualScaling/">Residual scaling</a></li><li><a class="tocitem" href="../AdvancedFeatures/">Advanced features</a></li></ul></li><li><a class="tocitem" href="../../hack_api/">Hacking API</a></li><li><a class="tocitem" href="../../internals/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User API</a></li><li class="is-active"><a href>Workers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Workers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/main/docs/src/UserAPI/Workers.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Workers"><a class="docs-heading-anchor" href="#Workers">Workers</a><a id="Workers-1"></a><a class="docs-heading-anchor-permalink" href="#Workers" title="Permalink"></a></h1><p>The to perform work, such as assembling, the function <a href="#FerriteAssembly.work!"><code>work!</code></a> should be called with a  given worker and domain buffer. </p><p>There are currently two categories of workers implemented:  which are used to calculate</p><ul><li><a href="#System-matrix-and-vector">Assemblers</a>: Calculate system matrices and vectors</li><li><a href="#Integration">Integrators</a>: Integrate a function over the domain</li></ul><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.work!" href="#FerriteAssembly.work!"><code>FerriteAssembly.work!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">work!(worker, buffer; a=nothing, aold=nothing)</code></pre><p>Perform the work according to <code>worker</code> over the domain(s) specificed by  <code>buffer</code>. Current, <code>a</code>, and old, <code>aold</code>, global degree of freedom vectors  are passed to get these values passed into the innermost user-defined functions. If not passed (or as <code>nothing</code>), <code>NaN</code> values are passed into the innermost functions. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/448ad3f9fcdd7a049e82b797ea2025ace2e14e38/src/work.jl#L1-L8">source</a></section></article><h2 id="System-matrix-and-vector"><a class="docs-heading-anchor" href="#System-matrix-and-vector">System matrix and vector</a><a id="System-matrix-and-vector-1"></a><a class="docs-heading-anchor-permalink" href="#System-matrix-and-vector" title="Permalink"></a></h2><p>In order to assemble the system matrices and residual vectors, it is necessary to define the appropriate  element routine and choose an assembler. The following assemblers can be used to assemble the system matrix and vector:</p><ul><li><a href="https://ferrite-fem.github.io/Ferrite.jl/stable/reference/assembly/#Ferrite.start_assemble"><code>Ferrite.start_assemble</code></a> that returns<ul><li><code>Ferrite.AssemblerSparsityPattern</code></li><li><code>Ferrite.AssemblerSymmetricSparsityPattern</code></li></ul></li><li><a href="#FerriteAssembly.KeReAssembler"><code>KeReAssembler</code></a></li><li><a href="#FerriteAssembly.ReAssembler"><code>ReAssembler</code></a></li></ul><p>Where the ones available in <code>FerriteAssembly</code> have additional features,  such as the possibility of applying constraints locally (see <code>Ferrite.apply_assemble!</code>) or calculate <a href="../ResidualScaling/#ElementResidualScaling">scaling</a> for the residual. </p><h3 id="Element-routines"><a class="docs-heading-anchor" href="#Element-routines">Element routines</a><a id="Element-routines-1"></a><a class="docs-heading-anchor-permalink" href="#Element-routines" title="Permalink"></a></h3><p>One of the element methods should be overloaded for <code>material</code>.  Note that <code>cellvalues</code> are already <code>reinit!</code>:ed for the current cell.</p><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.element_routine!-Tuple" href="#FerriteAssembly.element_routine!-Tuple"><code>FerriteAssembly.element_routine!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">element_routine!(
    Ke::AbstractMatrix, re::AbstractVector, state,
    ae::AbstractVector, material, cellvalues, buffer)</code></pre><p>The main function to be overloaded for the specific <code>material</code>. In most cases, the same implementation can be used for different cellvalues  (e.g. for different interpolation orders) This function should modify the element stiffness matrix <code>Ke</code>, the residual <code>re</code>, and potentially <code>state</code>. The element degree of freedom values, <code>ae</code>, are filled by  <code>NaN</code>s unless <code>a</code> is passed to <a href="#FerriteAssembly.work!"><code>work!</code></a>.</p><p>The following variables can be obtained from <code>buffer</code>.</p><ul><li><a href="../CellBuffer/#FerriteAssembly.get_old_state"><code>get_old_state(buffer)</code></a></li><li><a href="../CellBuffer/#FerriteAssembly.get_aeold"><code>get_aeold(buffer)</code></a></li><li><a href="../CellBuffer/#FerriteAssembly.get_time_increment"><code>get_time_increment(buffer)</code></a></li><li><a href="../CellBuffer/#Ferrite.dof_range-Tuple{FerriteAssembly.AbstractItemBuffer, Symbol}"><code>dof_range(buffer, fieldname::Symbol)</code></a></li><li><a href="../CellBuffer/#Ferrite.getcoordinates-Tuple{FerriteAssembly.AbstractItemBuffer}"><code>getcoordinates(buffer)</code></a></li><li><a href="../CellBuffer/#Ferrite.celldofs-Tuple{FerriteAssembly.AbstractItemBuffer}"><code>celldofs(buffer)</code></a></li><li><a href="../CellBuffer/#Ferrite.cellid-Tuple{FerriteAssembly.AbstractItemBuffer}"><code>cellid(buffer)</code></a></li><li><a href="../CellBuffer/#FerriteAssembly.get_user_data"><code>get_user_data(buffer)</code></a></li><li><a href="../CellBuffer/#FerriteAssembly.get_user_cache"><code>get_user_cache(buffer)</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/448ad3f9fcdd7a049e82b797ea2025ace2e14e38/src/FerriteAssembly.jl#L40-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.element_residual!" href="#FerriteAssembly.element_residual!"><code>FerriteAssembly.element_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">element_residual!(
    re::AbstractVector, state,
    ae::AbstractVector, material, cellvalues, buffer)</code></pre><p>To calculate the element tangent stiffness <code>Ke</code> automatically by using <code>ForwardDiff</code>, it is possible to overload <code>element_residual!</code> instead of <code>element_routine!</code>. See  <a href="../../MaterialModelsBase/#FerriteAssembly.element_routine!-Tuple{Any, Any, Vector{&lt;:MaterialModelsBase.AbstractMaterialState}, Any, MaterialModelsBase.AbstractMaterial, CellVectorValues, Any}"><code>element_routine!</code></a> for a description of the input parameters. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>MethodError</code> with <code>ForwardDiff.Dual</code><br/>When using automatic differentiation for elements with state variables (or other mutating values in e.g. cache), an error will be thrown if trying to change the type in many cases.  When mutating <code>state</code>, call <code>ForwardDiff.value()</code> on the value to be assigned <strong>after</strong>  it will no longer be used to calculate <code>re</code>. (If done on a value which is later affects <code>re</code> inside the element, the tangent, <code>Ke</code>, will be wrong.)</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/448ad3f9fcdd7a049e82b797ea2025ace2e14e38/src/FerriteAssembly.jl#L65-L81">source</a></section></article><h3 id="Assemblers"><a class="docs-heading-anchor" href="#Assemblers">Assemblers</a><a id="Assemblers-1"></a><a class="docs-heading-anchor-permalink" href="#Assemblers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.KeReAssembler" href="#FerriteAssembly.KeReAssembler"><code>FerriteAssembly.KeReAssembler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KeReAssembler(K, r; fillzero=true, kwargs...)
KeReAssembler(a::Ferrite.AbstractSparseAssembler; kwargs...)</code></pre><p>The default <code>KeReAssembler</code> works just like a <code>Ferrite.AbstractSparseAssembler</code>: It will call <code>element_routine!</code> and assemble <code>Ke</code> and <code>re</code> into the global system  matrix <code>K</code> and vector <code>r</code>. However, it comes with the additional possible features, that are controllable via the keyword arguments:</p><ul><li><code>ch::Union{Nothing,ConstraintHandler}=nothing</code>: If a <code>ConstraintHandler</code> is given, local applications of constraints will be applied, using <code>Ferrite.apply_assemble</code>.</li><li><code>apply_zero</code>: Required if a constraint handler is given, and forwarded to <code>Ferrite.apply_assemble</code>. </li><li><code>scaling</code>: Calculate a scaling measure locally at the residual level, see e.g.,  <a href="../ResidualScaling/#FerriteAssembly.ElementResidualScaling"><code>ElementResidualScaling</code></a></li></ul><p><code>a=Ferrite.start_assemble(K, r; fillzero=fillzero)</code> is passed to the second definition  if a matrix, <code>K</code>, and vector, <code>r</code>, are given as input.</p><p><a href="../../hack_api/#FerriteAssembly.reset_scaling!"><code>reset_scaling!</code></a> is called when creating <code>KeReAssembler</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/448ad3f9fcdd7a049e82b797ea2025ace2e14e38/src/Workers/Assemblers.jl#L65-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.ReAssembler" href="#FerriteAssembly.ReAssembler"><code>FerriteAssembly.ReAssembler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReAssembler(r; fillzero=true, scaling=NoScaling())</code></pre><p><code>ReAssembler</code> will call <code>element_residual!</code> and assemble <code>re</code> into the system  vector <code>r</code>. <code>fillzero=true</code> implies that <code>r</code> is zeroed upon construction of  <code>ReAssembler</code>. Furthermore, remaining keyword arguments can enable the following  features:</p><ul><li><code>scaling</code>: Calculate a scaling measure locally at the residual level, see e.g.,  <a href="../ResidualScaling/#FerriteAssembly.ElementResidualScaling"><code>ElementResidualScaling</code></a>. </li></ul><p><a href="../../hack_api/#FerriteAssembly.reset_scaling!"><code>reset_scaling!</code></a> is called when creating <code>ReAssembler</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/448ad3f9fcdd7a049e82b797ea2025ace2e14e38/src/Workers/Assemblers.jl#L22-L33">source</a></section></article><h2 id="Integration"><a class="docs-heading-anchor" href="#Integration">Integration</a><a id="Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Integration" title="Permalink"></a></h2><p>In addition to assembling system matrices and vectors, much of the internal code can be reused  to create quite efficient integration of values, given a solution vector (and potentially state variables). The same domain buffer as for assembly can be used, and exactly as for assembly, we just call  <code>work!(integrator, buffer)</code>. The following integrators are implemented</p><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.SimpleIntegrator" href="#FerriteAssembly.SimpleIntegrator"><code>FerriteAssembly.SimpleIntegrator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimpleIntegrator(fun::Function, val)</code></pre><p>Calculate the integral</p><p class="math-container">\[\int_\Omega f(u, \nabla u, s)\, \mathrm{d}\Omega \]</p><p>For single-field problems, the function signature of <span>$f$</span> is <code>fun(u, ∇u, qp_state)</code>. <code>u</code> is the current function value, <code>∇u</code> the current function gradient, and <code>qp_state</code> the  current state in the current quadrature point. This assumes that <code>cell_state::AbstractVector</code>,  otherwise, <code>qp_state = cell_state</code>.  </p><p>For multi-field problem, we have <code>fun(u::NamedTuple, ∇u::NamedTuple, qp_state)</code>,  where the keys in <code>u</code> and <code>∇u</code> are the fieldnames. The rest is same as for single-field  problems. </p><p>It is the user&#39;s responsibility that <code>fun(args...)::typeof(val)</code>.  Additionally, the type of <code>val</code> must support</p><ul><li><code>val + val</code></li><li><code>val * x</code> (where <code>x::Real</code>)</li><li><code>zero(val)</code></li></ul><p>One exception to these requirements; <code>val::Tuple</code>,  if the elements of the tuple fulfills those requirements.</p><p>Specify <code>domains</code> to only integrate over a part of the grid. It should contain a subset of the keys provided to <code>setup_domainbuffers</code>. Single, <code>String</code>, or collections; <code>Set{String}</code>, <code>AbstractVector{String}</code>, or <code>NTuple{N,String}</code> inputs are supported. If <code>domains=nothing</code>, all domains are integrated. </p><p><strong>Example:</strong> <em>Calculate the average value and gradient</em> <br/>We assume that we have done the setup: <code>buffer = setup_domainbuffer(...)</code>,<br/>assembled <code>K</code> and <code>r</code>, and solved <code>a=K\r</code></p><pre><code class="language-julia hljs">integrator = SimpleIntegrator((u, ∇u, state)-&gt;(1.0, u, ∇u), (0.0, 0.0, zero(Vec{dim})))
work!(integrator, buffer; a=a)
area = integrator.val[1]
u_avg = integrator.val[2]/area 
∇u_avg = integrator.val[3]/area</code></pre><p>If the <code>buffer</code> is setup to be threaded, this calculation will also be threaded. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/448ad3f9fcdd7a049e82b797ea2025ace2e14e38/src/Workers/Integrators.jl#L47-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.Integrator" href="#FerriteAssembly.Integrator"><code>FerriteAssembly.Integrator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Integrator(val::V; domains=nothing)</code></pre><p>Integrate over the domain by modifying the value <code>val</code> for each cell in the function  <code>integrate_cell</code>, which should be overloaded for the specific combination of <code>val::V</code>  and the material for that cell. <code>V</code> must be a mutable type.</p><p>Specify <code>domains</code> to only integrate over a part of the grid. It should contain the names of the domains to integrate over. Single, <code>String</code>, or collections; <code>Set{String}</code>, <code>AbstractVector{String}</code>, or <code>NTuple{N,String}</code> inputs are supported. If <code>domains=nothing</code>, all domains are integrated. </p><p><strong>Note</strong>: This integrator will currently only run sequentially even if a  threaded assembly is setup with <a href="../Setup/#FerriteAssembly.setup_domainbuffer"><code>setup_domainbuffer</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/448ad3f9fcdd7a049e82b797ea2025ace2e14e38/src/Workers/Integrators.jl#L1-L15">source</a></section></article><h3 id="Integration-routines"><a class="docs-heading-anchor" href="#Integration-routines">Integration routines</a><a id="Integration-routines-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-routines" title="Permalink"></a></h3><p>The general integrator requires overloading the <code>integrate_cell!</code> function</p><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.integrate_cell!" href="#FerriteAssembly.integrate_cell!"><code>FerriteAssembly.integrate_cell!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">integrate_cell!(val, cell_state, ae, material, cv, cellbuffer)</code></pre><p>Function to be overloaded for <code>val</code> (potentially in combination with <code>material</code>), and will be called when using <a href="#FerriteAssembly.Integrator"><code>Integrator</code></a>. Mutate <code>val</code> to add to the result.</p><p>The order of the inputs is chosen to follow the element routines</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/448ad3f9fcdd7a049e82b797ea2025ace2e14e38/src/Workers/Integrators.jl#L28-L35">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../StateVariables/">« State variables</a><a class="docs-footer-nextpage" href="../CellBuffer/">CellBuffer »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 30 July 2023 21:59">Sunday 30 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
