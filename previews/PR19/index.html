<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · FerriteAssembly.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://KnutAM.github.io/FerriteAssembly.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>FerriteAssembly.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Heat-equation-example"><span>Heat equation example</span></a></li></ul></li><li><a class="tocitem" href="design/">Design</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="examples/plasticity/">Plasticity</a></li><li><a class="tocitem" href="examples/mixed_materials/">Multiple materials</a></li><li><a class="tocitem" href="ExampleElements/">Example elements</a></li></ul></li><li><a class="tocitem" href="MaterialModelsBase/">Builtin elements</a></li><li><span class="tocitem">User API</span><ul><li><a class="tocitem" href="UserAPI/Setup/">Setup</a></li><li><a class="tocitem" href="UserAPI/StateVariables/">State variables</a></li><li><a class="tocitem" href="UserAPI/Workers/">Workers</a></li><li><a class="tocitem" href="UserAPI/CellBuffer/">CellBuffer</a></li><li><a class="tocitem" href="UserAPI/ResidualScaling/">Residual scaling</a></li><li><a class="tocitem" href="UserAPI/AdvancedFeatures/">Advanced features</a></li></ul></li><li><a class="tocitem" href="hack_api/">Hacking API</a></li><li><a class="tocitem" href="internals/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="FerriteAssembly"><a class="docs-heading-anchor" href="#FerriteAssembly">FerriteAssembly</a><a id="FerriteAssembly-1"></a><a class="docs-heading-anchor-permalink" href="#FerriteAssembly" title="Permalink"></a></h1><p>The goal of <a href="https://github.com/KnutAM/FerriteAssembly.jl">FerriteAssembly</a>  is make it convenient to iterate over a grid and perform some task for each item. The primary use is to iterate over all cells and assemble into global matrices and  vectors. However, it makes many other tasks easy as well, for example iterating over faces for adding boundary conditions, or integrating a function over a given domain. </p><p>The design is built around two main object types</p><ol><li><strong>Worker</strong>: What to do for each item</li><li><strong>Domain</strong>: What items to work on</li></ol><p>More details are given in <a href="design/">Package Design</a>, which is a recommended read for understanding the structure of the package. The current page highlights an example for doing standard assembly over cells. But before diving into that example, we give a short list with links to examples for some common tasks that <code>FerriteAssembly.jl</code> can help you with.</p><p><strong>TODO:</strong> <em>Add links and examples</em></p><ul><li>Easy Neumann boundary conditions</li><li>Models with state variables</li><li>Multiple domains</li><li>Mixed grids</li><li>Calculate integral quantities</li><li>Postprocess data in each cell</li><li>Robin boundary conditions</li></ul><h2 id="Heat-equation-example"><a class="docs-heading-anchor" href="#Heat-equation-example">Heat equation example</a><a id="Heat-equation-example-1"></a><a class="docs-heading-anchor-permalink" href="#Heat-equation-example" title="Permalink"></a></h2><p>The full example can be downloaded <a href="firstexample.jl">here</a>. In order to use FerriteAssembly for assembly, we need to</p><ol><li>Define a custom <code>material</code> that determines the physics</li><li>Overload <code>element_routine!</code> or <code>element_residual!</code> for that material.</li></ol><p>We can then set up Ferrite in the standard way, by defining a Grid, DofHandler, and CellValues. We then pass these to the setup_domainbuffer function and create an assembler (worker), allowing us to perform the work with the <code>work!</code> function.</p><h3>Standard Ferrite setup</h3><p>First we create the dofhandler and cellvalues as in <a href="https://ferrite-fem.github.io/Ferrite.jl/stable/examples/heat_equation/"><code>Ferrite.jl</code>&#39;s heat equation example</a></p><pre><code class="language-julia hljs">using Ferrite, FerriteAssembly, BenchmarkTools
dh = DofHandler(generate_grid(Quadrilateral, (100, 100))); add!(dh, :u, 1); close!(dh)
cellvalues = CellScalarValues(QuadratureRule{2, RefCube}(2), Lagrange{2, RefCube, 1}());
K = create_sparsity_pattern(dh)
r = zeros(ndofs(dh));</code></pre><h3>Define the physics</h3><p>We start by defining the material and create an instance of it</p><pre><code class="language-julia hljs">struct ThermalMaterial
    k::Float64 # Thermal conductivity
    f::Float64 # Volumetric heat source
end
material = ThermalMaterial(1.0, 1.0)</code></pre><pre><code class="nohighlight hljs">Main.var&quot;##335&quot;.ThermalMaterial(1.0, 1.0)</code></pre><p>and then define our <code>element_routine!</code> for that material as</p><pre><code class="language-julia hljs">function FerriteAssembly.element_routine!(Ke, re, state, ae,
        material::ThermalMaterial, cellvalues, cellbuffer
        )
    n_basefuncs = getnbasefunctions(cellvalues)
    # Loop over quadrature points
    for q_point in 1:getnquadpoints(cellvalues)
        dΩ = getdetJdV(cellvalues, q_point)
        for i in 1:n_basefuncs
            δN  = shape_value(cellvalues, q_point, i)
            ∇δN = shape_gradient(cellvalues, q_point, i)
            # Add body load contribution to re
            re[i] += -material.f*δN * dΩ
            # Loop over trial shape functions
            for j in 1:n_basefuncs
                ∇N = shape_gradient(cellvalues, q_point, j)
                # Add contribution to Ke
                Ke[i, j] += material.k*(∇δN ⋅ ∇N) * dΩ
            end
        end
    end
end;</code></pre><p>which is basically the same as in <code>Ferrite.jl</code>&#39;s example.</p><h3>Setting up the domain.</h3><p>We first start by defining a domain and passing that to the <code>setup_domainbuffer</code> function.</p><pre><code class="language-julia hljs">grid_domain = DomainSpec(dh, material, cellvalues)
buffer = setup_domainbuffer(grid_domain);</code></pre><h3>Performing the assembly</h3><p>The <code>worker</code> in this case is the standard Ferrite assembler:</p><pre><code class="language-julia hljs">assembler = start_assemble(K, r);</code></pre><p>Given this worker, we can do the work to assemble <code>K</code> and <code>r</code></p><pre><code class="language-julia hljs">work!(assembler, buffer);</code></pre><h3>Threaded assembly</h3><p>To do the assembly in the example above threaded, we just tell <code>setup_domainbuffer</code> that:</p><pre><code class="language-julia hljs">threaded_buffer = setup_domainbuffer(grid_domain; threading=true);</code></pre><p>This creates a default coloring of the grid, but custom coloring can also be given.</p><p>We can call <code>work!</code> as before</p><pre><code class="language-julia hljs">assembler = start_assemble(K, r)
work!(assembler, threaded_buffer);</code></pre><h3>Automatic Differentiation</h3><p>Deriving the analytical element stiffness is often time-consuming, and can be avoided by using Automatic Differentiation (AD). FerriteAssembly supports this: Just define <a href="UserAPI/Workers/#FerriteAssembly.element_residual!"><code>element_residual!</code></a> instead of <a href="MaterialModelsBase/#FerriteAssembly.element_routine!-Tuple{Any, Any, Vector{&lt;:MaterialModelsBase.AbstractMaterialState}, Any, MaterialModelsBase.AbstractMaterial, CellVectorValues, Any}"><code>element_routine!</code></a> for your material.</p><pre><code class="language-julia hljs">struct ThermalMaterialAD
    k::Float64 # Thermal conductivity
    f::Float64 # Volumetric heat source
end
material_ad = ThermalMaterialAD(1.0, 1.0)

function FerriteAssembly.element_residual!(re, state, ae,
        material::ThermalMaterialAD, cellvalues, cellbuffer
        )
    n_basefuncs = getnbasefunctions(cellvalues)
    # Loop over quadrature points
    for q_point in 1:getnquadpoints(cellvalues)
        # Get the quadrature weight
        dΩ = getdetJdV(cellvalues, q_point)
        ∇u = function_gradient(cellvalues, q_point, ae)
        # Loop over test shape functions
        for i in 1:n_basefuncs
            δN  = shape_value(cellvalues, q_point, i)
            ∇δN = shape_gradient(cellvalues, q_point, i)
            # re = fint - fext
            re[i] += (material.k*(∇δN ⋅ ∇u) - material.f*δN) * dΩ
        end
    end
end;</code></pre><p>We use the same setup as before, but with <code>material_ad</code></p><pre><code class="language-julia hljs">grid_domain_ad = DomainSpec(dh, material_ad, cellvalues)
buffer_ad = setup_domainbuffer(grid_domain_ad);</code></pre><p>In this case we need the <code>ae</code> input and must therefore define <code>a</code>:</p><pre><code class="language-julia hljs">a = zeros(ndofs(dh))
assembler = start_assemble(K, r)
work!(assembler, buffer_ad; a=a);</code></pre><h3>AD performance</h3><p>Explicitly defining the element stiffness was a lot faster and has less allocations:</p><pre><code class="language-julia hljs">@btime work!($assembler, $buffer; a=$a)
@btime work!($assembler, $buffer_ad; a=$a)</code></pre><pre><code class="nohighlight hljs">  5.499 ms (0 allocations: 0 bytes)
  13.891 ms (60000 allocations: 9.46 MiB)
</code></pre><p>FerriteAssembly comes with a special <code>cellbuffer</code> for speeding up automatic differentiation, we can significantly improve the performance.</p><pre><code class="language-julia hljs">buffer_ad2 = setup_domainbuffer(grid_domain_ad; autodiffbuffer=true)
@btime work!($assembler, $buffer_ad2; a=$a)</code></pre><pre><code class="nohighlight hljs">  6.450 ms (0 allocations: 0 bytes)
</code></pre><hr/><p><em>The examples were generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="design/">Design »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 30 July 2023 23:54">Sunday 30 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
