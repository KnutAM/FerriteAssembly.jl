var documenterSearchIndex = {"docs":
[{"location":"Workers/Integrators/#Integrators","page":"Integrators","title":"Integrators","text":"","category":"section"},{"location":"Workers/Integrators/","page":"Integrators","title":"Integrators","text":"In addition to assembling system matrices and vectors, much of the internal code can be reused  to create quite efficient integration of values, given a solution vector (and potentially state variables). This feature can also be used to calculate per-cell (or per-integration point) quantities, simply by  defining an integrator containing a vector that is indexed by the global cell id. ","category":"page"},{"location":"Workers/Integrators/#Available-integrators","page":"Integrators","title":"Available integrators","text":"","category":"section"},{"location":"Workers/Integrators/#SimpleIntegrator","page":"Integrators","title":"SimpleIntegrator","text":"","category":"section"},{"location":"Workers/Integrators/","page":"Integrators","title":"Integrators","text":"SimpleIntegrator","category":"page"},{"location":"Workers/Integrators/#FerriteAssembly.SimpleIntegrator","page":"Integrators","title":"FerriteAssembly.SimpleIntegrator","text":"SimpleIntegrator(fun::Function, val; domains=nothing)\n\nCalculate the integrals\n\nint_Omega f(u nabla u s) mathrmdOmega\nint_Gamma f(u nabla u n) mathrmdGamma \n\nfor cell and face domains respectively.  For single-field problems, u is the current function value, ∇u the current function gradient. For multi-field problem, u and ∇u are NamedTuples, where the keys in u and ∇u are the fieldnames. \n\nFor cell domains, qp_state the current state in the current quadrature point.  This assumes that cell_state::AbstractVector, otherwise, qp_state = cell_state.   For face domains, n is the face normal vector. \n\nIt is the user's responsibility that fun(args...)::typeof(val).  Additionally, the type of val must support\n\nval + val\nval * x (where x::Real)\nzero(val)\n\nOne exception to these requirements; val::Tuple,  if the elements of the tuple fulfills those requirements.\n\nSpecify domains to only integrate over a part of the grid. It should contain a subset of the keys provided to setup_domainbuffers. Single, String, or collections; Set{String}, AbstractVector{String}, or NTuple{N,String} inputs are supported. If domains=nothing, all domains are integrated. \n\nExample: Calculate the average value and gradient \nWe assume that we have done the setup: buffer = setup_domainbuffer(...),\nassembled K and r, and solved a=K\\r\n\nintegrator = SimpleIntegrator((u, ∇u, state)->(1.0, u, ∇u), (0.0, 0.0, zero(Vec{dim})))\nwork!(integrator, buffer; a=a)\narea = integrator.val[1]\nu_avg = integrator.val[2]/area \n∇u_avg = integrator.val[3]/area\n\nIf the buffer is setup to be threaded, this calculation will also be threaded. \n\n\n\n\n\n","category":"type"},{"location":"Workers/Integrators/#Integrator","page":"Integrators","title":"Integrator","text":"","category":"section"},{"location":"Workers/Integrators/","page":"Integrators","title":"Integrators","text":"Integrator","category":"page"},{"location":"Workers/Integrators/#FerriteAssembly.Integrator","page":"Integrators","title":"FerriteAssembly.Integrator","text":"Integrator(val::V; domains=nothing)\n\nIntegrate over the domain by modifying the value val for each cell in the function  integrate_cell, which should be overloaded for the specific combination of val::V  and the material for that cell. V must be a mutable type.\n\nSpecify domains to only integrate over a part of the grid. It should contain the names of the domains to integrate over. Single, String, or collections; Set{String}, AbstractVector{String}, or NTuple{N,String} inputs are supported. If domains=nothing, all domains are integrated. \n\nNote: This integrator will currently only run sequentially even if a  threaded assembly is setup with setup_domainbuffer\n\n\n\n\n\n","category":"type"},{"location":"Workers/Integrators/#Functions-to-overload","page":"Integrators","title":"Functions to overload","text":"","category":"section"},{"location":"Workers/Integrators/","page":"Integrators","title":"Integrators","text":"Using the Integrator requires the following functions  to be overloaded, depending on the type of domain","category":"page"},{"location":"Workers/Integrators/","page":"Integrators","title":"Integrators","text":"FerriteAssembly.integrate_cell!\nFerriteAssembly.integrate_face!","category":"page"},{"location":"Workers/Integrators/#FerriteAssembly.integrate_cell!","page":"Integrators","title":"FerriteAssembly.integrate_cell!","text":"integrate_cell!(val, cell_state, ae, material, cv, cellbuffer)\n\nFunction to be overloaded for val (potentially in combination with material), and will be called when using Integrator. Mutate val to add to the result.\n\nThe order of the inputs is chosen to follow the element routines\n\n\n\n\n\n","category":"function"},{"location":"Workers/Integrators/#FerriteAssembly.integrate_face!","page":"Integrators","title":"FerriteAssembly.integrate_face!","text":"integrate_face!(val, ae, material, fv, facebuffer)\n\nFunction to be overloaded for val (potentially in combination with material), and will be called when using Integrator. Mutate val to add to the result.\n\nThe order of the inputs is chosen to follow the element routines\n\n\n\n\n\n","category":"function"},{"location":"Convenience/ExampleElements/#Example-elements","page":"Example elements","title":"Example elements","text":"","category":"section"},{"location":"Convenience/ExampleElements/","page":"Example elements","title":"Example elements","text":"The package includes a set of example elements inside the submodule FerriteAssembly.ExampleElements. In order to use these it is possible to import them explicitly as, e.g.,","category":"page"},{"location":"Convenience/ExampleElements/","page":"Example elements","title":"Example elements","text":"import FerriteAssembly.ExampleElements: StationaryFourier","category":"page"},{"location":"Convenience/ExampleElements/#Overview","page":"Example elements","title":"Overview","text":"","category":"section"},{"location":"Convenience/ExampleElements/","page":"Example elements","title":"Example elements","text":"StationaryFourier\nTransientFourier\nElasticPlaneStrain\nPoroElasticPlaneStrain\nWeakForm\nJ2Plasticity","category":"page"},{"location":"Convenience/ExampleElements/#Available-example-elements","page":"Example elements","title":"Available example elements","text":"","category":"section"},{"location":"Convenience/ExampleElements/","page":"Example elements","title":"Example elements","text":"The following elements are implemented as full elements","category":"page"},{"location":"Convenience/ExampleElements/","page":"Example elements","title":"Example elements","text":"ExampleElements.StationaryFourier\nExampleElements.TransientFourier\nExampleElements.ElasticPlaneStrain\nExampleElements.PoroElasticPlaneStrain\nExampleElements.WeakForm","category":"page"},{"location":"Convenience/ExampleElements/#FerriteAssembly.ExampleElements.StationaryFourier","page":"Example elements","title":"FerriteAssembly.ExampleElements.StationaryFourier","text":"StationaryFourier(k)\n\nFor solving stationary linear heat conduction (which uses Fourier's law) with conductivity k,  such that the heat flux is boldsymbolq=-k nabla T, where T is the temperature field. \n\nThe strong form is,\n\n nabla cdot boldsymbolq = h  quad textbfx in Omega\n\nand the corresponding weak form is \n\n   -int_Omega nabla delta T cdot boldsymbolq mathrmdOmega \n   = - int_Gamma delta T q_mathrmn mathrmdGamma \n     + int_Omega delta T h mathrmdOmega\n\nwhere, on the right hand side, q_mathrmn is a heat flux normal to the boundary Gamma, and h is a volumetric heat supply.  These contributions are not included in the element, and should be added with FerriteNeumann.jl\n\n\n\n\n\n","category":"type"},{"location":"Convenience/ExampleElements/#FerriteAssembly.ExampleElements.TransientFourier","page":"Example elements","title":"FerriteAssembly.ExampleElements.TransientFourier","text":"TransientFourier(k, c)\n\nFor solving the transient linear heat equation (which uses Fourier's law) with conductivity k,  such that the heat flux is boldsymbolq=-k nabla T, where T is the temperature field. \n\nThe strong form is,\n\n    c dotT + nabla cdot boldsymbolq = h  quad textbfx in Omega\n\nand the corresponding time-discretized weak form is \n\n    int_Omega delta T c fracT - ^mathrmnTDelta t mathrmdOmega\n    - int_Omega nabla delta T cdot boldsymbolq mathrmdOmega \n   = - int_Gamma delta T q_mathrmn mathrmdGamma \n     + int_Omega delta T h mathrmdOmega\n\nwhere ^mathrmnT is the old temperature (in the previous timestep) and Delta t is the timestep.  On the right hand side, q_mathrmn is a heat flux normal to the boundary Gamma, and h is a volumetric heat supply.  These external contributions on the right hand side are not included in the element,  and should be added with FerriteNeumann.jl\n\n\n\n\n\n","category":"type"},{"location":"Convenience/ExampleElements/#FerriteAssembly.ExampleElements.ElasticPlaneStrain","page":"Example elements","title":"FerriteAssembly.ExampleElements.ElasticPlaneStrain","text":"ElasticPlaneStrain(;E=2.e3, ν=0.3)\n\nFor solving linear elasticity for plane strain, where Young's modulus, E, and Poisson's ratio, ν, is used to construct the correct stiffness tensor, boldsymbolmathsfC,  such that the stress, boldsymbolsigma=boldsymbolmathsfCboldsymbolepsilon,  where the strain tensor, boldsymbolepsilon=boldsymboluotimesnabla^mathrmsym, is calculated from the displacement field, boldsymbolu(boldsymbolxt). \n\nThe strong form of the mechanical quasi-static equilibrium is\n\n    boldsymbolsigma cdot nabla + boldsymbolb = 0 quad textbfx in Omega\n\nwith the corresponding weak form, \n\n   int_Omega boldsymboldelta uotimesnabla^mathrmsym  boldsymbolsigma mathrmdOmega \n   = int_Gamma boldsymboldelta u cdot boldsymbolt mathrmdGamma \n   + int_Omega boldsymboldelta u cdot boldsymbolb mathrmdOmega\n\nThe external loading on the right hand side is not included in the element, but can be implemented  using FerriteNeumann.jl.  (Note that this constructor returns LinearElastic, which just stores the  correct stiffness tensor for the case of isotropic plane strain)\n\n\n\n\n\n","category":"function"},{"location":"Convenience/ExampleElements/#FerriteAssembly.ExampleElements.PoroElasticPlaneStrain","page":"Example elements","title":"FerriteAssembly.ExampleElements.PoroElasticPlaneStrain","text":"PoroElasticPlaneStrain(;E=2.e3, ν=0.3, k=0.05, α=1.0, β=1/2e3)\n\nThe strong forms are given as\n\nbeginaligned\nboldsymbolsigma(boldsymbolepsilon p) cdot boldsymbolnabla = boldsymbol0 \ndotPhi(boldsymbolepsilon p) + boldsymbolw(p) cdot boldsymbolnabla = 0\nendaligned\n\nwhere  boldsymbolepsilon = leftboldsymboluotimesboldsymbolnablaright^mathrmsym  The constitutive relationships are \n\nbeginaligned\nboldsymbolsigma = boldsymbolmathsfEboldsymbolepsilon - alpha p boldsymbolI \nboldsymbolw = - k boldsymbolnabla p \nPhi = phi + alpha mathrmtr(boldsymbolepsilon) + beta p\nendaligned\n\nwith  boldsymbolmathsfE=2G boldsymbolmathsfI^mathrmdev + 3K boldsymbolIotimesboldsymbolI. The material parameters are then the  shear modulus, G,  bulk modulus, K,  permeability, k,   Biot's coefficient, alpha, and liquid compressibility, beta. The porosity, phi, doesn't enter into the equations  (A different porosity leads to different skeleton stiffness and permeability).\n\nThe weak forms are\n\nbeginaligned\nint_Omega leftleftboldsymboldelta uotimesboldsymbolnablaright^mathrmsym\nboldsymbolmathsfEboldsymbolepsilon - boldsymboldelta u cdot boldsymbolnabla alpha pright mathrmdOmega \n= int_Gamma boldsymboldelta u cdot boldsymbolt mathrmd Gamma \nint_Omega leftdelta p leftalpha dotboldsymbolu cdot boldsymbolnabla + beta dotpright + \nboldsymbolnabla(delta p) cdot k boldsymbolnablaright mathrmdOmega \n= -int_Gamma delta p w_mathrmn mathrmd Gamma \nendaligned\n\nwhere boldsymbolt=boldsymbolncdotboldsymbolsigma is the traction and  w_mathrmn = boldsymbolncdotboldsymbolw is the normal flux.  \n\n\n\n\n\n","category":"type"},{"location":"Convenience/ExampleElements/#FerriteAssembly.ExampleElements.WeakForm","page":"Example elements","title":"FerriteAssembly.ExampleElements.WeakForm","text":"WeakForm(f::Function)\n\nSolve the problem with primary variable, u, variation, delta u, and a weak form\n\n   int_Omega f(delta u delta u otimesnabla u u otimesnabla dotu dotu otimesnabla) mathrmdOmega \n   - int_Gamma delta u h(xtn) mathrmdGamma - int_Omega delta u b(xt) mathrmdOmega = 0\n\nwhere the function f is given to the weak form, and h and b are given with FerriteNeumann.\n\nnote: This element is intended for testing\nIt is not optimized for speed\n\nExamples\n\nTransient heat flow\n\nWeak form\n\n    int_Omega delta u c dotu + k nabla delta u cdot nabla u mathrmdOmega \n   + int_Gamma delta u q_mathrmn mathrmdGamma - int_Omega delta u b mathrmdOmega = 0\n\nImplementation This implementation is equivalent to TransientFourier, but it is also possible to add the body load directly in the weak form (if desired). \n\nc = 1.0; k = 1.0; # heat capacity and heat conductivity (material parameters)\nqn = 1.0; b=1.0;  # Normal boundary flux and internal heat source (external loading)\nmaterial = WeakForm((δu, ∇δu, u, ∇u, u_dot, ∇u_dot) -> δu*c*u_dot + k*(∇δu ⋅ ∇u))\nnh = NeumannHandler(dh)\nadd!(nh, Neumann(:u, 2, getfaceset(dh.grid, \"right\"), (x,t,n)->qn))\nadd!(nh, BodyLoad(:c, 1, (x,t)->b))\n\nLinear elasticity\n\nThis implementation is equivalent to ElasticPlaneStrain, but it is also possible to add the body load directly in the weak form (if desired).  Weak form\n\n   int_Omega boldsymboldelta uotimesnabla^mathrmsym  boldsymbolsigma mathrmdOmega \n   - int_Gamma boldsymboldelta u cdot boldsymbolt mathrmdGamma \n   - int_Omega boldsymboldelta u cdot boldsymbolb mathrmdOmega = 0\n\nImplementation\n\nG = 80e3; K = 160e3; # Shear and bulk modulus (material parameters)\ntn = 1.0, b=Vec((0.0, 0.0, -1.0)); # Normal traction and body force (external loading)\nmaterial = WeakForm((δu, ∇δu, u, ∇u, u_dot, ∇u_dot) -> (∇δu ⊡ (2*G*dev(symmetric(∇u)) + 3*K*vol(∇u))))\nnh = NeumannHandler(dh)\nadd!(nh, Neumann(:u, 2, getfaceset(dh.grid, \"right\"), (x,t,n)->tn*n))\nadd!(nh, BodyLoad(:c, 2, (x,t)->b))\n\n\n\n\n\n","category":"type"},{"location":"Convenience/ExampleElements/#Available-example-mechanical-materials","page":"Example elements","title":"Available example mechanical materials","text":"","category":"section"},{"location":"Convenience/ExampleElements/","page":"Example elements","title":"Example elements","text":"The following physical behaviors are implemented as a  MaterialModelsBase.jl material, which is supported as a regular element as well.","category":"page"},{"location":"Convenience/ExampleElements/","page":"Example elements","title":"Example elements","text":"ExampleElements.J2Plasticity","category":"page"},{"location":"Convenience/ExampleElements/#FerriteAssembly.ExampleElements.J2Plasticity","page":"Example elements","title":"FerriteAssembly.ExampleElements.J2Plasticity","text":"J2Plasticity(;E, ν, σ0, H) <: MaterialModelsBase.AbstractMaterial\n\nThis plasticity model is taken from Ferrite.jl's plasticity  example, and considers linear isotropic hardening, with Young's modulus, E, Poisson's ratio, ν, initial yield limit, σ0, and hardening modulus, H. It is defined  as an AbstractMaterial following the MaterialModelsBase interface. \n\n\n\n\n\n","category":"type"},{"location":"DomainBuffers/ItemBuffer/","page":"ItemBuffer","title":"ItemBuffer","text":"CurrentModule = FerriteAssembly","category":"page"},{"location":"DomainBuffers/ItemBuffer/#AbstractItemBuffer","page":"ItemBuffer","title":"AbstractItemBuffer","text":"","category":"section"},{"location":"DomainBuffers/ItemBuffer/","page":"ItemBuffer","title":"ItemBuffer","text":"Depening on the domain that is worked over, different item buffers are available,  e.g. CellBuffer and FaceBuffer. These are set up during call to setup_domainbuffer.","category":"page"},{"location":"DomainBuffers/ItemBuffer/","page":"ItemBuffer","title":"ItemBuffer","text":"For each item (cell or face), the values in the buffer are updated to the current item, and can be accessed with the following functions:","category":"page"},{"location":"DomainBuffers/ItemBuffer/","page":"ItemBuffer","title":"ItemBuffer","text":"get_aeold\nget_old_state\nget_time_increment\nFerrite.dof_range(::AbstractItemBuffer, ::Symbol)\nFerrite.getcoordinates(::AbstractItemBuffer)\nFerrite.celldofs(::AbstractItemBuffer)\nFerrite.cellid(::AbstractItemBuffer)\nget_user_data\nget_user_cache","category":"page"},{"location":"DomainBuffers/ItemBuffer/#FerriteAssembly.get_aeold","page":"ItemBuffer","title":"FerriteAssembly.get_aeold","text":"get_aeold(itembuffer::AbstractItemBuffer)\n\nGet the degrees of freedom pertinent to the values object (e.g. cellvalues) in the itembuffer. \n\nNote: Filled by NaNs unless aold is passed to work!\n\n\n\n\n\n","category":"function"},{"location":"DomainBuffers/ItemBuffer/#FerriteAssembly.get_old_state","page":"ItemBuffer","title":"FerriteAssembly.get_old_state","text":"get_old_state(itembuffer::AbstractCellBuffer)\n\nGet the old state variables for the cell. Currently only available for cells and not for faces. \n\n\n\n\n\n","category":"function"},{"location":"DomainBuffers/ItemBuffer/#FerriteAssembly.get_time_increment","page":"ItemBuffer","title":"FerriteAssembly.get_time_increment","text":"get_time_increment(itembuffer::AbstractItemBuffer)\n\nGet the time increment to get to the current step.  Set by set_time_increment!.\n\n\n\n\n\n","category":"function"},{"location":"DomainBuffers/ItemBuffer/#Ferrite.dof_range-Tuple{FerriteAssembly.AbstractItemBuffer, Symbol}","page":"ItemBuffer","title":"Ferrite.dof_range","text":"Ferrite.dof_range(::AbstractItemBuffer, ::Symbol)\n\nGet the dof_range for a specific field, same as  Ferrite.dof_range(::SubDofHandler, ::Symbol),  but fully type-stable. \n\n\n\n\n\n","category":"method"},{"location":"DomainBuffers/ItemBuffer/#Ferrite.getcoordinates-Tuple{FerriteAssembly.AbstractItemBuffer}","page":"ItemBuffer","title":"Ferrite.getcoordinates","text":"Ferrite.getcoordinates(::AbstractItemBuffer)\n\nGet the cell coordinates for the current item. \n\n\n\n\n\n","category":"method"},{"location":"DomainBuffers/ItemBuffer/#Ferrite.celldofs-Tuple{FerriteAssembly.AbstractItemBuffer}","page":"ItemBuffer","title":"Ferrite.celldofs","text":"Ferrite.celldofs(::AbstractItemBuffer)\n\nGet the degree of freedom indices for the current cell referred to  by the current item. \n\n\n\n\n\n","category":"method"},{"location":"DomainBuffers/ItemBuffer/#Ferrite.cellid-Tuple{FerriteAssembly.AbstractItemBuffer}","page":"ItemBuffer","title":"Ferrite.cellid","text":"Ferrite.cellid(::AbstractItemBuffer)\n\nGet the cell nr for the current item. \n\n\n\n\n\n","category":"method"},{"location":"DomainBuffers/ItemBuffer/#FerriteAssembly.get_user_data","page":"ItemBuffer","title":"FerriteAssembly.get_user_data","text":"get_user_data(itembuffer::AbstractItemBuffer)\n\nGet the user_data passed to the DomainSpec when setting up the domain.  This is not modified and always passed around as reference. \n\n\n\n\n\n","category":"function"},{"location":"DomainBuffers/ItemBuffer/#FerriteAssembly.get_user_cache","page":"ItemBuffer","title":"FerriteAssembly.get_user_cache","text":"get_user_cache(itembuffer::AbstractItemBuffer)\n\nGet the user_cache created by allocate_cell_cache. For multithreaded applications, this cache is copied between  for each tasks, and can be modified without risking race conditions. \n\n\n\n\n\n","category":"function"},{"location":"DomainBuffers/ItemBuffer/#AbstractCellBuffer","page":"ItemBuffer","title":"AbstractCellBuffer","text":"","category":"section"},{"location":"DomainBuffers/ItemBuffer/","page":"ItemBuffer","title":"ItemBuffer","text":"Two types of cell buffers are provided, the regular CellBuffer and a wrapper AutoDiffCellBuffer that speeds up the automatic differentiation. By using the above access functions, these behave identical.","category":"page"},{"location":"DomainBuffers/ItemBuffer/","page":"ItemBuffer","title":"ItemBuffer","text":"To allocate the user cache, overload allocate_cell_cache:","category":"page"},{"location":"DomainBuffers/ItemBuffer/","page":"ItemBuffer","title":"ItemBuffer","text":"allocate_cell_cache(::Any, ::Any)","category":"page"},{"location":"DomainBuffers/ItemBuffer/#FerriteAssembly.allocate_cell_cache-Tuple{Any, Any}","page":"ItemBuffer","title":"FerriteAssembly.allocate_cell_cache","text":"FerriteAssembly.allocate_cell_cache(material, cellvalues)\n\nThis function can be overloaded for the specific material to allocate  a cache that is stored in the AbstractCellBuffer. This cache can be  used to reduce allocations. Returns nothing by default.\n\n\n\n\n\n","category":"method"},{"location":"DomainBuffers/ItemBuffer/#FaceBuffer","page":"ItemBuffer","title":"FaceBuffer","text":"","category":"section"},{"location":"DomainBuffers/ItemBuffer/","page":"ItemBuffer","title":"ItemBuffer","text":"The FaceBuffer is similar to the CellBuffer, except that it has FaceValues instead of CellValues and that state variables are not supported. To allocate user cache, overload allocate_face_cache:","category":"page"},{"location":"DomainBuffers/ItemBuffer/","page":"ItemBuffer","title":"ItemBuffer","text":"allocate_face_cache","category":"page"},{"location":"DomainBuffers/ItemBuffer/#FerriteAssembly.allocate_face_cache","page":"ItemBuffer","title":"FerriteAssembly.allocate_face_cache","text":"FerriteAssembly.allocate_face_cache(material, cellvalues)\n\nThis function can be overloaded for the specific material to allocate  a cache that is stored in the FaceBuffer and can be used to reduce  allocations. Returns nothing by default.\n\n\n\n\n\n","category":"function"},{"location":"Convenience/MaterialModelsBase/#MaterialModelsBase","page":"Mechanical materials","title":"MaterialModelsBase","text":"","category":"section"},{"location":"Convenience/MaterialModelsBase/","page":"Mechanical materials","title":"Mechanical materials","text":"For constitutive mechanical behavior following the  MaterialModelsBase.jl interface, element_routine!,  element_residual!,  create_cell_state,  and allocate_cell_cache are implemented in FerriteAssembly.jl.","category":"page"},{"location":"Convenience/MaterialModelsBase/","page":"Mechanical materials","title":"Mechanical materials","text":"FerriteAssembly.element_routine!(Ke, re, state::Vector{<:MMB.AbstractMaterialState}, ae, material::MMB.AbstractMaterial, cellvalues::CellVectorValues, buffer)\nFerriteAssembly.element_residual!(re, state::Vector{<:MMB.AbstractMaterialState}, ae, material::MMB.AbstractMaterial, cellvalues::CellVectorValues, buffer)\nFerriteAssembly.create_cell_state(m::MMB.AbstractMaterial, cv::CellVectorValues, args...)\nFerriteAssembly.allocate_cell_cache(m::MMB.AbstractMaterial, ::Any)","category":"page"},{"location":"Convenience/MaterialModelsBase/#FerriteAssembly.element_routine!-Tuple{Any, Any, Vector{<:MaterialModelsBase.AbstractMaterialState}, Any, MaterialModelsBase.AbstractMaterial, CellVectorValues, Any}","page":"Mechanical materials","title":"FerriteAssembly.element_routine!","text":"FerriteAssembly.element_routine!(\n    Ke, re, state::Vector{<:MMB.AbstractMaterialState}, ae, \n    m::MMB.AbstractMaterial, cv::CellVectorValues, buffer)\n\nSolve the weak form \n\n   int_Omega boldsymboldelta uotimesnabla^mathrmsym  boldsymbolsigma mathrmdOmega \n   = int_Gamma boldsymboldelta u cdot boldsymbolt mathrmdGamma \n   + int_Omega boldsymboldelta u cdot boldsymbolb mathrmdOmega\n\nwhere sigma is calculated with the material_response function from  MaterialModelsBase.jl.  Note that create_cell_state is already implemented for <:AbstractMaterial. \n\n\n\n\n\n","category":"method"},{"location":"Convenience/MaterialModelsBase/#FerriteAssembly.element_residual!-Tuple{Any, Vector{<:MaterialModelsBase.AbstractMaterialState}, Any, MaterialModelsBase.AbstractMaterial, CellVectorValues, Any}","page":"Mechanical materials","title":"FerriteAssembly.element_residual!","text":"FerriteAssembly.element_residual!(\n    re, state::Vector{<:MMB.AbstractMaterialState}, ae, \n    m::MMB.AbstractMaterial, cv::CellVectorValues, buffer)\n\nThe element_residual! implementation corresponding to the element_routine! implementation for a MaterialModelsBase.AbstractMaterial\n\n\n\n\n\n","category":"method"},{"location":"Convenience/MaterialModelsBase/#FerriteAssembly.create_cell_state-Tuple{MaterialModelsBase.AbstractMaterial, CellVectorValues, Vararg{Any}}","page":"Mechanical materials","title":"FerriteAssembly.create_cell_state","text":"FerriteAssembly.create_cell_state(m::MMB.AbstractMaterial, cv::CellVectorValues, args...)\n\nCreate a Vector{<:MMM.AbstractMaterialState} where each element is the output from  MMB.initial_material_state(m) and the length is the number of quadrature points in cv.\n\n\n\n\n\n","category":"method"},{"location":"Convenience/MaterialModelsBase/#FerriteAssembly.allocate_cell_cache-Tuple{MaterialModelsBase.AbstractMaterial, Any}","page":"Mechanical materials","title":"FerriteAssembly.allocate_cell_cache","text":"FerriteAssembly.allocate_cell_cache(m::MMB.AbstractMaterial, ::Any)\n\nCreate the material cache defined by the MMB.get_cache(m) function.\n\n\n\n\n\n","category":"method"},{"location":"DomainBuffers/StateVariables/#State-variables","page":"State variables","title":"State variables","text":"","category":"section"},{"location":"DomainBuffers/StateVariables/","page":"State variables","title":"State variables","text":"The state variable for a given cell is determined by the material type, via  overloading the create_cell_state function. To update old states to the new states, use update_states!.","category":"page"},{"location":"DomainBuffers/StateVariables/#The-state-variable-datastructure","page":"State variables","title":"The state variable datastructure","text":"","category":"section"},{"location":"DomainBuffers/StateVariables/","page":"State variables","title":"State variables","text":"The state variables are created when calling setup_domainbuffer or setup_domainbuffers, and stored inside the buffers.  The states for a given domain are accessed with  get_state  and  get_old_state,  where the state for a particular cell is indexed by its cell number. (The output from the mentioned functions are Dict{Int})","category":"page"},{"location":"DomainBuffers/StateVariables/#API","page":"State variables","title":"API","text":"","category":"section"},{"location":"DomainBuffers/StateVariables/","page":"State variables","title":"State variables","text":"FerriteAssembly.create_cell_state\nupdate_states!","category":"page"},{"location":"DomainBuffers/StateVariables/#FerriteAssembly.create_cell_state","page":"State variables","title":"FerriteAssembly.create_cell_state","text":"create_cell_state(material, cellvalues, x, ae, dofrange)\n\nDefaults to returning nothing.\n\nOverload this function to create the state which should be passed into the  element_routine!/element_residual! for the given material and cellvalues.  x is the cell's coordinates, ae the element degree of freedom values, and  dofrange::NamedTuple containing the local dof range for each field.  As for the element routines, ae, is filled with NaN unless the global degree  of freedom vector is given to the setup_domainbuffer function.\n\n\n\n\n\nFerriteAssembly.create_cell_state(m::MMB.AbstractMaterial, cv::CellVectorValues, args...)\n\nCreate a Vector{<:MMM.AbstractMaterialState} where each element is the output from  MMB.initial_material_state(m) and the length is the number of quadrature points in cv.\n\n\n\n\n\n","category":"function"},{"location":"DomainBuffers/StateVariables/#FerriteAssembly.update_states!","page":"State variables","title":"FerriteAssembly.update_states!","text":"update_states!(old_states, states)\n\nIn most cases, this 2-argument function is not required, and the  entire domain buffer can be passed instead, see update_states!. This 2-argument function will then be called for the stored state variables. \n\n\n\n\n\nupdate_states!(db::Dict{String,AbstractDomainBuffer})\nupdate_states!(db::AbstractDomainBuffer)\n\nUpdate the states such that old_states = states for the states  stored in db.\n\nThis method tries to avoid allocating new values where possible.  Currently, if create_cell_state returns T or Vector{T} where isbitstype(T), this works. If needed/wanted, it should be relatively easy to provide an interface to make it possible to have allocation free  for custom cell states.\n\n\n\n\n\n","category":"function"},{"location":"Customization/","page":"Customizations","title":"Customizations","text":"CurrentModule = FerriteAssembly","category":"page"},{"location":"Customization/#Customizations","page":"Customizations","title":"Customizations","text":"","category":"section"},{"location":"Customization/","page":"Customizations","title":"Customizations","text":"The functions described on this page are somewhere inbetween regular API and internal API, and are intended for making custom solutions, but with a higher risk of breaking changes.","category":"page"},{"location":"Customization/#Modify-the-material","page":"Customizations","title":"Modify the material","text":"","category":"section"},{"location":"Customization/","page":"Customizations","title":"Customizations","text":"Some advanced or experimental features are documented here, these are typically used in research settings. Their API may be less stable than other parts of the library.","category":"page"},{"location":"Customization/","page":"Customizations","title":"Customizations","text":"FerriteAssembly.unwrap_material_for_ad","category":"page"},{"location":"Customization/#FerriteAssembly.unwrap_material_for_ad","page":"Customizations","title":"FerriteAssembly.unwrap_material_for_ad","text":"unwrap_material_for_ad(m)\n\nExperimental feature:  Unwrap a material that has been wrapped in another struct before using  for automatic differentiation. This function is called when setting up  the AutoDiffCellBuffer's ForwardDiff.JacobianConfig, and all calls to  element_routine_ad! should use the unwrapped material from the cellbuffer.\n\nThis feature is used to customize the behavior of a material, by performing  additional calculations before or after the regular element routine.  One example is to modify the stiffness, for example\n\nstruct ModifiedStiffness{M,T}\n    material::M\n    factor::T\nend\nfunction FerriteAssembly.unwrap_material_for_ad(m::ModifiedStiffness)\n    return FerriteAssembly.unwrap_material_for_ad(m.material)\nend\nfunction FerriteAssembly.element_routine!(Ke, re, state, ae, m::ModifiedStiffness, args...)\n    FerriteAssembly.element_routine!(Ke, re, state, ae, m.material, args...)\n    Ke .+= LinearAlgebra.I*m.factor # Add m.factor to Ke's diagonal\nend\n\nDefining unwrap_material_for_ad is then necessary if both the following holds\n\nelement_routine! is not implemented for m.material, but automatic differentiation is used. \nAutoDiffCellBuffer is used to speed up the automatic differentiation\n\nPlease note that\n\nThe material is not unwrapped automatically when calling element_routine_ad!.  This behavior avoids user defining unwrap_material_for_ad for their wrapper, and  then unintentionally unwrap before reaching the element_residual call. \nTo support wrapped wrappers, overload as  unwrap_material_for_ad(m::MyWrapper) = unwrap_material_for_ad(m.material)\n\n\n\n\n\n","category":"function"},{"location":"Customization/#TaskLocals-API-(task-local-storage)","page":"Customizations","title":"TaskLocals API (task local storage)","text":"","category":"section"},{"location":"Customization/","page":"Customizations","title":"Customizations","text":"During multithreaded assembly, each task needs its own storage with values that it can change. This can be both cache variables (whose values don't matter after the task completes) or  other values that are part of the result from the assembly procedure. To do this in a structured way, the TaskLocals type and associated interface is used for all these cases in the package, but the user should never \"see\" this type directly (but it can be embedded in types seen by the user, such as ThreadedDomainBuffer). Specifically, a so-called scatter-gather approach is emulated,  even though the memory is shared, allowing this to be simplified. ","category":"page"},{"location":"Customization/","page":"Customizations","title":"Customizations","text":"FerriteAssembly.TaskLocals\nFerriteAssembly.create_local\nFerriteAssembly.scatter!\nFerriteAssembly.gather!\nFerriteAssembly.get_local\nFerriteAssembly.get_locals\nFerriteAssembly.get_base","category":"page"},{"location":"Customization/#FerriteAssembly.TaskLocals","page":"Customizations","title":"FerriteAssembly.TaskLocals","text":"TaskLocals(base; num_tasks=Threads.nthreads())\n\nTaskLocals is used to store a base value and a vector, locals.  Items in locals are for each task and can be obtained with get_local. base can be obtained with get_base.\n\nA base-type that supports the TaskLocals API should define the following functions\n\ncreate_local\nscatter!(local, base)\ngather!(base, local)\n\n\n\n\n\n","category":"type"},{"location":"Customization/#FerriteAssembly.create_local","page":"Customizations","title":"FerriteAssembly.create_local","text":"create_local(base::TB)\n\nCreate a task local variable, local::TL. In many cases, TL=TB. local's state should match that after calling gather!(base, local)  (reset local) followed by scatter!(local, base) (add info from base) (This is important, because it allows create_local to be called while working with  tasks, if more locals are needed)\n\n\n\n\n\n","category":"function"},{"location":"Customization/#FerriteAssembly.scatter!","page":"Customizations","title":"FerriteAssembly.scatter!","text":"scatter!(local, base)\n\nWrite any information from base required to be forwarded to  the local::typeof(create_local(base)). (typically if something in base have changed since its creation)\n\n\n\n\n\n","category":"function"},{"location":"Customization/#FerriteAssembly.gather!","page":"Customizations","title":"FerriteAssembly.gather!","text":"gather!(base, local)\n\nTake any information from local::typeof(create_local(base)) that should  be added to base after an assembly.  In addition, any accumulative information in local should  be reset, such that running scatter! -> \"do work\" -> gather! should  only affect the values in base. \n\n\n\n\n\n","category":"function"},{"location":"Customization/#FerriteAssembly.get_local","page":"Customizations","title":"FerriteAssembly.get_local","text":"get_local(tl::TaskLocals, i::Int)\n\nGet the ith local variable from tl\n\n\n\n\n\n","category":"function"},{"location":"Customization/#FerriteAssembly.get_locals","page":"Customizations","title":"FerriteAssembly.get_locals","text":"get_locals(tl::TaskLocals)\n\nGet the vector of locals in tl\n\n\n\n\n\n","category":"function"},{"location":"Customization/#FerriteAssembly.get_base","page":"Customizations","title":"FerriteAssembly.get_base","text":"get_base(tl::TaskLocals)\nget_base(x::Any)\n\nGet the base variable from tl, or,  for an x that is not a TaskLocals, return itself\n\n\n\n\n\n","category":"function"},{"location":"Customization/#Assembler-interface","page":"Customizations","title":"Assembler interface","text":"","category":"section"},{"location":"Customization/","page":"Customizations","title":"Customizations","text":"Different types of assemblers can be created in addition to those already defined by the package. The interface for creating an assembler is that the assembler must support the TaskLocals API,  as well as the methods,","category":"page"},{"location":"Customization/","page":"Customizations","title":"Customizations","text":"FerriteAssembly.work_single_cell!(assembler, buffer::AbstractCellBuffer)\nFerriteAssembly.work_single_face!(assembler, buffer::FaceBuffer)","category":"page"},{"location":"Customization/","page":"Customizations","title":"Customizations","text":"The internal methods for builtin assemblers can be used as examples.","category":"page"},{"location":"Customization/","page":"Customizations","title":"Customizations","text":"In addition, the following functions are used to determine properties/requirements for the assembler. ","category":"page"},{"location":"Customization/","page":"Customizations","title":"Customizations","text":"can_thread(assembler)::Bool: Is multithreading supported, if false, sequential assembly will run even if the a ThreadedDomainBuffer is used. If not defined, defaults to false. \nskip_this_domain(assembler, name::String)::Bool: When running multiple domains, should the domain with key name be skipped? Defaults to false. ","category":"page"},{"location":"Customization/#Custom-scaling","page":"Customizations","title":"Custom scaling","text":"","category":"section"},{"location":"Customization/","page":"Customizations","title":"Customizations","text":"In general, a scaling must, in addition to the TaskLocals API,  support the following functions","category":"page"},{"location":"Customization/","page":"Customizations","title":"Customizations","text":"FerriteAssembly.update_scaling!\nFerriteAssembly.reset_scaling!","category":"page"},{"location":"Customization/#FerriteAssembly.update_scaling!","page":"Customizations","title":"FerriteAssembly.update_scaling!","text":"update_scaling!(scaling, re, cellbuffer)\n\nThis function should add the contribution from the element residual vector re to the scaling factors in scaling.\n\n\n\n\n\n","category":"function"},{"location":"Customization/#FerriteAssembly.reset_scaling!","page":"Customizations","title":"FerriteAssembly.reset_scaling!","text":"reset_scaling!(scaling)\n\nThis function should reset the scaling factors, such that the values don't accumulate if used  in multiple iterations/time steps. \n\n\n\n\n\n","category":"function"},{"location":"Workers/Workers/#Workers","page":"Workers","title":"Workers","text":"","category":"section"},{"location":"Workers/Workers/","page":"Workers","title":"Workers","text":"There are currently two categories of workers implemented:","category":"page"},{"location":"Workers/Workers/","page":"Workers","title":"Workers","text":"Assemblers: Calculate system matrices and vectors \nIntegrators: Integrate a function over the domain","category":"page"},{"location":"Workers/Workers/#Perform-the-work","page":"Workers","title":"Perform the work","text":"","category":"section"},{"location":"Workers/Workers/","page":"Workers","title":"Workers","text":"Having setup a DomainBuffer and a worker, work is performed by calling the function work!","category":"page"},{"location":"Workers/Workers/","page":"Workers","title":"Workers","text":"work!","category":"page"},{"location":"Workers/Workers/#FerriteAssembly.work!","page":"Workers","title":"FerriteAssembly.work!","text":"work!(worker, buffer; a=nothing, aold=nothing)\n\nPerform the work according to worker over the domain(s) specificed by  buffer. Current, a, and old, aold, global degree of freedom vectors  are passed to get these values passed into the innermost user-defined functions. If not passed (or as nothing), NaN values are passed into the innermost functions. \n\n\n\n\n\n","category":"function"},{"location":"Workers/Workers/","page":"Workers","title":"Workers","text":"A worker needs to define what to do for different domains,  specifically it needs to define  work_single_cell! and work_single_face!. Further details  about writing custom workers can be found in the  Customizations section.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"EditURL = \"../literate_tutorials/heat_equation.jl\"","category":"page"},{"location":"tutorials/heat_equation/#Heat-Equation","page":"Heat Equation","title":"Heat Equation","text":"","category":"section"},{"location":"tutorials/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"This tutorial solves the stationary heat flow example, equivalent to the first example in Ferrite.jl.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"The full script without intermediate comments is available at the bottom of this page.","category":"page"},{"location":"tutorials/heat_equation/#Setup","page":"Heat Equation","title":"Setup","text":"","category":"section"},{"location":"tutorials/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"First we create the dofhandler, vectors and matrices, and cellvalues as in Ferrite.jl's heat equation example","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"using Ferrite, FerriteAssembly\ngrid = generate_grid(Quadrilateral, (20, 20))\ndh = DofHandler(grid); add!(dh, :u, 1); close!(dh)\ncellvalues = CellScalarValues(QuadratureRule{2, RefCube}(2), Lagrange{2, RefCube, 1}());\nK = create_sparsity_pattern(dh)\nr = zeros(ndofs(dh));\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/#Define-the-physics","page":"Heat Equation","title":"Define the physics","text":"","category":"section"},{"location":"tutorials/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"We start by defining the material and create an instance of it","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"struct ThermalMaterial\n    k::Float64 # Thermal conductivity\n    f::Float64 # Volumetric heat source\nend\nmaterial = ThermalMaterial(1.0, 1.0);\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"and then define our element_routine! for that material as","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"function FerriteAssembly.element_routine!(Ke, re, state, ae,\n        material::ThermalMaterial, cellvalues, cellbuffer\n        )\n    n_basefuncs = getnbasefunctions(cellvalues)\n    # Loop over quadrature points\n    for q_point in 1:getnquadpoints(cellvalues)\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:n_basefuncs\n            δN  = shape_value(cellvalues, q_point, i)\n            ∇δN = shape_gradient(cellvalues, q_point, i)\n            # Add body load contribution to re\n            re[i] += -material.f*δN * dΩ\n            # Loop over trial shape functions\n            for j in 1:n_basefuncs\n                ∇N = shape_gradient(cellvalues, q_point, j)\n                # Add contribution to Ke\n                Ke[i, j] += material.k*(∇δN ⋅ ∇N) * dΩ\n            end\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"which is basically the same as in Ferrite.jl's example.","category":"page"},{"location":"tutorials/heat_equation/#Assemble","page":"Heat Equation","title":"Assemble","text":"","category":"section"},{"location":"tutorials/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"We first start by defining a domain and passing that to the setup_domainbuffer function.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"grid_domain = DomainSpec(dh, material, cellvalues)\nbuffer = setup_domainbuffer(grid_domain);\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"The worker in this case is the standard Ferrite assembler:","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"assembler = start_assemble(K, r);\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Given this worker, we can do the work to assemble K and r","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"work!(assembler, buffer);\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/#Solve-the-problem.","page":"Heat Equation","title":"Solve the problem.","text":"","category":"section"},{"location":"tutorials/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"To actually solve the problem, we also need Dirichlet boundary conditions.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"ch = ConstraintHandler(dh)\nfaceset = union((getfaceset(grid,k) for k in (\"left\", \"right\", \"bottom\", \"top\"))...)\nadd!(ch, Dirichlet(:u, faceset, Returns(0.0)))\nclose!(ch);\napply_zero!(K, r, ch)","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"where we use apply_zero! since we assembled assuming a zero temperature. We could have used apply!(K,f,ch), but for non-zero dirichlet conditions, this relies on the correct sign for external loads, and we have r=-f.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Finally, we can solve the problem and save the results","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"a = -K\\r\nvtk_grid(\"heat_equation\", grid) do vtk\n    vtk_point_data(vtk, dh, a)\nend;\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/#heat_equation_plain_program","page":"Heat Equation","title":"Plain program","text":"","category":"section"},{"location":"tutorials/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"Here follows a version of the program without any comments. The file is also available here: heat_equation.jl.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"using Ferrite, FerriteAssembly\ngrid = generate_grid(Quadrilateral, (20, 20))\ndh = DofHandler(grid); add!(dh, :u, 1); close!(dh)\ncellvalues = CellScalarValues(QuadratureRule{2, RefCube}(2), Lagrange{2, RefCube, 1}());\nK = create_sparsity_pattern(dh)\nr = zeros(ndofs(dh));\n\nstruct ThermalMaterial\n    k::Float64 # Thermal conductivity\n    f::Float64 # Volumetric heat source\nend\nmaterial = ThermalMaterial(1.0, 1.0);\n\nfunction FerriteAssembly.element_routine!(Ke, re, state, ae,\n        material::ThermalMaterial, cellvalues, cellbuffer\n        )\n    n_basefuncs = getnbasefunctions(cellvalues)\n    # Loop over quadrature points\n    for q_point in 1:getnquadpoints(cellvalues)\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:n_basefuncs\n            δN  = shape_value(cellvalues, q_point, i)\n            ∇δN = shape_gradient(cellvalues, q_point, i)\n            # Add body load contribution to re\n            re[i] += -material.f*δN * dΩ\n            # Loop over trial shape functions\n            for j in 1:n_basefuncs\n                ∇N = shape_gradient(cellvalues, q_point, j)\n                # Add contribution to Ke\n                Ke[i, j] += material.k*(∇δN ⋅ ∇N) * dΩ\n            end\n        end\n    end\nend;\n\ngrid_domain = DomainSpec(dh, material, cellvalues)\nbuffer = setup_domainbuffer(grid_domain);\n\nassembler = start_assemble(K, r);\n\nwork!(assembler, buffer);\n\nch = ConstraintHandler(dh)\nfaceset = union((getfaceset(grid,k) for k in (\"left\", \"right\", \"bottom\", \"top\"))...)\nadd!(ch, Dirichlet(:u, faceset, Returns(0.0)))\nclose!(ch);\napply_zero!(K, r, ch)\n\na = -K\\r\nvtk_grid(\"heat_equation\", grid) do vtk\n    vtk_point_data(vtk, dh, a)\nend;\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat Equation","title":"Heat Equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"DomainBuffers/Setup/","page":"DomainBuffers","title":"DomainBuffers","text":"CurrentModule = FerriteAssembly","category":"page"},{"location":"DomainBuffers/Setup/#Setup-API","page":"DomainBuffers","title":"Setup API","text":"","category":"section"},{"location":"DomainBuffers/Setup/","page":"DomainBuffers","title":"DomainBuffers","text":"DomainSpec\nsetup_domainbuffer\nsetup_domainbuffers","category":"page"},{"location":"DomainBuffers/Setup/#FerriteAssembly.DomainSpec","page":"DomainBuffers","title":"FerriteAssembly.DomainSpec","text":"DomainSpec(sdh::SubDofHandler, material, fe_values; set=getcellset(sdh), colors_or_chunks=nothing, user_data=nothing)\nDomainSpec(dh::DofHandler, material, fe_values; set=1:getncells(dh), colors=nothing, chunks=nothing, user_data=nothing)\n\nCreate a DomainSpec that can be used to set up a domain buffer. \n\nsdh/dh: Give the DofHandler for the domain in question, or a SubDofHandler in case there are more than one in DofHandler  (See Ferrite.jl's documentation)\nmaterial: Used for dispatch on the utilized worker's function. \nfe_values: CellValues or FaceValues depending on the type of domain. \nset: The items in the domain, the element type determines the type of domain \nCell domain: Int\nFace domain: FaceIndex\ncolors::Vector{Vector{I}}: used to avoid race conditions when multithreading.  For cell domains, I=Int, and for face domains, I can be either Int  (denoting cell numbers) or FaceIndex for actual faces. If I=Int, it will be  converted to FaceIndex internally. If colors=nothing and chunks=nothing,  Ferrite.jl's default coloring algorithm is used.\nchunks::Vector{Vector{Vector{I}}}. During multithreading, each task works with  items in one chunk::Vector{I} at a time. Items in chunks[k][i] and chunks[k][j] should be independent (i.e. not share dofs). If given, this input takes precidence over  colors. For chunks, I must be Int for cell domains and FaceIndex for face domains. \nuser_data: Can be whatever the user wants to and is passed along by reference everywhere.  It is accessible from the ItemBuffer (e.g. CellBuffer) given to the worker's function via the get_user_data function. However, since it is passed by reference, modifying values  during work, care must be taken to ensure thread safety.  To avoid allocations, caches can be created separately with allocate_cell_cache and  allocate_face_cache.\n\n\n\n\n\n","category":"type"},{"location":"DomainBuffers/Setup/#FerriteAssembly.setup_domainbuffer","page":"DomainBuffers","title":"FerriteAssembly.setup_domainbuffer","text":"setup_domainbuffer(domain::DomainSpec; a=nothing, threading=false, autodiffbuffer=false)\n\nSetup a domain buffer for a single grid domain, domain. \n\na::Vector: The global degree of freedom values are used to pass the  local element dof values to the create_cell_state function,  making it possible to create the initial state dependent on the initial  conditions for the field variables. \nthreading: Should a ThreadedDomainBuffer be created to work the grid multithreaded if supported by the used worker?\nautodiffbuffer: Should a custom itembuffer be used to speed up the automatic  differentiation (if supported by the itembuffer)\n\n\n\n\n\n","category":"function"},{"location":"DomainBuffers/Setup/#FerriteAssembly.setup_domainbuffers","page":"DomainBuffers","title":"FerriteAssembly.setup_domainbuffers","text":"setup_domainbuffers(domains::Dict{String,DomainSpec}; kwargs...)\n\nSetup multiple domain buffers, one for each DomainSpec in domains. See setup_domainbuffer for description of the keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"DomainBuffers/Setup/#AbstractDomainBuffer","page":"DomainBuffers","title":"AbstractDomainBuffer","text":"","category":"section"},{"location":"DomainBuffers/Setup/","page":"DomainBuffers","title":"DomainBuffers","text":"The domain buffer be a DomainBuffer, ThreadedDomainBuffer, or a Dict{String} with eltype  of one of the former. The following functions are defined for these buffers:","category":"page"},{"location":"DomainBuffers/Setup/","page":"DomainBuffers","title":"DomainBuffers","text":"FerriteAssembly.get_material(::FerriteAssembly.DomainBuffers, ::String)\nFerriteAssembly.get_dofhandler(::FerriteAssembly.DomainBuffers)\nFerriteAssembly.get_state(::FerriteAssembly.DomainBuffers, ::String)\nFerriteAssembly.get_old_state(::FerriteAssembly.DomainBuffers, ::String)\nFerriteAssembly.getset\nupdate_states!(::FerriteAssembly.DomainBuffers)\nset_time_increment!(::FerriteAssembly.DomainBuffers, ::Any)","category":"page"},{"location":"DomainBuffers/Setup/#FerriteAssembly.get_material-Tuple{Dict{String, <:FerriteAssembly.AbstractDomainBuffer}, String}","page":"DomainBuffers","title":"FerriteAssembly.get_material","text":"get_material(dbs::Dict{String,AbstractDomainBuffer}, domain::String)\nget_material(db::AbstractDomainBuffer)\n\nGet the material for the domain represented by db or dbs[domain].\n\n\n\n\n\n","category":"method"},{"location":"DomainBuffers/Setup/#FerriteAssembly.get_dofhandler-Tuple{Dict{String, <:FerriteAssembly.AbstractDomainBuffer}}","page":"DomainBuffers","title":"FerriteAssembly.get_dofhandler","text":"get_dofhandler(dbs::Dict{String,AbstractDomainBuffer})\nget_dofhandler(db::AbstractDomainBuffer)\n\nGet the dofhandler stored in db. Note that this is the global dofhandler, and not the SubDofHandler that is local to a specific domain.\n\n\n\n\n\n","category":"method"},{"location":"DomainBuffers/Setup/#FerriteAssembly.get_state-Tuple{Dict{String, <:FerriteAssembly.AbstractDomainBuffer}, String}","page":"DomainBuffers","title":"FerriteAssembly.get_state","text":"get_state(dbs::Dict{String,AbstractDomainBuffer}, domain::String)\nget_state(db::AbstractDomainBuffer)\n\nGet the states::Dict{Int,S}, where S type of the state for each entity in the domain, stored in the db or dbs[domain].\n\n\n\n\n\n","category":"method"},{"location":"DomainBuffers/Setup/#FerriteAssembly.get_old_state-Tuple{Dict{String, <:FerriteAssembly.AbstractDomainBuffer}, String}","page":"DomainBuffers","title":"FerriteAssembly.get_old_state","text":"get_old_state(dbs::Dict{String,AbstractDomainBuffer}, domain::String)\nget_old_state(db::AbstractDomainBuffer)\n\nGet the states::Dict{Int,S}, where S type of the state for each entity in the domain, stored in the db or dbs[domain].\n\n\n\n\n\n","category":"method"},{"location":"DomainBuffers/Setup/#FerriteAssembly.getset","page":"DomainBuffers","title":"FerriteAssembly.getset","text":"getset(dbs::Dict{String,AbstractDomainBuffer}, domain::String)\ngetset(db::AbstractDomainBuffer)\n\nGet the set of items stored in db or dbs[domain]\n\n\n\n\n\n","category":"function"},{"location":"DomainBuffers/Setup/#FerriteAssembly.update_states!-Tuple{Dict{String, <:FerriteAssembly.AbstractDomainBuffer}}","page":"DomainBuffers","title":"FerriteAssembly.update_states!","text":"update_states!(db::Dict{String,AbstractDomainBuffer})\nupdate_states!(db::AbstractDomainBuffer)\n\nUpdate the states such that old_states = states for the states  stored in db.\n\nThis method tries to avoid allocating new values where possible.  Currently, if create_cell_state returns T or Vector{T} where isbitstype(T), this works. If needed/wanted, it should be relatively easy to provide an interface to make it possible to have allocation free  for custom cell states.\n\n\n\n\n\n","category":"method"},{"location":"DomainBuffers/Setup/#FerriteAssembly.set_time_increment!-Tuple{Dict{String, <:FerriteAssembly.AbstractDomainBuffer}, Any}","page":"DomainBuffers","title":"FerriteAssembly.set_time_increment!","text":"set_time_increment!(db::Dict{String,AbstractDomainBuffer}, Δt)\nset_time_increment!(db::AbstractDomainBuffer, Δt)\n\nUpdate the time increment stored in db, which is passed on to the  stored AbstractItemBuffer\n\n\n\n\n\n","category":"method"},{"location":"Workers/Assemblers/#Assemblers","page":"Assemblers","title":"Assemblers","text":"","category":"section"},{"location":"Workers/Assemblers/","page":"Assemblers","title":"Assemblers","text":"Assemblers are used to assemble the system matrices and residual vectors. To calculate the contribution to these matrices, one or more of the following functions should be overloaded for the specific material:","category":"page"},{"location":"Workers/Assemblers/","page":"Assemblers","title":"Assemblers","text":"element_routine!\nelement_residual!\nface_residual!\nface_routine!","category":"page"},{"location":"Workers/Assemblers/#Available-assemblers","page":"Assemblers","title":"Available assemblers","text":"","category":"section"},{"location":"Workers/Assemblers/","page":"Assemblers","title":"Assemblers","text":"The following assemblers can be used to assemble the system matrix and vector:","category":"page"},{"location":"Workers/Assemblers/","page":"Assemblers","title":"Assemblers","text":"Ferrite.start_assemble (AssemblerSparsityPattern or AssemblerSymmetricSparsityPattern)\nKeReAssembler\nReAssembler","category":"page"},{"location":"Workers/Assemblers/#Ferrite-assemblers","page":"Assemblers","title":"Ferrite assemblers","text":"","category":"section"},{"location":"Workers/Assemblers/","page":"Assemblers","title":"Assemblers","text":"Ferrite assemblers are supported and are used to assemble both a matrix and a vector. They are created by calling Ferrite's start_assemble function. They will primarily call element_routine! or face_routine!.  However, if not defined for the given material, automatic differentiation will be used to get the matrix contribution by calling element_residual! or face_residual! instead.","category":"page"},{"location":"Workers/Assemblers/#ReAssembler","page":"Assemblers","title":"ReAssembler","text":"","category":"section"},{"location":"Workers/Assemblers/","page":"Assemblers","title":"Assemblers","text":"The ReAssembler assembles only the residual vector, and will thus call element_residual! or face_residual!.","category":"page"},{"location":"Workers/Assemblers/","page":"Assemblers","title":"Assemblers","text":"ReAssembler","category":"page"},{"location":"Workers/Assemblers/#FerriteAssembly.ReAssembler","page":"Assemblers","title":"FerriteAssembly.ReAssembler","text":"ReAssembler(r; fillzero=true, scaling=NoScaling())\n\nReAssembler will call element_residual! and assemble re into the system  vector r. fillzero=true implies that r is zeroed upon construction of  ReAssembler. Furthermore, remaining keyword arguments can enable the following  features:\n\nscaling: Calculate a scaling measure locally at the residual level, see e.g.,  ElementResidualScaling. \n\nreset_scaling! is called when creating ReAssembler\n\n\n\n\n\n","category":"type"},{"location":"Workers/Assemblers/#KeReAssembler","page":"Assemblers","title":"KeReAssembler","text":"","category":"section"},{"location":"Workers/Assemblers/","page":"Assemblers","title":"Assemblers","text":"The KeReAssembler assembles both the residual vector and the system matrix, similar to Ferrite's assemblers. It will also primarily call element_routine! or face_routine! and fall back to automatic differentiation of element_residual! and face_residual! if the former methods are not defined. ","category":"page"},{"location":"Workers/Assemblers/","page":"Assemblers","title":"Assemblers","text":"KeReAssembler","category":"page"},{"location":"Workers/Assemblers/#FerriteAssembly.KeReAssembler","page":"Assemblers","title":"FerriteAssembly.KeReAssembler","text":"KeReAssembler(K, r; fillzero=true, kwargs...)\nKeReAssembler(a::Ferrite.AbstractSparseAssembler; kwargs...)\n\nThe default KeReAssembler works just like a Ferrite.AbstractSparseAssembler: It will call element_routine! and assemble Ke and re into the global system  matrix K and vector r. However, it comes with the additional possible features, that are controllable via the keyword arguments:\n\nch::Union{Nothing,ConstraintHandler}=nothing: If a ConstraintHandler is given, local applications of constraints will be applied, using Ferrite.apply_assemble.\napply_zero: Required if a constraint handler is given, and forwarded to Ferrite.apply_assemble. \nscaling: Calculate a scaling measure locally at the residual level, see e.g.,  ElementResidualScaling\n\na=Ferrite.start_assemble(K, r; fillzero=fillzero) is passed to the second definition  if a matrix, K, and vector, r, are given as input.\n\nreset_scaling! is called when creating KeReAssembler\n\n\n\n\n\n","category":"type"},{"location":"Workers/Assemblers/#Functions-to-overload","page":"Assemblers","title":"Functions to overload","text":"","category":"section"},{"location":"Workers/Assemblers/","page":"Assemblers","title":"Assemblers","text":"FerriteAssembly.element_routine!\nFerriteAssembly.element_residual!\nFerriteAssembly.face_routine!\nFerriteAssembly.face_residual!","category":"page"},{"location":"Workers/Assemblers/#FerriteAssembly.element_routine!","page":"Assemblers","title":"FerriteAssembly.element_routine!","text":"element_routine!(\n    Ke::AbstractMatrix, re::AbstractVector, state,\n    ae::AbstractVector, material, cellvalues, buffer)\n\nThe main function to be overloaded for the specific material. In most cases, the same implementation can be used for different cellvalues  (e.g. for different interpolation orders) This function should modify the element stiffness matrix Ke, the residual re, and potentially state. The element degree of freedom values, ae, are filled by  NaNs unless a is passed to work!.\n\nThe following variables can be obtained from buffer.\n\nget_old_state(buffer)\nget_aeold(buffer)\nget_time_increment(buffer)\ndof_range(buffer, fieldname::Symbol)\ngetcoordinates(buffer)\ncelldofs(buffer)\ncellid(buffer)\nget_user_data(buffer)\nget_user_cache(buffer)\n\n\n\n\n\nFerriteAssembly.element_routine!(\n    Ke, re, state::Vector{<:MMB.AbstractMaterialState}, ae, \n    m::MMB.AbstractMaterial, cv::CellVectorValues, buffer)\n\nSolve the weak form \n\n   int_Omega boldsymboldelta uotimesnabla^mathrmsym  boldsymbolsigma mathrmdOmega \n   = int_Gamma boldsymboldelta u cdot boldsymbolt mathrmdGamma \n   + int_Omega boldsymboldelta u cdot boldsymbolb mathrmdOmega\n\nwhere sigma is calculated with the material_response function from  MaterialModelsBase.jl.  Note that create_cell_state is already implemented for <:AbstractMaterial. \n\n\n\n\n\n","category":"function"},{"location":"Workers/Assemblers/#FerriteAssembly.element_residual!","page":"Assemblers","title":"FerriteAssembly.element_residual!","text":"element_residual!(\n    re::AbstractVector, state,\n    ae::AbstractVector, material, cellvalues, buffer)\n\nTo calculate the element tangent stiffness Ke automatically by using ForwardDiff, it is possible to overload element_residual! instead of element_routine!. See  element_routine! for a description of the input parameters. \n\nnote: Note\nMethodError with ForwardDiff.Dual\nWhen using automatic differentiation for elements with state variables (or other mutating values in e.g. cache), an error will be thrown if trying to change the type in many cases.  When mutating state, call ForwardDiff.value() on the value to be assigned after  it will no longer be used to calculate re. (If done on a value which is later affects re inside the element, the tangent, Ke, will be wrong.)\n\n\n\n\n\n","category":"function"},{"location":"Workers/Assemblers/#FerriteAssembly.face_routine!","page":"Assemblers","title":"FerriteAssembly.face_routine!","text":"face_routine!(Ke, re, ae, material, facevalues, facebuffer)\n\nCalculate contributions to the stiffness matrix and residual vector from a  face domain. It can be used, for example, to implement Robin boundary conditions.\n\n\n\n\n\n","category":"function"},{"location":"Workers/Assemblers/#FerriteAssembly.face_residual!","page":"Assemblers","title":"FerriteAssembly.face_residual!","text":"face_residual!(re, ae, material, facevalues, facebuffer)\n\nCalculate contributions to the residual vector from a face domain.  Internally, this is used for calculating Neumann boundary conditions. \n\n\n\n\n\n","category":"function"},{"location":"Workers/Assemblers/#Residual-scaling","page":"Assemblers","title":"Residual scaling","text":"","category":"section"},{"location":"Workers/Assemblers/","page":"Assemblers","title":"Assemblers","text":"There are many options for how to scale the residual in finite element simulations. This package does not intend to implement many different options, but does give the  user the option to calculate scaling contributions from each cell, which may be useful. By defining a scaling that is passed to KeReAssembler or ReAssembler, it can be updated based on the output from each cell. ","category":"page"},{"location":"Workers/Assemblers/","page":"Assemblers","title":"Assemblers","text":"One type of scaling, ElementResidualScaling, is included as described below. Its code can be used as a template for how to include custom scaling that works on the element level.","category":"page"},{"location":"Workers/Assemblers/#ElementResidualScaling","page":"Assemblers","title":"ElementResidualScaling","text":"","category":"section"},{"location":"Workers/Assemblers/","page":"Assemblers","title":"Assemblers","text":"ElementResidualScaling","category":"page"},{"location":"Workers/Assemblers/#FerriteAssembly.ElementResidualScaling","page":"Assemblers","title":"FerriteAssembly.ElementResidualScaling","text":"ElementResidualScaling(dh::AbstractDofHandler, p=Val(2), T=Float64)\n\nCreate tolerance scaling based on the sum of the p-norm of each cell's residual vector,  separately for each field. I.e. pseudo-code for field :u the scaling factor::T is\n\nfor each cell\n    element_routine!(Ke, re, args...) # Calculate re\n    factor += sum(abs.(re[dof_range(dh, :u)]).^p)^(1/p)\n\nNote that p=Val(2) is a special case that is supported, for different values  it should be given as a Real. p=2 is equivalent to Val(2), but is less efficient. \n\n\n\n\n\n","category":"type"},{"location":"internals/#Internal-API","page":"Internals","title":"Internal API","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Note that the internal API may change without being considered a breaking change!","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"FerriteAssembly.reinit_buffer!\nFerriteAssembly.create_states\nFerriteAssembly._copydofs!\nFerriteAssembly._create_cell_state\nFerriteAssembly.CellBuffer\nFerriteAssembly.AutoDiffCellBuffer\nFerriteAssembly.FaceBuffer\nFerriteAssembly.get_itembuffer\nFerriteAssembly.skip_this_domain\nFerriteAssembly.can_thread\nFerriteAssembly.fast_getindex\nFerriteAssembly.work_single_cell!\nFerriteAssembly.work_single_face!\nFerriteAssembly.autogenerate_cellvalues\nFerriteAssembly.autogenerate_facevalues","category":"page"},{"location":"internals/#FerriteAssembly.reinit_buffer!","page":"Internals","title":"FerriteAssembly.reinit_buffer!","text":"reinit_buffer!(cb::CellBuffer, db::AbstractDomainBuffer, cellnum::Int; a=nothing, aold=nothing)\n\nReinitialize the cb::CellBuffer for cell number cellnum. The global degree of freedom vectors a (current) and aold are used to update the cell degree of freedom vectors in c. If the global vectors are instead ::Nothing, the corresponding cell values are set to NaN The element stiffness, cb.Ke, and residual, cb.re, are also zeroed. \n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly.create_states","page":"Internals","title":"FerriteAssembly.create_states","text":"create_states(sdh::SubDofHandler, material, cellvalues, a, cellset, dofrange)\n\nCreate a Dict of states for the cells in cellset, where the user should  define the create_cell_state function for their material (and corresponding cellvalues) dofrange::NamedTuple is passed onto create_cell_state and contains the local dof ranges for each field. \n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly._copydofs!","page":"Internals","title":"FerriteAssembly._copydofs!","text":"_copydofs!(edofs::Vector, gdofs::Vector, inds::Vector{Int})\n\nInternal function for faster copying of global values into the element values.  Equivalent to edofs .= gdofs[inds]\n\n_copydofs!(edofs::Vector, gdofs::Nothing, inds::Vector{Int})\n\nFill edofs with NaN\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly._create_cell_state","page":"Internals","title":"FerriteAssembly._create_cell_state","text":"_create_cell_state(cell, material, cellvalues, a, ae, dofrange, cellnr)\n\nInternal function to reinit and extract the relevant quantities from the  cell::CellCache, reinit cellvalues, update ae from a, and  pass these into the create_cell_state function that the user should specify. \n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly.CellBuffer","page":"Internals","title":"FerriteAssembly.CellBuffer","text":"CellBuffer(\n    numdofs::Int, numnodes::Int, ::Val{sdim}, \n    cellvalues, material, state, dofrange, user_data=nothing) -> CellBuffer\n\nCreate a cell cache for an element with numdofs degrees of freedom and numnodes nodes with dimension sdim. cellvalues are reinit!ed for each cell, and the state is updated to the  old cell state. material will be passed as-is to the element.  The given dofrange::NamedTuple, user_data::Any, and cache::Any are available to the element via the buffer input. \n\nnote: See setup_domainbuffer\nThis constructor is normally not used, and is instead called from setup_domainbuffer\n\n\n\n\n\n","category":"type"},{"location":"internals/#FerriteAssembly.AutoDiffCellBuffer","page":"Internals","title":"FerriteAssembly.AutoDiffCellBuffer","text":"AutoDiffCellBuffer(cb::CellBuffer)\n\n\n\n\n\n","category":"type"},{"location":"internals/#FerriteAssembly.FaceBuffer","page":"Internals","title":"FerriteAssembly.FaceBuffer","text":"FaceBuffer(\n    numdofs::Int, numnodes::Int, ::Val{sdim}, \n    facevalues, material, state, dofrange, user_data=nothing)\n\nCreate a facebuffer for an element with numdofs degrees of freedom and numnodes nodes with dimension sdim. facevalues are reinit!ed for each cell, and the state is updated to the  old cell state. material will be passed as-is to the element.  The given dofrange::NamedTuple, user_data::Any, and cache::Any are available to the element via the buffer input. \n\nnote: See setup_domainbuffer\nThis constructor is normally not used, and is instead called from setup_domainbuffer\n\n\n\n\n\n","category":"type"},{"location":"internals/#FerriteAssembly.get_itembuffer","page":"Internals","title":"FerriteAssembly.get_itembuffer","text":"get_itembuffer(dbs::Dict{String,AbstractDomainBuffer}, domain::String)\nget_itembuffer(db::AbstractDomainBuffer)\n\nGet the AbstractItemBuffer stored in db or dbs[domain].  This internal function might change, but currently the full TaskLocals  is returned for a ThreadedDomainBuffer (used internally). \n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly.skip_this_domain","page":"Internals","title":"FerriteAssembly.skip_this_domain","text":"skip_this_domain(worker, name::String)\n\nShould the domain with key name be skipped during work? Defaults to false. Can be used to e.g. only loop over parts of a domain.\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly.can_thread","page":"Internals","title":"FerriteAssembly.can_thread","text":"can_thread(worker)::Bool\n\nDoes the worker support multithreaded work? Defaults to false.  If this returns true, the worker must support the TaskLocals interface. \n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly.fast_getindex","page":"Internals","title":"FerriteAssembly.fast_getindex","text":"fast_getindex(collection)\n\nIf the output is known from the element type of the collection, this can be returned  directly. Currently, this is implemented for AbstractDict with Nothing as type, which takes away overhead when state variables are not used. \n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly.work_single_cell!","page":"Internals","title":"FerriteAssembly.work_single_cell!","text":"work_single_cell!(worker, cellbuffer)\n\nEach worker that supports a cellbuffer should overload this function.\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly.work_single_face!","page":"Internals","title":"FerriteAssembly.work_single_face!","text":"work_single_face!(worker, facebuffer)\n\nEach worker that supports for a facebuffer should overload this function.\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly.autogenerate_cellvalues","page":"Internals","title":"FerriteAssembly.autogenerate_cellvalues","text":"autogenerate_cellvalues(fv::CellValues, args...)\n\nJust return the provided CellValues \n\nautogenerate_cellvalues(qr::QuadratureRule, ip_fun::Interpolation, ip_geo::Interpolation, f)\n\nDepending on the return type of f(x,t), return CellScalarValues(qr, ip_fun, ip_geo) or CellVectorValues(qr, ip_fun, ip_geo).\n\nautogenerate_cellvalues(order::Int, ip_fun::Interpolation{dim,RefShape}, ip_geo::Interpolation{dim,RefShape}, f)\n\nUsing quadrature rule, qr = QuadratureRule{dim,RefShape}(order), call autogenerate_cellvalues(qr, ip_fun, ip_geo, f)\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly.autogenerate_facevalues","page":"Internals","title":"FerriteAssembly.autogenerate_facevalues","text":"autogenerate_facevalues(fv::FaceValues, args...)\n\nJust return the provided FaceValues \n\nautogenerate_facevalues(qr::QuadratureRule, ip_fun::Interpolation, ip_geo::Interpolation, f)\n\nDepending on the return type of f(x,t,n), return FaceScalarValues(qr, ip_fun, ip_geo) or FaceVectorValues(qr, ip_fun, ip_geo).\n\nautogenerate_facevalues(order::Int, ip_fun::Interpolation{dim,RefShape}, ip_geo::Interpolation{dim,RefShape}, f)\n\nUsing quadrature rule, qr = QuadratureRule{dim-1,RefShape}(order), call autogenerate_facevalues(qr, ip_fun, ip_geo, f)\n\n\n\n\n\n","category":"function"},{"location":"internals/#Threading-model","page":"Internals","title":"Threading model","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"FerriteAssembly.TaskChunks","category":"page"},{"location":"internals/#FerriteAssembly.TaskChunks","page":"Internals","title":"FerriteAssembly.TaskChunks","text":"TaskChunks(chunks)\n\nThis is strictly an internal implementation detail for now. It is used to provide a variant of Base.Channel, but  where data is not removed, the index is just incremented.\n\n\n\n\n\n","category":"type"},{"location":"design/#Package-design","page":"Design","title":"Package design","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"At the top level, the user of FerriteAssembly needs to interact with two main types of objects, a domain buffer (or a Dict of multiple domain buffers) and a worker (for example an assembler). ","category":"page"},{"location":"design/#Worker","page":"Design","title":"Worker","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"The worker is the simplest object, and determines what is done for each item in the domain(s).","category":"page"},{"location":"design/#Domain-buffer","page":"Design","title":"Domain buffer","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Two domain buffer types are implemented, a regular and a threaded version. To understand the structure, it sufficies to to understand the regular buffer. The threaded version just contains additional values to have per-task buffers etc.  The key fields of the DomainBuffer type are (1) a set of items to iterate over (for example a vector of Int for a list of cells or a vector of FaceIndex for a list of faces) and an itembuffer (e.g., CellBuffer or FaceBuffer) containing the data required to do something for each entity. ","category":"page"},{"location":"design/#ItemBuffer","page":"Design","title":"ItemBuffer","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"The most important fields in an item buffer are the user-defined material and the FEValues (e.g. CellValues or FaceValues). ","category":"page"},{"location":"design/#Requirements-for-being-a-domain","page":"Design","title":"Requirements for being a domain","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"In addition to having the same FEValues and material,  the items in a domain must also share the same SubDofHandler.  However, multiple domains can share the same SubDofHandler.","category":"page"},{"location":"design/#Setting-up-one-domain","page":"Design","title":"Setting up one domain","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Each domain is described by a DomainSpec. Based on a DomainSpec, we call  the function setup_domainbuffer to create a DomainBuffer. The motivation  for this two-stage process, is to separate the information given and to simplify  setting up multiple domains. Depending on the options given to setup_domainbuffer, different buffers can be returned, such as ThreadedDomainBuffer or a domain buffer with a special AutoDiffCellBuffer to speed up automatic differentiation. ","category":"page"},{"location":"design/#Multiple-domains","page":"Design","title":"Multiple domains","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Figure 1 shows an example of a mesh, containing both  Quadrilateral and Triangle elements, as well as two different materials, which we call \"matrix\" and \"conclusion\". In this case, we could have two SubDofHandlers, one for triangles and one for quadrilateral. If we would like to assemble the cell contribution for this grid, we need four different domains,  shown by the different colors in the figure.  This is because the the CellBuffer would contain different material types for each domain, and we would require different CellValues for the triangles and quadrilaterals. ","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"(Image: domains)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Figure 1: Domains","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"When setting up the domains, we collect all domains into a Dict, which is  done by calling setup_domainbuffers(::Dict{String,DomainSpec}; kwargs...), where the keyword arguments are the same as for a single domainbuffer. ","category":"page"},{"location":"design/#User-defined-overloaded-functions","page":"Design","title":"User-defined overloaded functions","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"The user interacts with FerriteAssembly on the top level, when setting up the domain buffer and the worker. But to make it work, the user must also overload  several functions that happen at the innermost part of the iteration of items in the grid. Some key functions to be overloaded are ","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"element_routine!: Calculate Ke, re, and state\nelement_residual!: Calculate re, and state\ncreate_cell_state: For the given material and initial cell dof values, return the initial value of the cell state. Typically one value per integration point. \nallocate_cell_cache: Define workspace for calculation on a single cell\nallocate_face_cache: Same as above, but for a face ","category":"page"},{"location":"design/#State-variables","page":"Design","title":"State variables","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"State variables (both current and old) are stored as a Dict{Int} in the domain buffer (for cells, not for faces, this may be added in the future).  The key corresponds to the cell id, and the state can be gotten with the  get_state and get_old_state functions. ","category":"page"},{"location":"design/#User-data","page":"Design","title":"User-data","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"All item buffers contain a user_data field for passing any additional information to the item being worked. In most cases, this should not be necessary, but it provides an easy way to do something that is not normally supported.  The object is passed around as reference; care must thus be taken to avoid race conditions if written to during threaded work.","category":"page"},{"location":"Convenience/LoadHandler/#External-loading","page":"External loads","title":"External loading","text":"","category":"section"},{"location":"Convenience/LoadHandler/","page":"External loads","title":"External loads","text":"In many simulations, there is a need to add contributions to the weak form  in the form of external loads, either as source terms/body loads, or as  non-zero Neumann boundary conditions. FerriteAssembly provides a  LoadHandler for this purpose, such that it is not necessary to  implement those terms into the specific elements directly. This avoid having  to pass information to the elements about changes to the load levels etc. ","category":"page"},{"location":"Convenience/LoadHandler/","page":"External loads","title":"External loads","text":"LoadHandler\nNeumann\nBodyLoad","category":"page"},{"location":"Convenience/LoadHandler/#FerriteAssembly.LoadHandler","page":"External loads","title":"FerriteAssembly.LoadHandler","text":"LoadHandler(dh::AbstractDofHandler)\n\nCreate a load handler for external loads to be applied on the  finite element simulation defined by a dofhandler dh.  It can be used to apply the Neumann and body load   contributions to the external \"force\"-vector, fext:\n\nfext = zeros(ndofs(dh))\nlh=LoadHandler(dh)\nadd!(lh, Neumann(...))  # Add Neumann boundary conditions\nadd!(lh, BodyLoad(...)) # Add body load\nfor t in timesteps\n    fill!(fext, 0)\n    apply!(fext, lh, t) # Add contributions to `fext`\n    ...\nend\n\n\n\n\n\n","category":"type"},{"location":"Convenience/LoadHandler/#FerriteAssembly.Neumann","page":"External loads","title":"FerriteAssembly.Neumann","text":"Neumann(field_name::Symbol, fv_info::Union{FaceValues,QuadratureRule,Int}, faceset::Set{FaceIndex}, f)\n\nDefine a Neumann contribution with the weak forms according to \n\nint_Gamma f  delta u  mathrmdGamma quad textScalar fields \n\nint_Gamma boldsymbolf cdot boldsymboldelta u  mathrmdGamma\nquad textVector fields \n\nwhere Gamma is the boundary where the contribution is active.  f, or boldsymbolf, is the prescribed Neumann value,  defined by a function with signatures\n\nf(x::Vec, t::Real, n::Vec) -> Number (Scalar field)\n\nf(x::Vec, t::Real, n::Vec) -> Vec{dim} (Vector field)\n\nwhere x is the spatial position of the current quadrature point, t is the  current time, and n is the face normal vector. The remaining input arguments are\n\nfieldname describes the field on which the boundary condition should abstract\nfv_info gives required input to determine the facevalues. The following input types are accepted:\nInt giving the integration order to use. FaceValues are deduced from the interpolation  of fieldname and the output of f. \nQuadratureRule matching the interpolation for fieldname for faces in faceset FaceValues are deduced  from the output of f\nFaceValues matching the interpolation for fieldname for the faces in faceset and output of f\nfaceset describes which faces the BC is applied to\n\n\n\n\n\n","category":"type"},{"location":"Convenience/LoadHandler/#FerriteAssembly.BodyLoad","page":"External loads","title":"FerriteAssembly.BodyLoad","text":"BodyLoad(field_name::Symbol, cv_info::Union{CellValues,QuadratureRule,Int}, cellset::Set{Int}, f)\nBodyLoad(field_name::Symbol, cv_info::Union{CellValues,QuadratureRule,Int}, f)\n\nDefine a body load contribution with the weak forms according to \n\nint_Omega f  delta u  mathrmdOmega quad textScalar fields \n\nint_Omega boldsymbolf cdot boldsymboldelta u  mathrmdOmega\nquad textVector fields \n\nwhere Omega is the region where the contribution is active.  f, or boldsymbolf, is the prescribed volumetric contribution (e.g. force/volume),  defined by a function with signatures\n\nf(x::Vec, t::Real) -> Number (Scalar field)\n\nf(x::Vec, t::Real) -> Vec{dim} (Vector field)\n\nwhere x is the spatial position of the current quadrature point and t is the  current time. The remaining input arguments are\n\nfieldname describes the field on which the load should act\ncv_info gives required input to determine the cellvalues. The following input types are accepted:\nInt giving the integration order to use. CellValues are deduced from the interpolation  of fieldname and the output of f.   \nQuadratureRule matching the interpolation for fieldname for cells in cellset.  CellValues are deduced from the output of f\nCellValues matching the interpolation for fieldname for the cells in cellset and output of f\ncellset describes which cells the load is applied to. If not given, the load is applied to all cells \n\n\n\n\n\n","category":"type"},{"location":"Convenience/LoadHandler/","page":"External loads","title":"External loads","text":"","category":"page"},{"location":"howto/surface_integral/","page":"Surface integration","title":"Surface integration","text":"EditURL = \"../literate_howto/surface_integral.jl\"","category":"page"},{"location":"howto/surface_integral/#Surface-integration","page":"Surface integration","title":"Surface integration","text":"","category":"section"},{"location":"howto/surface_integral/","page":"Surface integration","title":"Surface integration","text":"using Ferrite, FerriteAssembly","category":"page"},{"location":"howto/surface_integral/","page":"Surface integration","title":"Surface integration","text":"This how-to shows integration of the normal flux on a surface. As usual, we need the basic Ferrite building blocks, in this case a grid, dofhandler, and facevalues","category":"page"},{"location":"howto/surface_integral/","page":"Surface integration","title":"Surface integration","text":"grid = generate_grid(Hexahedron, (5,5,5))\ndh = DofHandler(grid); add!(dh, :u, 1); close!(dh)\nqr = QuadratureRule{2,RefCube}(2); ip = Lagrange{3,RefCube,1}()\nfv = FaceScalarValues(qr, ip);\nnothing #hide","category":"page"},{"location":"howto/surface_integral/","page":"Surface integration","title":"Surface integration","text":"We also need a solution vector to integrate, unless we only calculate geometric properties.","category":"page"},{"location":"howto/surface_integral/","page":"Surface integration","title":"Surface integration","text":"a = zeros(ndofs(dh))\napply_analytical!(a, dh, :u, norm); # f(x)=norm(x)\nnothing #hide","category":"page"},{"location":"howto/surface_integral/","page":"Surface integration","title":"Surface integration","text":"And then we decide which faces to integrate over","category":"page"},{"location":"howto/surface_integral/","page":"Surface integration","title":"Surface integration","text":"domainbuffer = setup_domainbuffer(DomainSpec(dh, nothing, fv; set=getfaceset(grid, \"right\")));\nnothing #hide","category":"page"},{"location":"howto/surface_integral/#Using-SimpleIntegrator","page":"Surface integration","title":"Using SimpleIntegrator","text":"","category":"section"},{"location":"howto/surface_integral/","page":"Surface integration","title":"Surface integration","text":"Using the simple interface, SimpleIntegrator, we simply give it the function, (u,∇u,n)->∇u⋅n, and the initial value","category":"page"},{"location":"howto/surface_integral/","page":"Surface integration","title":"Surface integration","text":"s_integrator = SimpleIntegrator((u,∇u,n)->∇u⋅n, 0.0);\nnothing #hide","category":"page"},{"location":"howto/surface_integral/","page":"Surface integration","title":"Surface integration","text":"And then let it do its work","category":"page"},{"location":"howto/surface_integral/","page":"Surface integration","title":"Surface integration","text":"work!(s_integrator, domainbuffer; a=a);\n\nprintln(\"Flux: ∫qₙ dA = \", s_integrator.val)","category":"page"},{"location":"howto/surface_integral/#Using-Integrator","page":"Surface integration","title":"Using Integrator","text":"","category":"section"},{"location":"howto/surface_integral/","page":"Surface integration","title":"Surface integration","text":"To demonstrate how the full-fledged interface can be used, we perform the same task by using the Integrator. To do that, we have to define an integrand, let's call it NormalFlux, and overload the face integration function","category":"page"},{"location":"howto/surface_integral/","page":"Surface integration","title":"Surface integration","text":"mutable struct NormalFlux{T}\n    qn::T\nend\nfunction FerriteAssembly.integrate_face!(nf::NormalFlux, ae, material, fv, facebuffer)\n    for q_point in 1:getnquadpoints(fv)\n        dA = getdetJdV(fv, q_point)\n        ∇u = function_gradient(fv, q_point, ae)\n        n = getnormal(fv, q_point)\n        nf.qn += (∇u⋅n)*dA\n    end\nend;\nnothing #hide","category":"page"},{"location":"howto/surface_integral/","page":"Surface integration","title":"Surface integration","text":"To do the actual integration, we define an instance of the integrand, create an Integrator, and do the work.","category":"page"},{"location":"howto/surface_integral/","page":"Surface integration","title":"Surface integration","text":"nf = NormalFlux(0.0)\nintegrator = Integrator(nf)\nwork!(integrator, domainbuffer; a=a)\n\nprintln(\"Flux: ∫qₙ dA = \", nf.qn)","category":"page"},{"location":"howto/surface_integral/","page":"Surface integration","title":"Surface integration","text":"","category":"page"},{"location":"howto/surface_integral/","page":"Surface integration","title":"Surface integration","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FerriteAssembly","category":"page"},{"location":"#FerriteAssembly","page":"Home","title":"FerriteAssembly","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The goal of FerriteAssembly  is make it convenient to iterate over a grid and perform some task for each item. The primary use is to iterate over all cells and assemble into global matrices and  vectors. However, it makes many other tasks easy as well, for example iterating over faces for adding boundary conditions, or integrating a function over a given domain. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The design is built around two main types of objects","category":"page"},{"location":"","page":"Home","title":"Home","text":"Workers: What to do for a given item\nDomains: What items to work on","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package user is responsible for writing the code for the actual work (e.g., writing the element routine). A given combination of a worker and a type of domain requires the user to overload a specific function. For example, an assembler (worker) and a cell domain requires overloading element_routine! or element_residual!.","category":"page"},{"location":"#Documentation-structure","page":"Home","title":"Documentation structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The documentation has two main parts","category":"page"},{"location":"","page":"Home","title":"Home","text":"1) Learning by doing: runnable examples 2) Reference: explanations and docstrings\nTutorials: Complete examples Domains: What items to work on\nShort guides for specific tasks Workers: What to do for an item\n Convenience: Premade solutions to make life easy\n Customizations: When the standard isn't good enough\n Internals: Developer documentation","category":"page"}]
}
