var documenterSearchIndex = {"docs":
[{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"EditURL = \"https://github.com/KnutAM/FerriteAssembly.jl/blob/main/docs/src/literate/plasticity.jl\"","category":"page"},{"location":"examples/plasticity/#Plasticity","page":"Plasticity","title":"Plasticity","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This example shows how any material following the MaterialModelsBase.jl interface can be assembled with FerriteAssembly.jl. We start by the required packages","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"using Tensors, MaterialModelsBase, Ferrite, FerriteAssembly","category":"page"},{"location":"examples/plasticity/#Material-model","page":"Plasticity","title":"Material model","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We use the simple plasticity model from Ferrite.jl's example. First, we define the required material struct","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"struct J2Plasticity{T, S <: SymmetricTensor{4, 3, T}} <: AbstractMaterial\n    G::T  # Shear modulus\n    K::T  # Bulk modulus\n    σ₀::T # Initial yield limit\n    H::T  # Hardening modulus\n    Dᵉ::S # Elastic stiffness tensor\nend\nfunction elastic_conversion(E, ν)\n    δ(i,j) = i == j ? 1.0 : 0.0 # helper function\n    G = E / 2(1 + ν)\n    K = E / 3(1 - 2ν)\n\n    Isymdev(i,j,k,l) = 0.5*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k)) - 1.0/3.0*δ(i,j)*δ(k,l)\n    temp(i,j,k,l) = 2.0G *( 0.5*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k)) + ν/(1.0-2.0ν)*δ(i,j)*δ(k,l))\n    Dᵉ = SymmetricTensor{4, 3}(temp)\n    return Dᵉ, G, K\nend\nfunction J2Plasticity(E, ν, σ₀, H)\n    Dᵉ, G, K = elastic_conversion(E, ν)\n    return J2Plasticity(G, K, σ₀, H, Dᵉ)\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"And the state variable struct","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"struct MaterialState{T, S <: SecondOrderTensor{3, T}} <: AbstractMaterialState\n    ϵᵖ::S # plastic strain\n    σ::S # stress\n    k::T # hardening variable\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Then the initial material state function","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function MaterialModelsBase.initial_material_state(::J2Plasticity)\n    return MaterialState(zero(SymmetricTensor{2,3}), zero(SymmetricTensor{2,3}), 0.0)\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"And finally the material_response function","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function MaterialModelsBase.material_response(\n    material::J2Plasticity, ϵ::SymmetricTensor{2,3}, state::MaterialState,\n    Δt, cache=get_cache(material), args...; kwargs...)\n    # unpack some material parameters\n    G = material.G\n    H = material.H\n\n    # We use (•)ᵗ to denote *trial*-values\n    σᵗ = material.Dᵉ ⊡ (ϵ - state.ϵᵖ) # trial-stress\n    sᵗ = dev(σᵗ)         # deviatoric part of trial-stress\n    J₂ = 0.5 * sᵗ ⊡ sᵗ  # second invariant of sᵗ\n    σᵗₑ = sqrt(3.0*J₂)   # effective trial-stress (von Mises stress)\n    σʸ = material.σ₀ + H * state.k # Previous yield limit\n\n    φᵗ  = σᵗₑ - σʸ # Trial-value of the yield surface\n\n    if φᵗ < 0.0 # elastic loading\n        return σᵗ, material.Dᵉ, MaterialState(state.ϵᵖ, σᵗ, state.k)\n    else # plastic loading\n        h = H + 3G\n        μ =  φᵗ / h   # plastic multiplier\n\n        c1 = 1 - 3G * μ / σᵗₑ\n        s = c1 * sᵗ           # updated deviatoric stress\n        σ = s + vol(σᵗ)       # updated stress\n\n        # Compute algorithmic tangent stiffness ``D = \\frac{\\Delta \\sigma }{\\Delta \\epsilon}``\n        κ = H * (state.k + μ) # drag stress\n        σₑ = material.σ₀ + κ  # updated yield surface\n\n        δ(i,j) = i == j ? 1.0 : 0.0\n        Isymdev(i,j,k,l)  = 0.5*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k)) - 1.0/3.0*δ(i,j)*δ(k,l)\n        Q(i,j,k,l) = Isymdev(i,j,k,l) - 3.0 / (2.0*σₑ^2) * s[i,j]*s[k,l]\n        b = (3G*μ/σₑ) / (1.0 + 3G*μ/σₑ)\n\n        Dtemp(i,j,k,l) = -2G*b * Q(i,j,k,l) - 9G^2 / (h*σₑ^2) * s[i,j]*s[k,l]\n        D = material.Dᵉ + SymmetricTensor{4, 3}(Dtemp)\n\n        # Return new state\n        Δϵᵖ = 3/2 * μ / σₑ * s # plastic strain\n        ϵᵖ = state.ϵᵖ + Δϵᵖ    # plastic strain\n        k = state.k + μ        # hardening variable\n        return σ, D, MaterialState(ϵᵖ, σ, k)\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Element-routine","page":"Plasticity","title":"Element routine","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"The element routine for any material that follows the MaterialModelsBase.jl interface can be coded as follows:","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function FerriteAssembly.element_routine!(\n    Ke::AbstractMatrix, re::AbstractVector, state::Vector{<:AbstractMaterialState},\n    ae::AbstractVector, material::AbstractMaterial, cellvalues::CellVectorValues, dh_fh, Δt, buffer::CellBuffer)\n    cache = FerriteAssembly.get_cache(buffer)\n    n_basefuncs = getnbasefunctions(cellvalues)\n    for q_point in 1:getnquadpoints(cellvalues)\n        # For each integration point, compute stress and material stiffness\n        ϵ = function_symmetric_gradient(cellvalues, q_point, ae) # Total strain\n        σ, D, state[q_point] = material_response(material, ϵ, state[q_point], Δt, cache)\n\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:n_basefuncs\n            δϵ = shape_symmetric_gradient(cellvalues, q_point, i)\n            re[i] += (δϵ ⊡ σ) * dΩ ## add internal force to residual\n            for j in 1:n_basefuncs\n                Δϵ = shape_symmetric_gradient(cellvalues, q_point, j)\n                Ke[i, j] += δϵ ⊡ D ⊡ Δϵ * dΩ\n            end\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Note that the boundary traction was not included, as this can be handled separately with FerriteNeumann.jl","category":"page"},{"location":"examples/plasticity/#Initial-states","page":"Plasticity","title":"Initial states","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"The initial states are created by overloading the create_cell_state function","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function FerriteAssembly.create_cell_state(material::AbstractMaterial, cellvalues, x, ae)\n    return [initial_material_state(material) for _ in 1:getnquadpoints(cellvalues)]\nend","category":"page"},{"location":"examples/plasticity/#Assembly","page":"Plasticity","title":"Assembly","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"With all required functions defined, we can now setup and assemble the finite element problem","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"material = J2Plasticity(200.0e9, 0.3, 200.0e6, 10.0e9);\ngrid = generate_grid(Tetrahedron, (20,2,4), zero(Vec{3}), Vec((10.0,1.0,1.0)));\ncellvalues = CellVectorValues(\n    QuadratureRule{3,RefTetrahedron}(2), Lagrange{3, RefTetrahedron, 1}());\ndh = DofHandler(grid); add!(dh, :u, 3); close!(dh); # Create dofhandler\nK = create_sparsity_pattern(dh);\nr = zeros(ndofs(dh));\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Using the create_states function, we can easily create the storage of state variables suitable for the chosen dof handler and the given material (via the create_cell_state function that we defined earlier)","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"states = create_states(dh, material, cellvalues);\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"And then we create the buffer for saving cell-related variables","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"buffer = setup_cellbuffer(dh, cellvalues, material, nothing, get_cache(material));\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Finally, with an initial guess of displacements, a, we can create the assembler and do the assembly","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"a = zeros(ndofs(dh))\nassembler = start_assemble(K,r)\ndoassemble!(assembler, buffer, states, dh, a);\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"ExampleElements/#Example-elements","page":"Example elements","title":"Example elements","text":"","category":"section"},{"location":"ExampleElements/","page":"Example elements","title":"Example elements","text":"The package includes a set of example elements inside the submodule FerriteAssembly.ExampleElements. In order to use these it is possible to import them explicitly as, e.g.,","category":"page"},{"location":"ExampleElements/","page":"Example elements","title":"Example elements","text":"import FerriteAssembly.ExampleElements: StationaryFourier","category":"page"},{"location":"ExampleElements/#Available-example-elements","page":"Example elements","title":"Available example elements","text":"","category":"section"},{"location":"ExampleElements/","page":"Example elements","title":"Example elements","text":"WeakForm\nStationaryFourier\nTransientFourier\nElasticPlaneStress\nPoroElasticPlaneStrain","category":"page"},{"location":"ExampleElements/","page":"Example elements","title":"Example elements","text":"ExampleElements.WeakForm\nExampleElements.StationaryFourier\nExampleElements.TransientFourier\nExampleElements.ElasticPlaneStress\nExampleElements.PoroElasticPlaneStrain","category":"page"},{"location":"ExampleElements/#FerriteAssembly.ExampleElements.WeakForm","page":"Example elements","title":"FerriteAssembly.ExampleElements.WeakForm","text":"WeakForm(f::Function)\n\nSolve the problem with primary variable, u, variation, delta u, and a weak form\n\n   int_Omega f(delta u delta u otimesnabla u u otimesnabla dotu dotu otimesnabla) mathrmdOmega \n   - int_Gamma delta u h(xtn) mathrmdGamma - int_Omega delta u b(xt) mathrmdOmega = 0\n\nwhere the function f is given to the weak form, and h and b are given with FerriteNeumann.\n\nnote: This element is intended for testing\nIt is not optimized for speed\n\nExamples\n\nTransient heat flow\n\nWeak form\n\n    int_Omega delta u c dotu - k nabla delta u cdot nabla u mathrmdOmega \n   - int_Gamma delta u q_mathrmn mathrmdGamma + int_Omega delta u b mathrmdOmega = 0\n\nImplementation\n\nc = 1.0; k = 1.0; # heat capacity and heat conductivity (material parameters)\nqn = 1.0; b=1.0;  # Normal boundary flux and internal heat source (external loading)\nmaterial = WeakForm((δu, ∇δu, u, ∇u, u_dot, ∇u_dot) -> δu*c*u_dot - k*(∇δu ⋅ ∇u))\nnh = NeumannHandler(dh)\nadd!(nh, Neumann(:u, 2, getfaceset(dh.grid, \"right\"), (x,t,n)->qn))\nadd!(nh, BodyLoad(:c, 1, (x,t)->b))\n\nLinear elasticity\n\nWeak form\n\n   int_Omega boldsymboldelta uotimesnabla^mathrmsym  boldsymbolsigma mathrmdOmega \n   - int_Gamma boldsymboldelta u cdot boldsymbolt mathrmdGamma \n   - int_Omega boldsymboldelta u cdot boldsymbolb mathrmdOmega = 0\n\nImplementation\n\nG = 80e3; K = 160e3; # Shear and bulk modulus (material parameters)\ntn = 1.0, b=Vec((0.0, 0.0, -1.0)); # Normal traction and body force (external loading)\nmaterial = WeakForm((δu, ∇δu, u, ∇u, u_dot, ∇u_dot) -> (∇δu ⊡ (2*G*dev(symmetric(∇u)) + 3*K*vol(∇u))))\nnh = NeumannHandler(dh)\nadd!(nh, Neumann(:u, 2, getfaceset(dh.grid, \"right\"), (x,t,n)->tn*n))\nadd!(nh, BodyLoad(:c, 2, (x,t)->b))\n\n\n\n\n\n","category":"type"},{"location":"ExampleElements/#FerriteAssembly.ExampleElements.StationaryFourier","page":"Example elements","title":"FerriteAssembly.ExampleElements.StationaryFourier","text":"StationaryFourier(k)\n\nFor solving stationary linear heat conduction (which uses Fourier's law) with conductivity k,  such that the heat flux is boldsymbolq=-k nabla T, where T is the temperature field. \n\nThe strong form is,\n\n nabla cdot boldsymbolq = h  quad textbfx in Omega\n\nand the corresponding weak form is \n\n   int_Omega nabla delta T cdot boldsymbolq mathrmdOmega \n   = int_Gamma delta T q_mathrmn mathrmdGamma \n   - int_Omega delta T h mathrmdOmega\n\nwhere, on the right hand side, q_mathrmn is a heat flux normal to the boundary Gamma, and h is a volumetric heat supply.  These contributions are not included in the element, and should be added with FerriteNeumann.jl\n\n\n\n\n\n","category":"type"},{"location":"ExampleElements/#FerriteAssembly.ExampleElements.TransientFourier","page":"Example elements","title":"FerriteAssembly.ExampleElements.TransientFourier","text":"TransientFourier(k, c)\n\nFor solving the transient linear heat equation (which uses Fourier's law) with conductivity k,  such that the heat flux is boldsymbolq=-k nabla T, where T is the temperature field. \n\nThe strong form is,\n\n    c dotT + nabla cdot boldsymbolq = h  quad textbfx in Omega\n\nand the corresponding time-discretized weak form is \n\n    int_Omega delta T c fracT - ^mathrmnTDelta t mathrmdOmega\n    + int_Omega nabla delta T cdot boldsymbolq mathrmdOmega \n   = int_Gamma delta T q_mathrmn mathrmdGamma \n   - int_Omega delta T h mathrmdOmega\n\nwhere ^mathrmnT is the old temperature (in the previous timestep) and Delta t is the timestep.  On the right hand side, q_mathrmn is a heat flux normal to the boundary Gamma, and h is a volumetric heat supply.  These external contributions on the right hand side are not included in the element,  and should be added with FerriteNeumann.jl\n\n\n\n\n\n","category":"type"},{"location":"ExampleElements/#FerriteAssembly.ExampleElements.ElasticPlaneStress","page":"Example elements","title":"FerriteAssembly.ExampleElements.ElasticPlaneStress","text":"ElasticPlaneStress(;E=2.e3, ν=0.3)\n\nFor solving linear elasticity for plane stress, where Young's modulus, E, and Poisson's ratio, ν, is used to construct the correct stiffness tensor, boldsymbolmathsfC,  such that the stress, boldsymbolsigma=boldsymbolmathsfCboldsymbolepsilon,  where the strain tensor, boldsymbolepsilon=boldsymboluotimesnabla^mathrmsym, is calculated from the displacement field, boldsymbolu(boldsymbolxt). \n\nThe strong form of the mechanical quasi-static equilibrium is\n\n    boldsymbolsigma cdot nabla + boldsymbolb = 0 quad textbfx in Omega\n\nwith the corresponding weak form, \n\n   int_Omega boldsymboldelta uotimesnabla^mathrmsym  boldsymbolsigma mathrmdOmega \n   = int_Gamma boldsymboldelta u cdot boldsymbolt mathrmdGamma \n   + int_Omega boldsymboldelta u cdot boldsymbolb mathrmdOmega\n\nThe external loading on the right hand side is not included in the element, but can be implemented  using FerriteNeumann.jl.  \n\n\n\n\n\n","category":"type"},{"location":"ExampleElements/#FerriteAssembly.ExampleElements.PoroElasticPlaneStrain","page":"Example elements","title":"FerriteAssembly.ExampleElements.PoroElasticPlaneStrain","text":"PoroElasticPlaneStrain(;E=2.e3, ν=0.3, k=0.05, α=1.0, β=1/2e3)\n\nTODO\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = FerriteAssembly","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Methods that should be overloaded and exported functions are described on this page. It may also be useful to checkout the Data structures.","category":"page"},{"location":"api/#Element-routines","page":"API","title":"Element routines","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"One of the element methods should be overloaded for a given combination of cellvalues and material.  Note that the cellvalues are already reinit!:ed when passed to the element routines. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"FerriteAssembly.element_routine!\nFerriteAssembly.element_residual!","category":"page"},{"location":"api/#FerriteAssembly.element_routine!","page":"API","title":"FerriteAssembly.element_routine!","text":"element_routine!(\n    Ke::AbstractMatrix, re::AbstractVector, state,\n    ae::AbstractVector, material, cellvalues, \n    dh_fh, Δt, buffer\n    )\n\nThe main function to be overloaded for the specific material and cellvalues. This function should modify the element stiffness matrix Ke and the residual re.\n\nstate should contain a state description for the element.  Typically, state will be a vector with a state variable for each  integration point, but it can also be any other type for each element.  On input, these are the old values and should be mutated to the updated  value for the current time step and guess for ae. \nThe user defined material variable usually contain the material parameters. \ncellvalues should contain the CellValues for the given element.  It can also be a tuple or named tuple of cellvalues. \nWhen the regular DofHandler is used, dh_fh::DofHandler is passed to the element  routine. However, if the MixedDofHandler is used, one of its fieldhandlers are passed  as dh_fh::FieldHandler. This gives the option to call dof_range(dh_fh, field::Symbol)  for multi-field problems. Note: Please do not rely on dh_fh for anything but dof_range, as dh_fh may be replaced with another type that only supports dof_range.\nΔt is time increment given to doassemble\nbuffer::Union{CellBuffer, AutoDiffCellBuffer} can be used to get \ngetcoordinates(buffer)::Vector{Vec}: The cell's coordinates\ncelldofs(buffer)::Vector{Int}: The cell's global degrees of freedom numbers\nFerriteAssembly.get_aeold(buffer): aold[celldofs] (if aold::Nothing is passed to  doassemble, a vector, [NaN for d in celldofs] is returned)\nFerriteAssembly.get_load(buffer): The cell_load in the buffer, typically used for   body loads or source terms. \nFerriteAssembly.get_cache(buffer): The cache in the buffer - typically used to gather all   preallocations if such are necessary\n\n\n\n\n\nFerriteAssembly.element_routine!(Ke, re, state, ae, m::MaterialModelsBase.AbstractMaterial, args...)\n\nSolve the weak form \n\n   int_Omega boldsymboldelta uotimesnabla^mathrmsym  boldsymbolsigma mathrmdOmega \n   = int_Gamma boldsymboldelta u cdot boldsymbolt mathrmdGamma \n   + int_Omega boldsymboldelta u cdot boldsymbolb mathrmdOmega\n\nwhere sigma is calculated with the material_response function from  MaterialModelsBase.jl.  Note that create_cell_state is already implemented for <:AbstractMaterial. \n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteAssembly.element_residual!","page":"API","title":"FerriteAssembly.element_residual!","text":"element_residual!(\n    re::AbstractVector, state, \n    ae::AbstractVector, material, cellvalues, \n    dh_fh, Δt, buffer\n    )\n\nTo calculate the element tangent stiffness Ke automatically by using ForwardDiff, it is possible to overload element_residual! instead of element_routine!. See  element_routine! for a description of the input parameters. \n\nNote that in order for this function to work, care must be taken when mutating values to not change their types. When mutating the state, ensure to call ForwardDiff.value() on those values. Warning: Only do this at a point when the calculation of re is  unaffected by the values in state, otherwise Ke will be wrong. \n\n\n\n\n\n","category":"function"},{"location":"api/#CellBuffer","page":"API","title":"CellBuffer","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Variables that are used and modified for each cell of a certain type,  but that don't belong to a specific cell, are collected in a CellBuffer.","category":"page"},{"location":"api/","page":"API","title":"API","text":"CellBuffer\nsetup_cellbuffer\nAutoDiffCellBuffer\nsetup_ad_cellbuffer\ngetCellBuffer","category":"page"},{"location":"api/#FerriteAssembly.CellBuffer","page":"API","title":"FerriteAssembly.CellBuffer","text":"CellBuffer(\n    numdofs::Int, numnodes::Int, ::Val{dim}, \n    cellvalues, material, cell_load=nothing, cache=nothing) -> CellBuffer\n\nCreate a cell cache for an element with numdofs degrees of freedom and numnodes nodes with dimension dim. Add the given cellvalues, material,  and cache to the CellBuffer as well. Note that this constructor is normally  not used, and is instead called from setup_cellbuffer. \n\n\n\n\n\n","category":"type"},{"location":"api/#FerriteAssembly.setup_cellbuffer","page":"API","title":"FerriteAssembly.setup_cellbuffer","text":"setup_cellbuffer(\n    dh::DofHandler, cellvalues, material, \n    cell_load=nothing, cache=nothing)\n\nCreates a single CellBuffer for use with the standard DofHandler and a single material.\n\n\n\n\n\nsetup_cellbuffer(\n    dh::MixedDofHandler, cellvalues, material, \n    cell_load=nothing, cache=nothing)\n\nReturn a tuple of CellBuffers for each FieldHandler in dh.fieldhandlers. cellvalues[i] corresponds to dh.fieldhandlers[i], and so does  materials[i], cell_load[i] and caches[i]. If only one CellValues, material, cell_load, and/or cache is given (not as a ::Tuple), the same is used for all fieldhandlers.  If a tuple of cellvalues (or materials/cell_load/caches) should be used for each cell,  and the same tuple should be used for each fieldhandler,  then it must be given as a tuple of tuples.  (Often, it is better to give a NamedTuple of e.g. CellValues to be used for every fieldhandler)\n\nThe Ferrite.jl functions getcoordinates(::CellBuffer) and celldofs(::CellBuffer) are defined and can  be used inside an element routine to get the current cell's coordinates and dof-numbers. \n\n\n\n\n\nsetup_cellbuffer(dh::AbstractDofHandler, cv, materials::Dict, \n    cell_load=nothing, cache=nothing)\n\nReturn a Dict{String} for each material in materials. If any of cv, cell_load, or cache is not a Dict, the same value  is used for each CellBuffer. If Dicts are used, the keys must match  those in materials. The return type depends on the dh:\n\ndh::DofHandler: Dict{String,<:CellBuffer}\ndh::MixedDofHandler: Dict{String,NTuple{N,CellBuffer}\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteAssembly.AutoDiffCellBuffer","page":"API","title":"FerriteAssembly.AutoDiffCellBuffer","text":"AutoDiffCellBuffer(cb::CellBuffer, cellstates, dh_fh::Union{DofHandler,FieldHandler})\n\ncellstates should be the states for the relevant cells in dh_fh.  An AutoDiffCellBuffer wraps a CellBuffer and behaves the same way  wrt defined functions, i.e. all get* functions defined for CellBuffer are also defined for AutoDiffCellBuffer.  When used for automatic differentiation, only the wrapped CellBuffer  is passed to element_residual!.  As a backup solution if direct field access is used, the function  getCellBuffer returns the CellBuffer for both a CellBuffer  and an AutoDiffCellBuffer. \n\nNote that this constructor is normally not used,  but called from the setup_ad_cellbuffer function.\n\n\n\n\n\n","category":"type"},{"location":"api/#FerriteAssembly.setup_ad_cellbuffer","page":"API","title":"FerriteAssembly.setup_ad_cellbuffer","text":"setup_ad_cellbuffer(states, dh::AbstractDofHandler, args...)\n\nCreate a special cell buffer that improves performance when using  automatic differentiation to calculate the element stiffness. The exact same  inputs as for setup_cellbuffer should be used, except that the  states variable that is passed to doassemble! should be prepended to the  argument list.  \n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteAssembly.getCellBuffer","page":"API","title":"FerriteAssembly.getCellBuffer","text":"getCellBuffer(b::Union{CellBuffer,AutoDiffCellBuffer})\n\nReturn the CellBuffer if isa(b,CellBuffer), else, return the CellBuffer wrapped by b::AutoDiffCellBuffer, i.e. b.cb\n\n\n\n\n\n","category":"function"},{"location":"api/#Access-functions","page":"API","title":"Access functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following access functions can be used to extract information from the  CellBuffer","category":"page"},{"location":"api/","page":"API","title":"API","text":"Ferrite.getcoordinates\nFerriteAssembly.get_aeold\nFerriteAssembly.get_load\nFerriteAssembly.get_cache","category":"page"},{"location":"api/#Ferrite.getcoordinates","page":"API","title":"Ferrite.getcoordinates","text":"Ferrite.getcoordinates(c::CellBuffer)\n\nFerrite.jl's getcoordinates function is overloaded on the CellBuffer to return  the current cell's nodal coordinates. \n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteAssembly.get_aeold","page":"API","title":"FerriteAssembly.get_aeold","text":"FerriteAssembly.get_aeold(c::CellBuffer)\n\nGet the old element dof-values for the current cell\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteAssembly.get_load","page":"API","title":"FerriteAssembly.get_load","text":"FerriteAssembly.get_load(c::CellBuffer)\n\nGet the user specified body load given to CellBuffer\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteAssembly.get_cache","page":"API","title":"FerriteAssembly.get_cache","text":"FerriteAssembly.get_cache(c::CellBuffer)\n\nGet the user-specified cache given to the CellBuffer\n\n\n\n\n\n","category":"function"},{"location":"api/#State-variables","page":"API","title":"State variables","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The initial state variables may vary depending on the position in the grid. Furthermore, the datastructure depends on the type of dof handler, so a convenience function exists that creates the correct variable structure. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"create_states\nFerriteAssembly.create_cell_state","category":"page"},{"location":"api/#FerriteAssembly.create_states","page":"API","title":"FerriteAssembly.create_states","text":"create_states(dh::DofHandler, material=nothing, cellvalues=nothing, a=nothing)\n\nCreate the state variables for the given dh, material, cellvalues, and global  dof vector a. material and cellvalues can be a Dict{String}, in which case they  should have the same keys, corresponding to cellsets in the grid.  This follows the same structure as for creating a CellBuffer. The function create_cell_state is called for each cell. \n\n\n\n\n\ncreate_states(dh::MixedDofHandler, material=nothing, cellvalues=nothing, a=nothing)\n\nCreate the state variables for the given dh, material, cellvalues, and global dof vector a. \n\nmaterial and cellvalues follow the same input structure as to setup_cellbuffer.  I.e., they can be tuples with the same length as fh.fieldhandlers.  Note that if cellvalues::Tuple is desired to be passed into the create_cell_state function, it must be wrapped in an outer ntuple with the same length as fh.fieldhandlers. (But using a NamedTuple is recommended to avoid this problem). \n\nFor multiple materials, material::Dict{String}, and cellvalues can optionally be that as well,  but then they must have the same keys. This follows the same structure as for creating a CellBuffer. The function create_cell_state is called for each cell. \n\nThe order of each call to create_cell_state is fixed for a given input, i.e. the loops are only  over sorted Sets and Dict keys. (Useful if using StableRNGs.jl for random variations to obtain reproducible results)\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteAssembly.create_cell_state","page":"API","title":"FerriteAssembly.create_cell_state","text":"create_cell_state(material, cellvalues, x, ae, [dh_fh])\n\nDefaults to returning nothing.\n\nOverload this function to create the state which should be passed  into the element_routine!/element_residual! for the given  material and cellvalues.  As for the element routines, ae, is filled with NaN unless the global degree of freedom vector is given to the  create_states function. \n\n\n\n\n\n","category":"function"},{"location":"api/#doassemble!","page":"API","title":"doassemble!","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Once everything is set up, one can call the function which will actually  do the assembly:","category":"page"},{"location":"api/","page":"API","title":"API","text":"doassemble!","category":"page"},{"location":"api/#FerriteAssembly.doassemble!","page":"API","title":"FerriteAssembly.doassemble!","text":"doassemble!(\n    assembler::Ferrite.AbstractSparseAssembler, cellbuffer::AbstractCellBuffer, \n    s::AbstractVector, dh::DofHandler, \n    a=nothing, aold=nothing, Δt=NaN, scaling=nothing; cellset=1:ncells\n    )\n\nSequential assembly of cells with the dh::DofHandler.\n\nassembler is obtained from Ferrite.jl's start_assemble(K,r) function\ncellbuffer contains buffers for the specific cell.  See  CellBuffer for more info. \ns is a collection (vector, dict, etc.) of state variables, where indexing  by cellnr gives the state variables for that cell. \na and aold are the current and old unknowns (can be set to nothing if not used)\nΔt is the time increment passed into each element routine\nscaling allows including element data in order to scale the residuals,  see Residual scaling\n\n\n\n\n\ndoassemble!(\n    assemblers::Vector{<:Ferrite.AbstractSparseAssembler},\n    cellbuffers::Vector{<:AbstractCellBuffer}, states, \n    dh::DofHandler, colored_sets::Vector{Vector{Int}}, \n    a=nothing, aold=nothing, Δt=NaN, \n    scalings::Vector=create_threaded_scalings(nothing);\n    cellset=nothing\n    )\n\nThreaded assembly of cells with the dh::DofHandler.\n\nassemblers are assemblers for each thread, which can be obtained with the create_threaded_assemblers function. \ncellbuffers contains buffers for the specific cell, for each thread. This can be created by create_threaded_CellBuffers.  See also CellBuffer for more info.\nstates, a, aold, and Δt are the same as for the  sequential doassemble!\ncolored_sets are cellsets for each color\n\n\n\n\n\ndoassemble!(\n    assembler::Ferrite.AbstractSparseAssembler, \n    cellbuffers::Tuple, states::Tuple, \n    dh::MixedDofHandler, \n    a=nothing, aold=nothing, Δt=NaN, scaling=nothing;\n    kwargs...\n    )\n\nSequential assembly of cells with the dh::MixedDofHandler.\n\ncellbuffers contains buffers for the specific cell in each FieldHandler in dh.fieldhandlers See  CellBuffer for more info. \nstates is a tuple which contains a collection of state variables,  one vector for each FieldHandler in dh.fieldhandlers.  Each element in the collection, i.e. states[cellnr], contains the  state variables for one Cell with global number cellnr.  Unless all cells have the same type of the state, it might make sense to use a  Dict{Int,State} where the key refers to the global number. \nassembler, a, aold, and Δt are the same as for the DofHandler case. \n\n\n\n\n\ndoassemble!(\n    assemblers::Vector{<:Ferrite.AbstractSparseAssembler},\n    cellbuffers::Tuple, \n    states::Tuple, \n    dh::MixedDofHandler, colored_sets::Vector{Vector{Int}}, \n    a::AbstractVector, aold::AbstractVector, Δt::Number, \n    scalings::Vector=create_threaded_scalings(nothing);\n    kwargs...)\n\nThreaded assembly of cells with the dh::MixedDofHandler.\n\nassemblers and colored_sets are the same as for the threaded DofHandler case.\nstates are the same as for the sequential MixedDofHandler case.\ncellbuffers contains vectors Vector{AbstractCellBuffer} for the cell type in  each FieldHandler in dh.fieldhandlers. The vector element corresponds to each  thread. This can be created by create_threaded_CellBuffers.  See also CellBuffer for more info.\na, aold, and Δt are the same as for the DofHandler case.\n\n\n\n\n\n","category":"function"},{"location":"api/#Threaded-assembly","page":"API","title":"Threaded assembly","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"For parallel assembly, we need a vector of CellBuffers and assemblers,  one for each thread. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"For the MixedDofHandler, the outer loop is over the type of cells, so we need a tuple that contains vectors of CellBuffers.  Construction of this via deepcopy is implemented as","category":"page"},{"location":"api/","page":"API","title":"API","text":"create_threaded_CellBuffers","category":"page"},{"location":"api/#FerriteAssembly.create_threaded_CellBuffers","page":"API","title":"FerriteAssembly.create_threaded_CellBuffers","text":"create_threaded_CellBuffers(c::CellBuffer; nthreads=Threads.nthreads())\ncreate_threaded_CellBuffers(cs::Tuple; nthreads=Threads.nthreads())\ncreate_threaded_CellBuffers(cs::Dict{String}; nthreads=Threads.nthreads())\n\nConvenience function for creating a vector with cell buffers for each thread.  The standard workflow is to first call CellBuffer with the  dof handler. For DofHandler this will give a CellBuffer,  and for MixedDofHandler this gives a tuple of CellBuffers.  In both cases, the output can be given to create_threaded_CellBuffers to produce the appropriate result required by the threaded versions of doassemble!. Similarily for a grid with mixed materials created by a dictionary of materials,  just pass the created CellBuffer to this function, and the output is what  doassemble! expects. \n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"A vector of assemblers that is convieniently created by calling ","category":"page"},{"location":"api/","page":"API","title":"API","text":"create_threaded_assemblers","category":"page"},{"location":"api/#FerriteAssembly.create_threaded_assemblers","page":"API","title":"FerriteAssembly.create_threaded_assemblers","text":"create_threaded_assemblers(K, r; nthreads=Threads.nthreads())\n\nConvenience function for creating a nthreads long vector with the  output of start_assemble as elements\n\n\n\n\n\n","category":"function"},{"location":"api/#Residual-scaling","page":"API","title":"Residual scaling","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"There are many options for how to scale the residual in finite element simulations. This package does not intend to implement many different options, but does give the  user the option to calculate scaling contributions from each cell, which may be useful. By defining a scaling that is passed to doassemble!, this can be updated in each cell.  One type of scaling, ElementResidualScaling, is included as described below. Its code can be used as a template  for how to include custom scaling that works on the element level. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"In general, a scaling must support the update_scaling! function. For consistency it is also nice, but not required, to support reset_scaling!. This function must, however, be called by the user before assembly (to allow consistent separated assembly using different cellsets). ","category":"page"},{"location":"api/","page":"API","title":"API","text":"FerriteAssembly.update_scaling!\nreset_scaling!","category":"page"},{"location":"api/#FerriteAssembly.update_scaling!","page":"API","title":"FerriteAssembly.update_scaling!","text":"update_scaling!(scaling, re, dh_fh, cellbuffer)\n\nThis function should add the contribution from the element residual vector re to the scaling factors in scaling.  The cellbuffer is included, which contains extra information if needed. \n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteAssembly.reset_scaling!","page":"API","title":"FerriteAssembly.reset_scaling!","text":"reset_scaling!(scaling)\n\nThis function should reset the scaling factors, such that the values don't accumulate if used  in multiple iterations/time steps. \n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Additionally, create_threaded_scalings can be used to copy one scaling to each thread when using with parallel assembly. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"create_threaded_scalings","category":"page"},{"location":"api/#FerriteAssembly.create_threaded_scalings","page":"API","title":"FerriteAssembly.create_threaded_scalings","text":"create_threaded_scalings(scaling; nthreads=Threads.nthreads()) -> Vector\n\nMakes nthreads deepcopies of scaling, such that it can be used for threaded assembly. Note: If creating your own scaling, it might make sense to define  Base.sum(::Vector{<:MyScalingType}) to sum scalings after threaded assembly. \n\n\n\n\n\n","category":"function"},{"location":"api/#ElementResidualScaling","page":"API","title":"ElementResidualScaling","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ElementResidualScaling","category":"page"},{"location":"api/#FerriteAssembly.ElementResidualScaling","page":"API","title":"FerriteAssembly.ElementResidualScaling","text":"ElementResidualScaling(dh::AbstractDofHandler, p=2, T=Float64)\n\nCreate tolerance scaling based on the sum of the p-norm of each cell's residual vector,  separately for each field. I.e. pseudo-code for field :u the scaling factor::T is\n\nfor each cell\n    element_routine!(Ke, re, args...) # Calculate re\n    factor += sum(abs.(re[dof_range(dh, :u)]).^p)^(1/p)\n\n\n\n\n\n","category":"type"},{"location":"MaterialModelsBase/#MaterialModelsBase","page":"MaterialModelsBase","title":"MaterialModelsBase","text":"","category":"section"},{"location":"MaterialModelsBase/","page":"MaterialModelsBase","title":"MaterialModelsBase","text":"If you have implemented your constitutive mechanical behavior following the  MaterialModelsBase.jl's API, FerriteAssembly.element_routine! and FerriteAssembly.create_cell_state  have already been implemented for this case. ","category":"page"},{"location":"MaterialModelsBase/","page":"MaterialModelsBase","title":"MaterialModelsBase","text":"FerriteAssembly.element_routine!(Ke, re, state::Vector{<:FerriteAssembly.MMB.AbstractMaterialState}, ae, material::FerriteAssembly.MMB.AbstractMaterial, cellvalues::CellVectorValues, dh_fh, Δt, cb)","category":"page"},{"location":"MaterialModelsBase/#FerriteAssembly.element_routine!-Tuple{Any, Any, Vector{<:MaterialModelsBase.AbstractMaterialState}, Any, MaterialModelsBase.AbstractMaterial, CellVectorValues, Any, Any, Any}","page":"MaterialModelsBase","title":"FerriteAssembly.element_routine!","text":"FerriteAssembly.element_routine!(Ke, re, state, ae, m::MaterialModelsBase.AbstractMaterial, args...)\n\nSolve the weak form \n\n   int_Omega boldsymboldelta uotimesnabla^mathrmsym  boldsymbolsigma mathrmdOmega \n   = int_Gamma boldsymboldelta u cdot boldsymbolt mathrmdGamma \n   + int_Omega boldsymboldelta u cdot boldsymbolb mathrmdOmega\n\nwhere sigma is calculated with the material_response function from  MaterialModelsBase.jl.  Note that create_cell_state is already implemented for <:AbstractMaterial. \n\n\n\n\n\n","category":"method"},{"location":"datastructures/#Data-structures","page":"Datastructures","title":"Data structures","text":"","category":"section"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"The assembly requires different datastructure, which also differ depending on  how the analysis is setup. An important feature of this package is that it provides a suggestion for how these structures can be organized to work in a range of cases.  While it is possible to use the package without knowing exactly how these are made,  it will make tracking down bugs easier and may be important for postprocessing.","category":"page"},{"location":"datastructures/#CellBuffer","page":"Datastructures","title":"CellBuffer","text":"","category":"section"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"All values passed into element_routine!, except the state variables,  dh_fh::Union{DofHandler,FieldHandler}, and time increment, are passed taken from the relevant CellBuffer.  (The cellbuffer itself is also passed into element_routine!.  By looking at the created CellBuffer, it is therefore clear what will  be passed into your element_routine!. ","category":"page"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"The following items deserve extra attention","category":"page"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"cellvalues: Can be either one CellValues (e.g CellVectorValues),  or a collection of these. This collection must be either a Tuple or  a NamedTuple for the reinitialization will work. If provided as a custom  type, just define Ferrite.reinit!(cv::MyCustomCellValueCollection, coords)\nmaterial: Represents the material to dispatch on for that specific element. \ncell_load: Is an additional custom user type, intended for defining source  terms or body loads. \ncache: A final custom user type, intended to store preallocated data  (e.g. for FE² simulations)","category":"page"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"Depending on the analysis, multiple CellBuffers may be created and  nested in various structures. These structures are explained in  the following table.  For brevity, the following abbrevations in type of analysis are used:  DH=DofHandler, MDH=MixedDofHandler with N fieldhandlers, and  MM = \"Multiple materials on the grid, not connected to each fieldhandler\"","category":"page"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"For the levels, Each X refers to the datastructure of CellBuffer for the cellset belonging to X, where X can be MAT (type of material),  thread, or FH (fieldhandler ::FieldHandler in MixedDofHandler). Note that on the lower level (closer to the cell), the cellset is always  reduced as the intersection between the higher level and the current.  I.e. for multithreaded cases, Each FH refers to the cellset that  is the intersection of the thread's cellset and the FieldHandler's  cellset. ","category":"page"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"Type of analysis Top level Each MAT Each FH Each thread Each cell\nDH CellBuffer - - - CellBuffer\nMDH Tuple - CellBuffer - CellBuffer\nThreaded, DH Vector - - CellBuffer CellBuffer\nThreaded, MDH Tuple - Vector CellBuffer CellBuffer\nMM, DH Dict{String} CellBuffer - - CellBuffer\nMM, MDH Dict{String} Tuple CellBuffer - CellBuffer\nMM, Threaded, DH Dict{String} Vector - CellBuffer CellBuffer\nMM, Threaded, MDH Dict{String} Tuple Vector CellBuffer CellBuffer","category":"page"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"Note that the lowest level above Each cell, is always also the CellBuffer, because one CellBuffer is shared between the cells that are being looped  over in the innermost loop. ","category":"page"},{"location":"datastructures/#State-variables","page":"Datastructures","title":"State variables","text":"","category":"section"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"SV is the datatype for one state variable. Normally,  this exists for each integration point, and the lowest level (what is passed into the element_routine!) is therefore a Vector{SV}, one SV per integration point. It's datastructure is unaffected by threading:  Each state entry belong to one cell so there are no race conditions. ","category":"page"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"Type of analysis Top level Each MAT Each FH Each cell\nDH Vector - - Vector{SV}\nMDH Tuple - Dict{Int} Vector{SV}\nMM, DH Dict{String} Dict{Int}  Vector{SV}\nMM, MDH Dict{String} Tuple Dict{Int} Vector{SV}","category":"page"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"On the level above Each cell, whether that is a Vector or Dict{Int},  the indexing always refers to the global cellid (which is why a Dict{Int} is  used when not all cells are included)","category":"page"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"In the case of one SV per cell (when create_states are called without a cellvalue),  the Each cell level becomes SV instead of Vector{SV} and the rest remain unchanged. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FerriteAssembly","category":"page"},{"location":"#FerriteAssembly","page":"Home","title":"FerriteAssembly","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The goal of FerriteAssembly  is to provide a simple structure for assembling in  Ferrite.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Sequential and threaded assembly when using either the DofHandler or the MixedDofHandler, including a possibility of mixed materials, is supported","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package works by exporting the doassemble! function, and requiring the  user to define either element_routine! (calculate both Ke and re), or just element_residual! (calculate only re).  In the latter case, Ke is calculated by  ForwardDiff.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dispatch element_routine!/element_residual! is typically based  on a user-defined material struct, and possibly also on cellvalues. For multiple fields, the latter can also be a NamedTuple/Tuple  (or any other type that supports Ferrite.reinit!). State variables (to be mutated) and current dof-values for the cell  are directly available in the element_routine!","category":"page"},{"location":"","page":"Home","title":"Home","text":"Old dof-values for the cell, user-defined cache and cell_load types,  cell coordinates and more are available through the CellBuffer type that is given as an additional input.","category":"page"},{"location":"#Heat-equation-example","page":"Home","title":"Heat equation example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Include the example here, but modify the Literate output to suit being embedded\nusing Literate, Markdown\nfilename = \"firstexample_literate\"\nLiterate.markdown(filename*\".jl\"; execute=true)\ncontents = read(filename*\".md\", String)\nLiterate.script(filename*\".jl\"; name=\"firstexample\")\nrm(filename*\".jl\")\nrm(filename*\".md\")\nheader_end = last(findnext(\"```\", contents, 4))+1\nMarkdown.parse(replace(contents[header_end:end], \n    \"*This page was generated using [Literate.jl]\"=>\"*The examples were generated using [Literate.jl]\")\n    )","category":"page"},{"location":"internals/#Internal-API","page":"Internals","title":"Internal API","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Note that the internal API may change without being considered a breaking change!","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"FerriteAssembly.assemble_cell!\nFerriteAssembly.inner_doassemble!\nFerriteAssembly.assemble_cell_reinited!\nFerriteAssembly._copydofs!\nFerriteAssembly._maketuple\nFerriteAssembly._makedict\nFerriteAssembly.reinit!\nFerriteAssembly.intersect_nothing\nFerriteAssembly._create_cell_state","category":"page"},{"location":"internals/#FerriteAssembly.assemble_cell!","page":"Internals","title":"FerriteAssembly.assemble_cell!","text":"assemble_cell!(assembler, cellbuffer, dh::DofHandler, cellnr, a, aold, state, Δt)\nassemble_cell!(assembler, cellbuffer, dh::MixedDofHandler, fh::FieldHandler, cellnr, a, aold, state, Δt)\n\nInternal function to that reinitializes the cellbuffer and calls assemble_cell_reinited!.\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly.inner_doassemble!","page":"Internals","title":"FerriteAssembly.inner_doassemble!","text":"inner_doassemble!(\n    assembler, cellbuffer::AbstractCellBuffer, states, \n    dh::MixedDofHandler, fh::FieldHandler, a, aold, Δt\n    )\n\nSequential assembly of cells corresponding to the given fh  from dh.fieldhandlers.  Internal function that is called from the sequential version  of doassemble! for the MixedDofHandler\n\n\n\n\n\ninner_doassemble!(\n    assemblers::Vector{<:Ferrite.AbstractSparseAssembler},\n    cellbuffers::Vector{<:AbstractCellBuffer}, states, \n    dh::MixedDofHandler, fh::FieldHandler, \n    colored_sets::Vector{Vector{Int}}, \n    a, aold, Δt, scalings::Vector;\n    )\n\nParallel assembly of cells corresponding to the given fh from  dh.fieldhandlers. Internal function that is called from the parallel version of  doassemble! for the MixedDofHandler\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly.assemble_cell_reinited!","page":"Internals","title":"FerriteAssembly.assemble_cell_reinited!","text":"assemble_cell_reinited!(assembler, cellbuffer, dh_fh::Union{DofHandler,FieldHandler}, state, Δt, scaling)\n\nInternal function that assembles the cell described by the reinitialized cellbuffer. This function is called  in all cases: Parallel or sequential and DofHandler or MixedDofHandler\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly._copydofs!","page":"Internals","title":"FerriteAssembly._copydofs!","text":"_copydofs!(edofs::Vector, gdofs::Vector, inds::Vector{Int})\n\nInternal function for faster copying of global values into the element values.  Equivalent to edofs .= gdofs[inds]\n\n_copydofs!(edofs::Vector, gdofs::Nothing, inds::Vector{Int})\n\nFill edofs with NaN\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly._maketuple","page":"Internals","title":"FerriteAssembly._maketuple","text":"_maketuple(t, n)\n\nIf t is a tuple, check that length(t)=n and return t.  Otherwise, return a tuple of length n with t as every element\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly._makedict","page":"Internals","title":"FerriteAssembly._makedict","text":"_makedict(d, d_keys)\n\nIf d::Dict then check that it has all keys in d_keys (if not throw KeyError). Otherwise, return a Dict with keys d_keys and d as every element\n\n\n\n\n\n","category":"function"},{"location":"internals/#Ferrite.reinit!","page":"Internals","title":"Ferrite.reinit!","text":"Ferrite.reinit!(c::CellBuffer, dh::AbstractDofHandler, cellnum::Int, anew, aold)\n\nReinitialize the c::CellBuffer for cell number cellnum. The global degree of freedom vectors anew (current) and aold are used to update the cell degree of freedom vectors in c. If the global vectors are instead ::Nothing, the corresponding cell values are set to NaN The element stiffness, c.Ke, and residual, c.re, are also zeroed. \n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly.intersect_nothing","page":"Internals","title":"FerriteAssembly.intersect_nothing","text":"intersect_nothing(a, b)\n\nA faster intersect if cellset::Nothing, otherwise calls Base.intersect\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly._create_cell_state","page":"Internals","title":"FerriteAssembly._create_cell_state","text":"_create_cell_state(cell, material, cellvalues, a, ae)\n\nInternal function to extract the relevant quantities from the  CellIterator, cell: Pass these into the  create_cell_state function that the user should specify. \n\n\n\n\n\n","category":"function"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"EditURL = \"https://github.com/KnutAM/FerriteAssembly.jl/blob/main/docs/src/literate/mixed_materials.jl\"","category":"page"},{"location":"examples/mixed_materials/#Multiple-materials","page":"Multiple materials","title":"Multiple materials","text":"","category":"section"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"This example shows how to use two different materials on a grid with the same cells everywhere. Hence, the only difference is the type of material and the state variables. We start by including the necessary packages, as well as the J2Plasticity.jl and MaterialModelsBaseElement.jl files from the previous example.","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"using Tensors, MaterialModelsBase, Ferrite, FerriteAssembly\ninclude(\"J2Plasticity.jl\");\ninclude(\"MaterialModelsBaseElement.jl\");\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"Then, we also define an elastic material","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"struct ElasticMaterial{T<:SymmetricTensor{4,3}} <: AbstractMaterial\n    D::T\nend\nfunction ElasticMaterial(;E, ν)\n    D, _, _ = elastic_conversion(E, ν)\n    return ElasticMaterial(D)\nend;\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"This material requires not state, so MaterialModelsBase.jl's NoMaterialState will be created by default. Hence, we only need to define the material_response","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"function MaterialModelsBase.material_response(\n    material::ElasticMaterial, ϵ::SymmetricTensor{2,3}, state,\n    Δt, cache=get_cache(material), args...; kwargs...)\n    σ = material.D ⊡ ϵ\n    return σ, material.D, NoMaterialState()\nend;\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"The same element_routine! as before can be used, defined in MaterialModelsBaseElement.jl. Hence, we just need to define the materials, grid, cellvalues etc.","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"materials = Dict(\n    \"elastic\" => ElasticMaterial(E=200.0e9, ν=0.3),\n    \"plastic\" => J2Plasticity(200.0e9, 0.3, 200.0e6, 10.0e9));\ngrid = generate_grid(Tetrahedron, (20,2,4), zero(Vec{3}), Vec((10.0,1.0,1.0)));\ncellvalues = CellVectorValues(\n    QuadratureRule{3,RefTetrahedron}(2), Lagrange{3, RefTetrahedron, 1}());\ndh = DofHandler(grid); add!(dh, :u, 3); close!(dh); # Create dofhandler\nK = create_sparsity_pattern(dh);\nr = zeros(ndofs(dh));\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"We then define the cellsets where with the same key as each material in materials","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"addcellset!(grid, \"elastic\", x -> x[1] <= 5.0+eps())\naddcellset!(grid, \"plastic\", setdiff(1:getncells(grid), getcellset(grid,\"elastic\")));\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"The create_states function will then create the correct datastructure for the states, (one Dict{Int} for each material)","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"states = create_states(dh, materials, cellvalues);\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"If desired, we can create a cache based on MaterialModelsBase, even though not used in this example (we could also skip passing this to setup_cellbuffer)","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"caches = Dict(key=>get_cache(mat) for (key,mat) in materials);\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"Then we create the cell buffers","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"buffers = setup_cellbuffer(dh, cellvalues, materials, nothing, caches);\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"And then we define the displacements and the assembler, before assembling","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"a = zeros(ndofs(dh))\nassembler = start_assemble(K, r)\ndoassemble!(assembler, buffers, states, dh, a);\n\nusing Test #hide\nK_ref = create_sparsity_pattern(dh); #hide\nr_ref = zeros(ndofs(dh)); #hide\nstates_ref = create_states(dh, materials[\"elastic\"], cellvalues); #hide\na_ref = zeros(ndofs(dh)) #hide\nassembler_ref = start_assemble(K_ref,r_ref) #hide\ndoassemble!(assembler_ref, buffers[\"elastic\"], states_ref, dh, a_ref); #hide\n@test K ≈ K_ref; #hide\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"This page was generated using Literate.jl.","category":"page"}]
}
