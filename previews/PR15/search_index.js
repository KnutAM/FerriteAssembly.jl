var documenterSearchIndex = {"docs":
[{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"EditURL = \"https://github.com/KnutAM/FerriteAssembly.jl/blob/main/docs/src/literate/plasticity.jl\"","category":"page"},{"location":"examples/plasticity/#Plasticity","page":"Plasticity","title":"Plasticity","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This example shows how any material following the MaterialModelsBase.jl interface can be assembled with FerriteAssembly.jl. element_routine! has already been implemented for this material. This example shows how to","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Assemble materials with state variables\nUpdate state variables for the next time step","category":"page"},{"location":"examples/plasticity/#Implementation","page":"Plasticity","title":"Implementation","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We start by the required packages","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"using Tensors, MaterialModelsBase, Ferrite, FerriteAssembly","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"And then we define the material_response for the plasticity material in J2Plasticity.jl, which is basically the same as in Ferrite.jl's plasticity example","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"include(\"J2Plasticity.jl\");\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Assembly","page":"Plasticity","title":"Assembly","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"With all required functions defined, we can now setup and assemble the finite element problem","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"material = J2Plasticity(200.0e9, 0.3, 200.0e6, 10.0e9);\ngrid = generate_grid(Tetrahedron, (20,2,4), zero(Vec{3}), Vec((10.0,1.0,1.0)));\ncellvalues = CellVectorValues(\n    QuadratureRule{3,RefTetrahedron}(2), Lagrange{3, RefTetrahedron, 1}());\ndh = DofHandler(grid); add!(dh, :u, 3); close!(dh); # Create dofhandler\nK = create_sparsity_pattern(dh);\nr = zeros(ndofs(dh));\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Using the setup_assembly function,","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"buffer, states_old, states_new = setup_assembly(dh, material, cellvalues)","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"we setup the buffer, old state variables, and new state variables. The state variables are created via the create_cell_state function that is already defined for MaterialModelsBase.AbstractMaterial","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We can now just provide an initial guess for the degree of freedom vector,a, and do the assembly","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"a = zeros(ndofs(dh))\ndoassemble!(K, r, states_new, states_old, buffer; a=a);\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"If we would have a rate-dependent material, such that the time increment mattered, we can also supply that (but that is not required in this example)","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"doassemble!(K, r, states_new, states_old, buffer; a=a, Δt=1.0);\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"In a full FE-program we iterate until convergence to find a. When converged, we go to the next time step, and would like to set the old state equal to the current state, which we can do by calling","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"update_states!(states_old, states_new)","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"If we would like to access the states in any cell, statesold and statesnew can be indexed with the cell number.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"ExampleElements/#Example-elements","page":"Example elements","title":"Example elements","text":"","category":"section"},{"location":"ExampleElements/","page":"Example elements","title":"Example elements","text":"The package includes a set of example elements inside the submodule FerriteAssembly.ExampleElements. In order to use these it is possible to import them explicitly as, e.g.,","category":"page"},{"location":"ExampleElements/","page":"Example elements","title":"Example elements","text":"import FerriteAssembly.ExampleElements: StationaryFourier","category":"page"},{"location":"ExampleElements/#Available-example-elements","page":"Example elements","title":"Available example elements","text":"","category":"section"},{"location":"ExampleElements/","page":"Example elements","title":"Example elements","text":"StationaryFourier\nTransientFourier\nElasticPlaneStrain\nPoroElasticPlaneStrain\nWeakForm","category":"page"},{"location":"ExampleElements/","page":"Example elements","title":"Example elements","text":"ExampleElements.StationaryFourier\nExampleElements.TransientFourier\nExampleElements.ElasticPlaneStrain\nExampleElements.PoroElasticPlaneStrain\nExampleElements.WeakForm","category":"page"},{"location":"ExampleElements/#FerriteAssembly.ExampleElements.StationaryFourier","page":"Example elements","title":"FerriteAssembly.ExampleElements.StationaryFourier","text":"StationaryFourier(k)\n\nFor solving stationary linear heat conduction (which uses Fourier's law) with conductivity k,  such that the heat flux is boldsymbolq=-k nabla T, where T is the temperature field. \n\nThe strong form is,\n\n nabla cdot boldsymbolq = h  quad textbfx in Omega\n\nand the corresponding weak form is \n\n   -int_Omega nabla delta T cdot boldsymbolq mathrmdOmega \n   = - int_Gamma delta T q_mathrmn mathrmdGamma \n     + int_Omega delta T h mathrmdOmega\n\nwhere, on the right hand side, q_mathrmn is a heat flux normal to the boundary Gamma, and h is a volumetric heat supply.  These contributions are not included in the element, and should be added with FerriteNeumann.jl\n\n\n\n\n\n","category":"type"},{"location":"ExampleElements/#FerriteAssembly.ExampleElements.TransientFourier","page":"Example elements","title":"FerriteAssembly.ExampleElements.TransientFourier","text":"TransientFourier(k, c)\n\nFor solving the transient linear heat equation (which uses Fourier's law) with conductivity k,  such that the heat flux is boldsymbolq=-k nabla T, where T is the temperature field. \n\nThe strong form is,\n\n    c dotT + nabla cdot boldsymbolq = h  quad textbfx in Omega\n\nand the corresponding time-discretized weak form is \n\n    int_Omega delta T c fracT - ^mathrmnTDelta t mathrmdOmega\n    - int_Omega nabla delta T cdot boldsymbolq mathrmdOmega \n   = - int_Gamma delta T q_mathrmn mathrmdGamma \n     + int_Omega delta T h mathrmdOmega\n\nwhere ^mathrmnT is the old temperature (in the previous timestep) and Delta t is the timestep.  On the right hand side, q_mathrmn is a heat flux normal to the boundary Gamma, and h is a volumetric heat supply.  These external contributions on the right hand side are not included in the element,  and should be added with FerriteNeumann.jl\n\n\n\n\n\n","category":"type"},{"location":"ExampleElements/#FerriteAssembly.ExampleElements.ElasticPlaneStrain","page":"Example elements","title":"FerriteAssembly.ExampleElements.ElasticPlaneStrain","text":"ElasticPlaneStrain(;E=2.e3, ν=0.3)\n\nFor solving linear elasticity for plane strain, where Young's modulus, E, and Poisson's ratio, ν, is used to construct the correct stiffness tensor, boldsymbolmathsfC,  such that the stress, boldsymbolsigma=boldsymbolmathsfCboldsymbolepsilon,  where the strain tensor, boldsymbolepsilon=boldsymboluotimesnabla^mathrmsym, is calculated from the displacement field, boldsymbolu(boldsymbolxt). \n\nThe strong form of the mechanical quasi-static equilibrium is\n\n    boldsymbolsigma cdot nabla + boldsymbolb = 0 quad textbfx in Omega\n\nwith the corresponding weak form, \n\n   int_Omega boldsymboldelta uotimesnabla^mathrmsym  boldsymbolsigma mathrmdOmega \n   = int_Gamma boldsymboldelta u cdot boldsymbolt mathrmdGamma \n   + int_Omega boldsymboldelta u cdot boldsymbolb mathrmdOmega\n\nThe external loading on the right hand side is not included in the element, but can be implemented  using FerriteNeumann.jl.  \n\n\n\n\n\n","category":"type"},{"location":"ExampleElements/#FerriteAssembly.ExampleElements.PoroElasticPlaneStrain","page":"Example elements","title":"FerriteAssembly.ExampleElements.PoroElasticPlaneStrain","text":"PoroElasticPlaneStrain(;E=2.e3, ν=0.3, k=0.05, α=1.0, β=1/2e3)\n\nThe strong forms are given as\n\nbeginaligned\nboldsymbolsigma(boldsymbolepsilon p) cdot boldsymbolnabla = boldsymbol0 \ndotPhi(boldsymbolepsilon p) + boldsymbolw(p) cdot boldsymbolnabla = 0\nendaligned\n\nwhere  boldsymbolepsilon = leftboldsymboluotimesboldsymbolnablaright^mathrmsym  The constitutive relationships are \n\nbeginaligned\nboldsymbolsigma = boldsymbolmathsfEboldsymbolepsilon - alpha p boldsymbolI \nboldsymbolw = - k boldsymbolnabla p \nPhi = phi + alpha mathrmtr(boldsymbolepsilon) + beta p\nendaligned\n\nwith  boldsymbolmathsfE=2G boldsymbolmathsfI^mathrmdev + 3K boldsymbolIotimesboldsymbolI. The material parameters are then the  shear modulus, G,  bulk modulus, K,  permeability, k,   Biot's coefficient, alpha, and liquid compressibility, beta. The porosity, phi, doesn't enter into the equations  (A different porosity leads to different skeleton stiffness and permeability).\n\nThe weak forms are\n\nbeginaligned\nint_Omega leftleftboldsymboldelta uotimesboldsymbolnablaright^mathrmsym\nboldsymbolmathsfEboldsymbolepsilon - boldsymboldelta u cdot boldsymbolnabla alpha pright mathrmdOmega \n= int_Gamma boldsymboldelta u cdot boldsymbolt mathrmd Gamma \nint_Omega leftdelta p leftalpha dotboldsymbolu cdot boldsymbolnabla + beta dotpright + \nboldsymbolnabla(delta p) cdot k boldsymbolnablaright mathrmdOmega \n= -int_Gamma delta p w_mathrmn mathrmd Gamma \nendaligned\n\nwhere boldsymbolt=boldsymbolncdotboldsymbolsigma is the traction and  w_mathrmn = boldsymbolncdotboldsymbolw is the normal flux.  \n\n\n\n\n\n","category":"type"},{"location":"ExampleElements/#FerriteAssembly.ExampleElements.WeakForm","page":"Example elements","title":"FerriteAssembly.ExampleElements.WeakForm","text":"WeakForm(f::Function)\n\nSolve the problem with primary variable, u, variation, delta u, and a weak form\n\n   int_Omega f(delta u delta u otimesnabla u u otimesnabla dotu dotu otimesnabla) mathrmdOmega \n   - int_Gamma delta u h(xtn) mathrmdGamma - int_Omega delta u b(xt) mathrmdOmega = 0\n\nwhere the function f is given to the weak form, and h and b are given with FerriteNeumann.\n\nnote: This element is intended for testing\nIt is not optimized for speed\n\nExamples\n\nTransient heat flow\n\nWeak form\n\n    int_Omega delta u c dotu + k nabla delta u cdot nabla u mathrmdOmega \n   + int_Gamma delta u q_mathrmn mathrmdGamma - int_Omega delta u b mathrmdOmega = 0\n\nImplementation This implementation is equivalent to TransientFourier, but it is also possible to add the body load directly in the weak form (if desired). \n\nc = 1.0; k = 1.0; # heat capacity and heat conductivity (material parameters)\nqn = 1.0; b=1.0;  # Normal boundary flux and internal heat source (external loading)\nmaterial = WeakForm((δu, ∇δu, u, ∇u, u_dot, ∇u_dot) -> δu*c*u_dot + k*(∇δu ⋅ ∇u))\nnh = NeumannHandler(dh)\nadd!(nh, Neumann(:u, 2, getfaceset(dh.grid, \"right\"), (x,t,n)->qn))\nadd!(nh, BodyLoad(:c, 1, (x,t)->b))\n\nLinear elasticity\n\nThis implementation is equivalent to ElasticPlaneStrain, but it is also possible to add the body load directly in the weak form (if desired).  Weak form\n\n   int_Omega boldsymboldelta uotimesnabla^mathrmsym  boldsymbolsigma mathrmdOmega \n   - int_Gamma boldsymboldelta u cdot boldsymbolt mathrmdGamma \n   - int_Omega boldsymboldelta u cdot boldsymbolb mathrmdOmega = 0\n\nImplementation\n\nG = 80e3; K = 160e3; # Shear and bulk modulus (material parameters)\ntn = 1.0, b=Vec((0.0, 0.0, -1.0)); # Normal traction and body force (external loading)\nmaterial = WeakForm((δu, ∇δu, u, ∇u, u_dot, ∇u_dot) -> (∇δu ⊡ (2*G*dev(symmetric(∇u)) + 3*K*vol(∇u))))\nnh = NeumannHandler(dh)\nadd!(nh, Neumann(:u, 2, getfaceset(dh.grid, \"right\"), (x,t,n)->tn*n))\nadd!(nh, BodyLoad(:c, 2, (x,t)->b))\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = FerriteAssembly","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Methods that should be overloaded and exported functions are described on this page. It may also be useful to checkout the Data structures.","category":"page"},{"location":"api/#Setting-up-and-doing-the-assembly","page":"API","title":"Setting up and doing the assembly","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AssemblyDomain\nsetup_assembly\ndoassemble!","category":"page"},{"location":"api/#FerriteAssembly.AssemblyDomain","page":"API","title":"FerriteAssembly.AssemblyDomain","text":"AssemblyDomain(name, dh, material, cellvalues; cellset, user_data=nothing, cache=nothing)\n\nCreate an AssemblyDomain that can be used when calling setup_assembly to assemble multiple domains. name is used to access the corresponding DomainBuffer and state variables returned by setup_assembly.  If not given, cellset is attempted to be inferred from the DofHandler, dh. \n\n\n\n\n\n","category":"type"},{"location":"api/#FerriteAssembly.setup_assembly","page":"API","title":"FerriteAssembly.setup_assembly","text":"setup_assembly(dh, material, cv_qr_quadorder; kwargs...)\n\nSetup assembly for a single domain (i.e. the same material and interpolations everywhere). Returns the buffer, old_states, and new_states to be used in doassemble!. The state variables are created by calling the user-defined create_cell_state function. \n\n\n\n\n\nsetup_assembly(domains::Vector{<:AssemblyDomain}; kwargs...)\n\nSetup assembly for each domain in domains.  Returns the Dicts buffers, old_states, and new_states to be used in doassemble!. The state variables are created by calling the user-defined create_cell_state function. \n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteAssembly.doassemble!","page":"API","title":"FerriteAssembly.doassemble!","text":"doassemble!([K::AbstractMatrix,] r::AbstractVector, new_states, old_states, buffer; kwargs...)\n\nAssemble K and r (element_residual must be defined to only assemble r), given the new_states, old_states, and buffer returned from setup_assembly. The available keyword arguments are \n\na=nothing: The current degree of freedom vector. If nothing, ae with NaN values is passed to element_routine!\naold=nothing: The old degree of freedom vector. If nothing, get_aeold(buffer) gives aNaN`-filled vector.\nΔt=NaN: The time increment that can be accessed as get_time_increment(buffer) in the element routines. \nfillzero=true: Should K and r be zeroed before starting the assembly?\n\n\n\n\n\n","category":"function"},{"location":"api/#Element-routines","page":"API","title":"Element routines","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"One of the element methods should be overloaded for a given combination of cellvalues and material.  Note that the cellvalues are already reinit!:ed when passed to the element routines. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"FerriteAssembly.element_routine!\nFerriteAssembly.element_residual!","category":"page"},{"location":"api/#FerriteAssembly.element_routine!","page":"API","title":"FerriteAssembly.element_routine!","text":"element_routine!(\n    Ke::AbstractMatrix, re::AbstractVector, state_new,\n    ae::AbstractVector, material, cellvalues, buffer)\n\nThe main function to be overloaded for the specific material. In most cases, the same implementation can be used for different cellvalues  (e.g. for different interpolation orders) This function should modify the element stiffness matrix Ke, the residual re, and potentially state_new. The element degree of freedom values, ae, are filled by  NaNs unless a is passed to doassemble!.\n\nThe following variables can be obtained from buffer.\n\nget_state_old(buffer)\nget_aeold(buffer)\nget_time_increment(buffer)\ndof_range(buffer, fieldname::Symbol)\ngetcoordinates(buffer)\ncelldofs(buffer)\ncellid(buffer)\nget_user_data(buffer)\nget_cache(buffer)\n\n\n\n\n\nFerriteAssembly.element_routine!(Ke, re, state, ae, m::MaterialModelsBase.AbstractMaterial, args...)\n\nSolve the weak form \n\n   int_Omega boldsymboldelta uotimesnabla^mathrmsym  boldsymbolsigma mathrmdOmega \n   = int_Gamma boldsymboldelta u cdot boldsymbolt mathrmdGamma \n   + int_Omega boldsymboldelta u cdot boldsymbolb mathrmdOmega\n\nwhere sigma is calculated with the material_response function from  MaterialModelsBase.jl.  Note that create_cell_state is already implemented for <:AbstractMaterial. \n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteAssembly.element_residual!","page":"API","title":"FerriteAssembly.element_residual!","text":"element_residual!(\n    re::AbstractVector, state_new,\n    ae::AbstractVector, material, cellvalues, buffer)\n\nTo calculate the element tangent stiffness Ke automatically by using ForwardDiff, it is possible to overload element_residual! instead of element_routine!. See  element_routine! for a description of the input parameters. \n\n!!! note MethodError with ForwardDiff.Dual     When using automatic differentiation for elements with state variables (or other mutating values in e.g. cache),     an error will be thrown if trying to change the type in many cases.      When mutating new_state, call ForwardDiff.value() on the value to be assigned after      it will no longer be used to calculate re. (If done on a value which is later affects re inside the element,     the tangent, Ke, will be wrong.)\n\n\n\n\n\n","category":"function"},{"location":"api/#State-variables","page":"API","title":"State variables","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The initial state variables may vary depending on the position in the grid. Furthermore, the datastructure depends on the type of dof handler, so a convenience function exists that creates the correct variable structure. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"FerriteAssembly.create_cell_state\nupdate_states!\nFerriteAssembly.create_states","category":"page"},{"location":"api/#FerriteAssembly.create_cell_state","page":"API","title":"FerriteAssembly.create_cell_state","text":"create_cell_state(material, cellvalues, x, ae, dofrange)\n\nDefaults to returning nothing.\n\nOverload this function to create the state which should be passed into the  element_routine!/element_residual! for the given material and cellvalues.  x is the cell's coordinates, ae the element degree of freedom values, and  dofrange::NamedTuple containing the local dof range for each field.  As for the element routines, ae, is filled with NaN unless the global degree  of freedom vector is given to the setup_assembly function.\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteAssembly.update_states!","page":"API","title":"FerriteAssembly.update_states!","text":"update_states!(old_states, new_states)\n\nUpdate old_states with the values from new_states. This is typically done after a converged time increment.\n\nThis method tries to avoid allocating new values where possible.  Currently, if create_cell_state returns T or Vector{T} where isbitstype(T), this works.\n\nIf needed/wanted, it should be relatively easy to provide an interface to make it possible to have allocation free  for custom cell states.\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteAssembly.create_states","page":"API","title":"FerriteAssembly.create_states","text":"create_states(sdh::SubDofHandler, material, cellvalues, a, cellset, dofrange)\n\nCreate a Dict of states for the cells in cellset, where the user should  define the create_cell_state function for their material (and corresponding cellvalues) dofrange::NamedTuple is passed onto create_cell_state and contains the local dof ranges for each field. \n\n\n\n\n\n","category":"function"},{"location":"api/#CellBuffer","page":"API","title":"CellBuffer","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Variables that are used and modified for each cell of a certain type,  but that don't belong to a specific cell, are collected in a CellBuffer.","category":"page"},{"location":"api/#Access-functions","page":"API","title":"Access functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following access functions can be used to extract information from the  CellBuffer","category":"page"},{"location":"api/","page":"API","title":"API","text":"get_state_old\nget_aeold\nget_time_increment\nFerrite.dof_range\nFerrite.getcoordinates\nFerrite.celldofs\nFerrite.cellid\nget_user_data\nget_cache","category":"page"},{"location":"api/#FerriteAssembly.get_state_old","page":"API","title":"FerriteAssembly.get_state_old","text":"get_state_old(c::CellBuffer)\n\nGet the state variables for the cell from the previous time step. \n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteAssembly.get_aeold","page":"API","title":"FerriteAssembly.get_aeold","text":"FerriteAssembly.get_aeold(c::CellBuffer)\n\nGet the old element dof-values for the current cell  (Filled by NaNs unless aold is passed to doassemble!)\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteAssembly.get_time_increment","page":"API","title":"FerriteAssembly.get_time_increment","text":"get_time_increment(c::CellBuffer)\n\nGet the time increment, Δt, that was passed to doassemble\n\n\n\n\n\n","category":"function"},{"location":"api/#Ferrite.dof_range","page":"API","title":"Ferrite.dof_range","text":"Ferrite.dof_range(c::CellBuffer, name::Symbol)\n\nGet the dofrange::UnitRange{Int} for the dofs pertaining to the field: name. Same output as dof_range(dh::DofHandler, name), but fully type-stable. \n\n\n\n\n\n","category":"function"},{"location":"api/#Ferrite.getcoordinates","page":"API","title":"Ferrite.getcoordinates","text":"Ferrite.getcoordinates(c::CellBuffer)\n\nFerrite.jl's getcoordinates function is overloaded on the CellBuffer to return  the current cell's nodal coordinates. \n\n\n\n\n\n","category":"function"},{"location":"api/#Ferrite.celldofs","page":"API","title":"Ferrite.celldofs","text":"Ferrite.celldofs(c::CellBuffer)\n\nFerrite.jl's celldofs function is overloaded on the CellBuffer to return  the current cell's degree of freedom indices.\n\n\n\n\n\n","category":"function"},{"location":"api/#Ferrite.cellid","page":"API","title":"Ferrite.cellid","text":"Ferrite.cellid(c::CellBuffer)\n\nGet the current cell id/nr\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteAssembly.get_user_data","page":"API","title":"FerriteAssembly.get_user_data","text":"FerriteAssembly.get_user_data(c::CellBuffer)\n\nGet the user specified user_data given to CellBuffer\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteAssembly.get_cache","page":"API","title":"FerriteAssembly.get_cache","text":"FerriteAssembly.get_cache(c::CellBuffer)\n\nGet the user-specified cache given to the CellBuffer\n\n\n\n\n\n","category":"function"},{"location":"api/#Residual-scaling","page":"API","title":"Residual scaling","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"There are many options for how to scale the residual in finite element simulations. This package does not intend to implement many different options, but does give the  user the option to calculate scaling contributions from each cell, which may be useful. By defining a scaling that is passed to doassemble!, this can be updated in each cell.  One type of scaling, ElementResidualScaling, is included as described below. Its code can be used as a template  for how to include custom scaling that works on the element level. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"In general, a scaling must support the update_scaling! function. For consistency it is also nice, but not required, to support reset_scaling!. This function must, however, be called by the user before assembly (to allow consistent separated assembly using different cellsets). ","category":"page"},{"location":"api/","page":"API","title":"API","text":"FerriteAssembly.update_scaling!\nreset_scaling!\nadd_to_scaling!","category":"page"},{"location":"api/#FerriteAssembly.update_scaling!","page":"API","title":"FerriteAssembly.update_scaling!","text":"update_scaling!(scaling, re, cellbuffer)\n\nThis function should add the contribution from the element residual vector re to the scaling factors in scaling.\n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteAssembly.reset_scaling!","page":"API","title":"FerriteAssembly.reset_scaling!","text":"reset_scaling!(scaling)\n\nThis function should reset the scaling factors, such that the values don't accumulate if used  in multiple iterations/time steps. \n\n\n\n\n\n","category":"function"},{"location":"api/#FerriteAssembly.add_to_scaling!","page":"API","title":"FerriteAssembly.add_to_scaling!","text":"add_to_scaling!(base_scaling, scaling)\n\nAdd the scaling values from scaling to base_scaling. This function is used after  threaded assembly to put all the scaling values together into the object initially sent to setup_assembly\n\n\n\n\n\n","category":"function"},{"location":"api/#ElementResidualScaling","page":"API","title":"ElementResidualScaling","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ElementResidualScaling","category":"page"},{"location":"api/#FerriteAssembly.ElementResidualScaling","page":"API","title":"FerriteAssembly.ElementResidualScaling","text":"ElementResidualScaling(dh::AbstractDofHandler, p=Val(2), T=Float64)\n\nCreate tolerance scaling based on the sum of the p-norm of each cell's residual vector,  separately for each field. I.e. pseudo-code for field :u the scaling factor::T is\n\nfor each cell\n    element_routine!(Ke, re, args...) # Calculate re\n    factor += sum(abs.(re[dof_range(dh, :u)]).^p)^(1/p)\n\nNote that p=Val(2) is a special case that is supported, for different values  it should be given as a Real. p=2 is equivalent to Val(2), but is less efficient. \n\n\n\n\n\n","category":"type"},{"location":"MaterialModelsBase/#MaterialModelsBase","page":"MaterialModelsBase.jl","title":"MaterialModelsBase","text":"","category":"section"},{"location":"MaterialModelsBase/","page":"MaterialModelsBase.jl","title":"MaterialModelsBase.jl","text":"If you have implemented your constitutive mechanical behavior following the  MaterialModelsBase.jl's API, FerriteAssembly.element_routine! and FerriteAssembly.create_cell_state  have already been implemented for this case. ","category":"page"},{"location":"MaterialModelsBase/","page":"MaterialModelsBase.jl","title":"MaterialModelsBase.jl","text":"FerriteAssembly.element_routine!(Ke, re, state::Vector{<:FerriteAssembly.MMB.AbstractMaterialState}, ae, material::FerriteAssembly.MMB.AbstractMaterial, cellvalues::CellVectorValues, dh_fh, Δt, cb)","category":"page"},{"location":"MaterialModelsBase/#FerriteAssembly.element_routine!-Tuple{Any, Any, Vector{<:MaterialModelsBase.AbstractMaterialState}, Any, MaterialModelsBase.AbstractMaterial, CellVectorValues, Any, Any, Any}","page":"MaterialModelsBase.jl","title":"FerriteAssembly.element_routine!","text":"element_routine!(\n    Ke::AbstractMatrix, re::AbstractVector, state_new,\n    ae::AbstractVector, material, cellvalues, buffer)\n\nThe main function to be overloaded for the specific material. In most cases, the same implementation can be used for different cellvalues  (e.g. for different interpolation orders) This function should modify the element stiffness matrix Ke, the residual re, and potentially state_new. The element degree of freedom values, ae, are filled by  NaNs unless a is passed to doassemble!.\n\nThe following variables can be obtained from buffer.\n\nget_state_old(buffer)\nget_aeold(buffer)\nget_time_increment(buffer)\ndof_range(buffer, fieldname::Symbol)\ngetcoordinates(buffer)\ncelldofs(buffer)\ncellid(buffer)\nget_user_data(buffer)\nget_cache(buffer)\n\n\n\n\n\n","category":"method"},{"location":"datastructures/#Data-structures","page":"Datastructures","title":"Data structures","text":"","category":"section"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"The assembly requires different datastructure, which also differ depending on  how the analysis is setup. An important feature of this package is that it provides a suggestion for how these structures can be organized to work in a range of cases.  While it is possible to use the package without knowing exactly how these are made,  it will make tracking down bugs easier and may be important for postprocessing.","category":"page"},{"location":"datastructures/#CellBuffer","page":"Datastructures","title":"CellBuffer","text":"","category":"section"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"All values passed into element_routine!, except the state variables,  dh_fh::Union{DofHandler,FieldHandler}, and time increment, are passed taken from the relevant CellBuffer.  (The cellbuffer itself is also passed into element_routine!.  By looking at the created CellBuffer, it is therefore clear what will  be passed into your element_routine!. ","category":"page"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"The following items deserve extra attention","category":"page"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"cellvalues: Can be either one CellValues (e.g CellVectorValues),  or a collection of these. This collection must be either a Tuple or  a NamedTuple for the reinitialization will work. If provided as a custom  type, just define Ferrite.reinit!(cv::MyCustomCellValueCollection, coords)\nmaterial: Represents the material to dispatch on for that specific element. \ncell_load: Is an additional custom user type, intended for defining source  terms or body loads. \ncache: A final custom user type, intended to store preallocated data  (e.g. for FE² simulations)","category":"page"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"Depending on the analysis, multiple CellBuffers may be created and  nested in various structures. These structures are explained in  the following table.  For brevity, the following abbrevations in type of analysis are used:  DH=DofHandler, MDH=MixedDofHandler with N fieldhandlers, and  MM = \"Multiple materials on the grid, not connected to each fieldhandler\"","category":"page"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"For the levels, Each X refers to the datastructure of CellBuffer for the cellset belonging to X, where X can be MAT (type of material),  thread, or FH (fieldhandler ::FieldHandler in MixedDofHandler). Note that on the lower level (closer to the cell), the cellset is always  reduced as the intersection between the higher level and the current.  I.e. for multithreaded cases, Each FH refers to the cellset that  is the intersection of the thread's cellset and the FieldHandler's  cellset. ","category":"page"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"Type of analysis Top level Each MAT Each FH Each thread Each cell\nDH CellBuffer - - - CellBuffer\nMDH Tuple - CellBuffer - CellBuffer\nThreaded, DH Vector - - CellBuffer CellBuffer\nThreaded, MDH Tuple - Vector CellBuffer CellBuffer\nMM, DH Dict{String} CellBuffer - - CellBuffer\nMM, MDH Dict{String} Tuple CellBuffer - CellBuffer\nMM, Threaded, DH Dict{String} Vector - CellBuffer CellBuffer\nMM, Threaded, MDH Dict{String} Tuple Vector CellBuffer CellBuffer","category":"page"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"Note that the lowest level above Each cell, is always also the CellBuffer, because one CellBuffer is shared between the cells that are being looped  over in the innermost loop. ","category":"page"},{"location":"datastructures/#State-variables","page":"Datastructures","title":"State variables","text":"","category":"section"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"SV is the datatype for one state variable. Normally,  this exists for each integration point, and the lowest level (what is passed into the element_routine!) is therefore a Vector{SV}, one SV per integration point. It's datastructure is unaffected by threading:  Each state entry belong to one cell so there are no race conditions. ","category":"page"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"Type of analysis Top level Each MAT Each FH Each cell\nDH Vector - - Vector{SV}\nMDH Tuple - Dict{Int} Vector{SV}\nMM, DH Dict{String} Dict{Int}  Vector{SV}\nMM, MDH Dict{String} Tuple Dict{Int} Vector{SV}","category":"page"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"On the level above Each cell, whether that is a Vector or Dict{Int},  the indexing always refers to the global cellid (which is why a Dict{Int} is  used when not all cells are included)","category":"page"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"In the case of one SV per cell (when create_states are called without a cellvalue),  the Each cell level becomes SV instead of Vector{SV} and the rest remain unchanged. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FerriteAssembly","category":"page"},{"location":"#FerriteAssembly","page":"Home","title":"FerriteAssembly","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The goal of FerriteAssembly  is to provide a simple structure for assembling in  Ferrite.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Sequential and threaded assembly when using either the DofHandler or the MixedDofHandler, including a possibility of mixed materials, is supported","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package works by exporting the doassemble! function, and requiring the  user to define either element_routine! (calculate both Ke and re), or just element_residual! (calculate only re).  In the latter case, Ke is calculated by  ForwardDiff.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dispatch element_routine!/element_residual! is typically based  on a user-defined material struct, and possibly also on cellvalues. For multiple fields, the latter can also be a NamedTuple/Tuple  (or any other type that supports Ferrite.reinit!). State variables (to be mutated) and current dof-values for the cell  are directly available in the element_routine!","category":"page"},{"location":"","page":"Home","title":"Home","text":"Old dof-values for the cell, user-defined cache and cell_load types,  cell coordinates and more are available through the CellBuffer type that is given as an additional input.","category":"page"},{"location":"#Heat-equation-example","page":"Home","title":"Heat equation example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Include the example here, but modify the Literate output to suit being embedded\nusing Literate, Markdown\nfilename = \"firstexample_literate\"\nLiterate.markdown(filename*\".jl\"; execute=true)\ncontents = read(filename*\".md\", String)\nLiterate.script(filename*\".jl\"; name=\"firstexample\")\nrm(filename*\".jl\")\nrm(filename*\".md\")\nheader_end = last(findnext(\"```\", contents, 4))+1\nMarkdown.parse(replace(contents[header_end:end], \n    \"*This page was generated using [Literate.jl]\"=>\"*The examples were generated using [Literate.jl]\")\n    )","category":"page"},{"location":"internals/#Internal-API","page":"Internals","title":"Internal API","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Note that the internal API may change without being considered a breaking change!","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"FerriteAssembly.assemble_cell!\nFerriteAssembly.assemble_cell_reinited!\nFerriteAssembly._copydofs!\nFerriteAssembly.reinit!\nFerriteAssembly._create_cell_state\nFerriteAssembly.CellBuffer\nFerriteAssembly.AutoDiffCellBuffer\nFerriteAssembly.fast_getindex","category":"page"},{"location":"internals/#FerriteAssembly.assemble_cell!","page":"Internals","title":"FerriteAssembly.assemble_cell!","text":"assemble_cell!(assembler, cellbuffer, dh::DofHandler, cellnr, a, aold, state, Δt)\nassemble_cell!(assembler, cellbuffer, dh::MixedDofHandler, fh::FieldHandler, cellnr, a, aold, state, Δt)\n\nInternal function to that reinitializes the cellbuffer and calls assemble_cell_reinited!.\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly.assemble_cell_reinited!","page":"Internals","title":"FerriteAssembly.assemble_cell_reinited!","text":"assemble_cell_reinited!(assembler, cellbuffer, state, scaling)\n\nInternal function that assembles the cell described by the reinitialized cellbuffer.\n\n\n\n\n\nassemble_cell_reinited!(assembler, cellbuffer, state, scaling)\n\nInternal function that assembles the residual for the cell described by the reinitialized cellbuffer.\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly._copydofs!","page":"Internals","title":"FerriteAssembly._copydofs!","text":"_copydofs!(edofs::Vector, gdofs::Vector, inds::Vector{Int})\n\nInternal function for faster copying of global values into the element values.  Equivalent to edofs .= gdofs[inds]\n\n_copydofs!(edofs::Vector, gdofs::Nothing, inds::Vector{Int})\n\nFill edofs with NaN\n\n\n\n\n\n","category":"function"},{"location":"internals/#Ferrite.reinit!","page":"Internals","title":"Ferrite.reinit!","text":"Ferrite.reinit!(c::CellBuffer, dh::AbstractDofHandler, cellnum::Int, anew, aold)\n\nReinitialize the c::CellBuffer for cell number cellnum. The global degree of freedom vectors anew (current) and aold are used to update the cell degree of freedom vectors in c. If the global vectors are instead ::Nothing, the corresponding cell values are set to NaN The element stiffness, c.Ke, and residual, c.re, are also zeroed. \n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly._create_cell_state","page":"Internals","title":"FerriteAssembly._create_cell_state","text":"_create_cell_state(cell, material, cellvalues, a, ae, dofrange, cellnr)\n\nInternal function to reinit and extract the relevant quantities from the  cell::CellCache, reinit cellvalues, update ae from a, and  pass these into the create_cell_state function that the user should specify. \n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly.CellBuffer","page":"Internals","title":"FerriteAssembly.CellBuffer","text":"CellBuffer(\n    numdofs::Int, numnodes::Int, ::Val{sdim}, \n    cellvalues, material, cell_load=nothing, cache=nothing) -> CellBuffer\n\nCreate a cell cache for an element with numdofs degrees of freedom and numnodes nodes with dimension sdim. cellvalues are reinit!ed for each cell, and the state is updated to the  old cell state. material will be passed as-is to the element.  The given dofrange::NamedTuple, user_data::Any, and cache::Any are available to the element via the buffer input. \n\nnote: See [`setup_assembly`](@ref)\nThis constructor is normally not used, and is instead called from setup_assembly\n\n\n\n\n\n","category":"type"},{"location":"internals/#FerriteAssembly.AutoDiffCellBuffer","page":"Internals","title":"FerriteAssembly.AutoDiffCellBuffer","text":"AutoDiffCellBuffer(cb::CellBuffer)\n\n\n\n\n\n","category":"type"},{"location":"internals/#FerriteAssembly.fast_getindex","page":"Internals","title":"FerriteAssembly.fast_getindex","text":"fast_getindex(collection)\n\nIf the output is known from the element type of the collection, this can be returned  directly. Currently, this is implemented for AbstractDict with Nothing as type, which takes away overhead when state variables are not used. \n\n\n\n\n\n","category":"function"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"EditURL = \"https://github.com/KnutAM/FerriteAssembly.jl/blob/main/docs/src/literate/mixed_materials.jl\"","category":"page"},{"location":"examples/mixed_materials/#Multiple-materials","page":"Multiple materials","title":"Multiple materials","text":"","category":"section"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"This example shows how to use two different materials on a grid with the same cells everywhere.","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"To do this, we use the ElasticMaterial defined at the end of the J2Plasticity.jl file.","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"using Tensors, MaterialModelsBase, Ferrite, FerriteAssembly\ninclude(\"J2Plasticity.jl\");\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"We start by setting up the","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"grid = generate_grid(Tetrahedron, (20,2,4), zero(Vec{3}), Vec((10.0,1.0,1.0)));\ncellvalues = CellVectorValues(\n    QuadratureRule{3,RefTetrahedron}(2), Lagrange{3, RefTetrahedron, 1}());\ndh = DofHandler(grid); add!(dh, :u, 3); close!(dh); # Create dofhandler\nK = create_sparsity_pattern(dh);\nr = zeros(ndofs(dh));\na = zeros(ndofs(dh))","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"In order to setup a simulation with multiple domains, we must use the AssemblyDomain structure to setup the simulation. We start by creating the elastic domain,","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"addcellset!(grid, \"elastic\", x -> x[1] <= 5.0+eps())\nelastic_material = ElasticMaterial(E=200.0e9, ν=0.3)\nelastic_domain = AssemblyDomain(\"elast\", dh, elastic_material, cellvalues; cellset=getcellset(grid, \"elastic\"));\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"And then create the plastic domain","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"plastic_cellset = setdiff(1:getncells(grid), getcellset(grid,\"elastic\"))\nplastic_material = J2Plasticity(200.0e9, 0.3, 200.0e6, 10.0e9)\nplastic_domain = AssemblyDomain(\"plast\", dh, plastic_material, cellvalues; cellset=plastic_cellset);\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"We can then setup the assembly, and in this case we would like to do the assembly threaded, so we need to color the domain.","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"colors = create_coloring(grid);\nbuffers, states_old, states_new = setup_assembly([elastic_domain, plastic_domain]; colors=colors);\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"In this case, buffers, states_old, and states_new are Dict{String} with keys according to the names given to each AssemblyDomain. This is important for postprocessing, but for doing assembly, these can be passed directly:","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"doassemble!(K, r, states_new, states_old, buffers, a=a);\n\nusing Test #hide\nK_ref = create_sparsity_pattern(dh) #hide\nr_ref = zeros(ndofs(dh)) #hide\na_ref = zeros(ndofs(dh)) #hide\nbuffer, states_old, states_new = setup_assembly(dh, elastic_material, cellvalues) #hide\ndoassemble!(K_ref, r_ref, states_old, states_new, buffer; a=a_ref) #hide\n@test K ≈ K_ref;    #hide\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"This page was generated using Literate.jl.","category":"page"}]
}
