var documenterSearchIndex = {"docs":
[{"location":"hack_api/","page":"Hacking API","title":"Hacking API","text":"CurrentModule = FerriteAssembly","category":"page"},{"location":"hack_api/#Hacking-API","page":"Hacking API","title":"Hacking API","text":"","category":"section"},{"location":"hack_api/","page":"Hacking API","title":"Hacking API","text":"The functions described on this page are somewhere inbetween regular API and internal API, and are intended for making custom solutions, but with a higher risk of breaking changes. Breaking changes to these interfaces should still be followed by a version bump.","category":"page"},{"location":"hack_api/#TaskLocals-API-(task-local-storage)","page":"Hacking API","title":"TaskLocals API (task local storage)","text":"","category":"section"},{"location":"hack_api/","page":"Hacking API","title":"Hacking API","text":"During multithreaded assembly, each task needs its own storage with values that it can change. This can be both cache variables (whose values don't matter after the task completes) or  other values that are part of the result from the assembly procedure. To do this in a structured way, the TaskLocals type and associated interface is used for all these cases in the package, but the user should never \"see\" this type directly (but it can be embedded in types seen by the user, such as ThreadedDomainBuffer). Specifically, a so-called scatter-gather approach is emulated,  even though the memory is shared, allowing this to be simplified. ","category":"page"},{"location":"hack_api/","page":"Hacking API","title":"Hacking API","text":"FerriteAssembly.TaskLocals\nFerriteAssembly.create_local\nFerriteAssembly.scatter!\nFerriteAssembly.gather!\nFerriteAssembly.get_local\nFerriteAssembly.get_base","category":"page"},{"location":"hack_api/#FerriteAssembly.TaskLocals","page":"Hacking API","title":"FerriteAssembly.TaskLocals","text":"TaskLocals(base; num_tasks=Threads.nthreads())\n\nTaskLocals is used to store a base value and a vector, locals.  Items in locals are for each task and can be obtained with get_local. base can be obtained with get_base.\n\nA base-type that supports the TaskLocals API should define the following functions\n\ncreate_local\nscatter!(local, base)\ngather!(base, local)\n\n\n\n\n\n","category":"type"},{"location":"hack_api/#FerriteAssembly.create_local","page":"Hacking API","title":"FerriteAssembly.create_local","text":"create_local(base::TB)\n\nCreate a task local variable, local::TL. In many cases, TL=TB. local's state should match that after calling gather!(base, local)  (reset local) followed by scatter!(local, base) (add info from base) (This is important, because it allows create_local to be called while working with  tasks, if more locals are needed)\n\n\n\n\n\n","category":"function"},{"location":"hack_api/#FerriteAssembly.scatter!","page":"Hacking API","title":"FerriteAssembly.scatter!","text":"scatter!(local, base)\n\nWrite any information from base required to be forwarded to  the local::typeof(create_local(base)). (typically if something in base have changed since its creation)\n\n\n\n\n\n","category":"function"},{"location":"hack_api/#FerriteAssembly.gather!","page":"Hacking API","title":"FerriteAssembly.gather!","text":"gather!(base, local)\n\nTake any information from local::typeof(create_local(base)) that should  be added to base after an assembly.  In addition, any accumulative information in local should  be reset, such that running scatter! -> \"do work\" -> gather! should  only affect the values in base. \n\n\n\n\n\n","category":"function"},{"location":"hack_api/#FerriteAssembly.get_local","page":"Hacking API","title":"FerriteAssembly.get_local","text":"get_local(tl::TaskLocals, i::Int)\n\nGet the ith local variable from tl\n\n\n\n\n\n","category":"function"},{"location":"hack_api/#FerriteAssembly.get_base","page":"Hacking API","title":"FerriteAssembly.get_base","text":"get_base(tl::TaskLocals)\n\nGet the base variable from tl\n\n\n\n\n\n","category":"function"},{"location":"hack_api/#Assembler-interface","page":"Hacking API","title":"Assembler interface","text":"","category":"section"},{"location":"hack_api/","page":"Hacking API","title":"Hacking API","text":"Different types of assemblers can be created in addition to those already defined by the package. The interface for creating an assembler is that the assembler must support the TaskLocals API,  as well as the method,  FerriteAssembly.assemble_cell_reinited!(assembler, cell_state, buffer::AbstractCellBuffer), where cell_state is the output from create_cell_state.  The following methods for builtin assemblers can be used as examples","category":"page"},{"location":"hack_api/","page":"Hacking API","title":"Hacking API","text":"FerriteAssembly.assemble_cell_reinited!","category":"page"},{"location":"hack_api/#FerriteAssembly.assemble_cell_reinited!","page":"Hacking API","title":"FerriteAssembly.assemble_cell_reinited!","text":"assemble_cell_reinited!(assembler::Ferrite.AbstractSparseAssembler, cell_state, cellbuffer)\n\nCalculate the local element stiffness, Ke, and the local residual, re, with element_routine! for the cell described by the reinitialized cellbuffer. Assemble these into the global matrix and vector in assembler. \n\n\n\n\n\nassemble_cell_reinited!(assembler::ReAssembler, cell_state, cellbuffer)\n\nCalculate the local residual, re, with element_residual! for the cell described  by the reinitialized cellbuffer. Assemble re into the global vector in assembler.  In addition, ReAssembler supports the extra option\n\nResidual scaling factor, e.g. ElementResidualScaling\n\n\n\n\n\nassemble_cell_reinited!(assembler::KeReAssembler, cell_state, cellbuffer)\n\nCalculate the local element stiffness, Ke, and the local residual, re, with element_routine! for the cell described by the reinitialized cellbuffer. Assemble these into the global matrix and vector in assembler.  In addition, KeReAssembler supports the extra options\n\nLocal application of constraints: Ferrite.apply_assemble!\nResidual scaling factor, e.g. ElementResidualScaling\n\n\n\n\n\n","category":"function"},{"location":"hack_api/","page":"Hacking API","title":"Hacking API","text":"In addition, the following functions are used to determine properties/requirements for the assembler. ","category":"page"},{"location":"hack_api/","page":"Hacking API","title":"Hacking API","text":"can_thread(assembler)::Bool: Is multithreading supported, if false, sequential assembly will run even if the user has set up multithreaded assembly with setup_assembly. If not defined, defaults to false. \nneeds_colors(assembler)::Bool: Indicate whether the assembler needs to run in colored mode or not, defaults to true. (Currently not used, all multithreading runs colored, but may be changed.)\nskip_this_domain(assembler, name::String)::Bool: Should the domain with name (given to AssemblyDomain) be skipped (currently used by the integrators to allow integrating only part of the domain). Defaults to false. ","category":"page"},{"location":"hack_api/#Custom-scaling","page":"Hacking API","title":"Custom scaling","text":"","category":"section"},{"location":"hack_api/","page":"Hacking API","title":"Hacking API","text":"In general, a scaling must, in addition to the TaskLocals API,  support the following functions","category":"page"},{"location":"hack_api/","page":"Hacking API","title":"Hacking API","text":"FerriteAssembly.update_scaling!\nFerriteAssembly.reset_scaling!","category":"page"},{"location":"hack_api/#FerriteAssembly.update_scaling!","page":"Hacking API","title":"FerriteAssembly.update_scaling!","text":"update_scaling!(scaling, re, cellbuffer)\n\nThis function should add the contribution from the element residual vector re to the scaling factors in scaling.\n\n\n\n\n\n","category":"function"},{"location":"hack_api/#FerriteAssembly.reset_scaling!","page":"Hacking API","title":"FerriteAssembly.reset_scaling!","text":"reset_scaling!(scaling)\n\nThis function should reset the scaling factors, such that the values don't accumulate if used  in multiple iterations/time steps. \n\n\n\n\n\n","category":"function"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"EditURL = \"https://github.com/KnutAM/FerriteAssembly.jl/blob/main/docs/src/literate/mixed_materials.jl\"","category":"page"},{"location":"examples/mixed_materials/#Multiple-materials","page":"Multiple materials","title":"Multiple materials","text":"","category":"section"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"How to assemble with different materials on different parts of the grid\nSpecifically, how to","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"Setup multiple AssemblyDomains\nRun threaded assembly","category":"page"},{"location":"examples/mixed_materials/#Material-modeling","page":"Multiple materials","title":"Material modeling","text":"","category":"section"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"In addition to J2Plasticity, we setup a portion of the domain to use the ElasticMaterial that is also defined in J2Plasticity.jl file.","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"using Tensors, MaterialModelsBase, Ferrite, FerriteAssembly\ninclude(\"J2Plasticity.jl\");\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/#Standard-Ferrite.jl-setup","page":"Multiple materials","title":"Standard Ferrite.jl setup","text":"","category":"section"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"We start by setting up the","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"grid = generate_grid(Tetrahedron, (20,2,4), zero(Vec{3}), Vec((10.0,1.0,1.0)))\ncellvalues = CellVectorValues(\n    QuadratureRule{3,RefTetrahedron}(2), Lagrange{3, RefTetrahedron, 1}())\ndh = DofHandler(grid); add!(dh, :u, 3); close!(dh) # Create dofhandler\nK = create_sparsity_pattern(dh)\nr = zeros(ndofs(dh))\na = zeros(ndofs(dh));\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/#Setting-up-AssemblyDomains","page":"Multiple materials","title":"Setting up AssemblyDomains","text":"","category":"section"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"In order to setup a simulation with multiple domains, we must use the AssemblyDomain structure to setup the simulation. We start by creating the elastic domain,","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"addcellset!(grid, \"elastic\", x -> x[1] <= 5.0+eps())\ncellset_el = getcellset(grid, \"elastic\")\nmaterial_el = ElasticMaterial(E=200.0e9, ν=0.3)\ndomain_el = AssemblyDomain(\"elast\", dh, material_el, cellvalues; cellset=cellset_el);\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"followed by the plastic domain","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"cellset_pl = setdiff(1:getncells(grid), cellset_el)\nmaterial_pl = J2Plasticity(200.0e9, 0.3, 200.0e6, 10.0e9)\ndomain_pl = AssemblyDomain(\"plast\", dh, material_pl, cellvalues; cellset=cellset_pl);\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"And then we can set up the assembly, where threading=true makes it multithreaded.","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"buffers, new_states, old_states = setup_assembly([domain_el, domain_pl]; threading=true);\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"For multiple domains, buffers, old_states, and new_states are Dict{String} with keys according to the names given to each AssemblyDomain.","category":"page"},{"location":"examples/mixed_materials/#Doing-the-assembly","page":"Multiple materials","title":"Doing the assembly","text":"","category":"section"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"The structure of buffers, old_states, and new_states is important for postprocessing, but these are passed directly for doing assembly:","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"assembler = start_assemble(K, r)\ndoassemble!(assembler, new_states, buffers; a=a, old_states=old_states);\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/#Updating-state-variables","page":"Multiple materials","title":"Updating state variables","text":"","category":"section"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"Updating the state variables after convergence in the current time step works as for single domains,","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"update_states!(old_states, new_states);\n\nusing Test #hide\nK_ref = create_sparsity_pattern(dh) #hide\nr_ref = zeros(ndofs(dh)) #hide\na_ref = zeros(ndofs(dh)) #hide\nbuffer, new_states, old_states = setup_assembly(dh, material_el, cellvalues) #hide\nassembler_ref = start_assemble(K_ref, r_ref)\ndoassemble!(assembler_ref, new_states, buffer; a=a_ref, old_states=old_states) #hide\n@test K ≈ K_ref    #hide\nnothing;           #hide\nnothing #hide","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"","category":"page"},{"location":"examples/mixed_materials/","page":"Multiple materials","title":"Multiple materials","text":"This page was generated using Literate.jl.","category":"page"},{"location":"UserAPI/ResidualScaling/#Residual-scaling","page":"Residual scaling","title":"Residual scaling","text":"","category":"section"},{"location":"UserAPI/ResidualScaling/","page":"Residual scaling","title":"Residual scaling","text":"There are many options for how to scale the residual in finite element simulations. This package does not intend to implement many different options, but does give the  user the option to calculate scaling contributions from each cell, which may be useful. By defining a scaling that is passed to setup_assembly, it can be updated  based on the output from each cell. ","category":"page"},{"location":"UserAPI/ResidualScaling/","page":"Residual scaling","title":"Residual scaling","text":"One type of scaling, ElementResidualScaling, is included as described below. Its code can be used as a template for how to include custom scaling that works on  the element level.","category":"page"},{"location":"UserAPI/ResidualScaling/#ElementResidualScaling","page":"Residual scaling","title":"ElementResidualScaling","text":"","category":"section"},{"location":"UserAPI/ResidualScaling/","page":"Residual scaling","title":"Residual scaling","text":"ElementResidualScaling","category":"page"},{"location":"UserAPI/ResidualScaling/#FerriteAssembly.ElementResidualScaling","page":"Residual scaling","title":"FerriteAssembly.ElementResidualScaling","text":"ElementResidualScaling(dh::AbstractDofHandler, p=Val(2), T=Float64)\n\nCreate tolerance scaling based on the sum of the p-norm of each cell's residual vector,  separately for each field. I.e. pseudo-code for field :u the scaling factor::T is\n\nfor each cell\n    element_routine!(Ke, re, args...) # Calculate re\n    factor += sum(abs.(re[dof_range(dh, :u)]).^p)^(1/p)\n\nNote that p=Val(2) is a special case that is supported, for different values  it should be given as a Real. p=2 is equivalent to Val(2), but is less efficient. \n\n\n\n\n\n","category":"type"},{"location":"UserAPI/StateVariables/#State-variables","page":"State variables","title":"State variables","text":"","category":"section"},{"location":"UserAPI/StateVariables/","page":"State variables","title":"State variables","text":"The state variable for a given cell is determined by the material type, via  overloading the create_cell_state function. To update old states to the new states, use update_states!.","category":"page"},{"location":"UserAPI/StateVariables/","page":"State variables","title":"State variables","text":"FerriteAssembly.create_cell_state(args...)\nupdate_states!","category":"page"},{"location":"UserAPI/StateVariables/#FerriteAssembly.create_cell_state-Tuple","page":"State variables","title":"FerriteAssembly.create_cell_state","text":"create_cell_state(material, cellvalues, x, ae, dofrange)\n\nDefaults to returning nothing.\n\nOverload this function to create the state which should be passed into the  element_routine!/element_residual! for the given material and cellvalues.  x is the cell's coordinates, ae the element degree of freedom values, and  dofrange::NamedTuple containing the local dof range for each field.  As for the element routines, ae, is filled with NaN unless the global degree  of freedom vector is given to the setup_assembly function.\n\n\n\n\n\n","category":"method"},{"location":"UserAPI/StateVariables/#FerriteAssembly.update_states!","page":"State variables","title":"FerriteAssembly.update_states!","text":"update_states!(old_states, new_states)\n\nUpdate old_states with the values from new_states. This is typically done after a converged time increment.\n\nThis method tries to avoid allocating new values where possible.  Currently, if create_cell_state returns T or Vector{T} where isbitstype(T), this works.\n\nIf needed/wanted, it should be relatively easy to provide an interface to make it possible to have allocation free  for custom cell states.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Internal-API","page":"Internals","title":"Internal API","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Note that the internal API may change without being considered a breaking change!","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"FerriteAssembly.create_states\nFerriteAssembly.assemble_cell!\nFerriteAssembly._copydofs!\nFerriteAssembly.reinit!\nFerriteAssembly._create_cell_state\nFerriteAssembly.CellBuffer\nFerriteAssembly.AutoDiffCellBuffer\nFerriteAssembly.fast_getindex","category":"page"},{"location":"internals/#FerriteAssembly.create_states","page":"Internals","title":"FerriteAssembly.create_states","text":"create_states(sdh::SubDofHandler, material, cellvalues, a, cellset, dofrange)\n\nCreate a Dict of states for the cells in cellset, where the user should  define the create_cell_state function for their material (and corresponding cellvalues) dofrange::NamedTuple is passed onto create_cell_state and contains the local dof ranges for each field. \n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly.assemble_cell!","page":"Internals","title":"FerriteAssembly.assemble_cell!","text":"assemble_cell!(assembler, new_states, cellbuffer, sdh::SubDofHandler, cellnr, a, aold, old_states)\n\nInternal function to that reinitializes the cellbuffer and calls assemble_cell_reinited!.\n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly._copydofs!","page":"Internals","title":"FerriteAssembly._copydofs!","text":"_copydofs!(edofs::Vector, gdofs::Vector, inds::Vector{Int})\n\nInternal function for faster copying of global values into the element values.  Equivalent to edofs .= gdofs[inds]\n\n_copydofs!(edofs::Vector, gdofs::Nothing, inds::Vector{Int})\n\nFill edofs with NaN\n\n\n\n\n\n","category":"function"},{"location":"internals/#Ferrite.reinit!","page":"Internals","title":"Ferrite.reinit!","text":"Ferrite.reinit!(c::CellBuffer, dh::AbstractDofHandler, cellnum::Int, anew, aold)\n\nReinitialize the c::CellBuffer for cell number cellnum. The global degree of freedom vectors anew (current) and aold are used to update the cell degree of freedom vectors in c. If the global vectors are instead ::Nothing, the corresponding cell values are set to NaN The element stiffness, c.Ke, and residual, c.re, are also zeroed. \n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly._create_cell_state","page":"Internals","title":"FerriteAssembly._create_cell_state","text":"_create_cell_state(cell, material, cellvalues, a, ae, dofrange, cellnr)\n\nInternal function to reinit and extract the relevant quantities from the  cell::CellCache, reinit cellvalues, update ae from a, and  pass these into the create_cell_state function that the user should specify. \n\n\n\n\n\n","category":"function"},{"location":"internals/#FerriteAssembly.CellBuffer","page":"Internals","title":"FerriteAssembly.CellBuffer","text":"CellBuffer(\n    numdofs::Int, numnodes::Int, ::Val{sdim}, \n    cellvalues, material, cell_load=nothing, cache=nothing) -> CellBuffer\n\nCreate a cell cache for an element with numdofs degrees of freedom and numnodes nodes with dimension sdim. cellvalues are reinit!ed for each cell, and the state is updated to the  old cell state. material will be passed as-is to the element.  The given dofrange::NamedTuple, user_data::Any, and cache::Any are available to the element via the buffer input. \n\nnote: See setup_assembly\nThis constructor is normally not used, and is instead called from setup_assembly\n\n\n\n\n\n","category":"type"},{"location":"internals/#FerriteAssembly.AutoDiffCellBuffer","page":"Internals","title":"FerriteAssembly.AutoDiffCellBuffer","text":"AutoDiffCellBuffer(cb::CellBuffer)\n\n\n\n\n\n","category":"type"},{"location":"internals/#FerriteAssembly.fast_getindex","page":"Internals","title":"FerriteAssembly.fast_getindex","text":"fast_getindex(collection)\n\nIf the output is known from the element type of the collection, this can be returned  directly. Currently, this is implemented for AbstractDict with Nothing as type, which takes away overhead when state variables are not used. \n\n\n\n\n\n","category":"function"},{"location":"UserAPI/Assemblers/#Assemblers","page":"Assemblers","title":"Assemblers","text":"","category":"section"},{"location":"UserAPI/Assemblers/","page":"Assemblers","title":"Assemblers","text":"The assembly process runs by calling doassemble! with a given assembler.  There are currently two categories of assemblers implemented, which are used to calculate","category":"page"},{"location":"UserAPI/Assemblers/","page":"Assemblers","title":"Assemblers","text":"System matrices and vectors\nThe integral of a function","category":"page"},{"location":"UserAPI/Assemblers/","page":"Assemblers","title":"Assemblers","text":"doassemble!","category":"page"},{"location":"UserAPI/Assemblers/#FerriteAssembly.doassemble!","page":"Assemblers","title":"FerriteAssembly.doassemble!","text":"doassemble!(\n    assembler, new_states::Dict{Int}, buffer::AbstractDomainBuffer; \n    a=nothing, aold=nothing, old_states=nothing, Δt=NaN)\n\nUse assembler to assemble a single domain described by buffer, and update new_states if dictated by the assembler. \n\ndoassemble!(\n    assembler, new_states::Dict{String}, buffers::Dict{String,AbstractDomainBuffer}; \n    a=nothing, aold=nothing, old_states=nothing, Δt=NaN)\n\nUse assembler to assemble the domains described by buffers, and update new_states if dictated by the assembler.\n\nThe keyword arguments work as follows:\n\na, aold: Global degree of freedom vectors. If nothing, NaN values are passed to the element routine.\nold_states: Old state variables. If nothing, get_old_state  will always return the initial state. \nΔt: The value returned by get_time_increment\n\n\n\n\n\n","category":"function"},{"location":"UserAPI/Assemblers/#System-matrix-and-vector","page":"Assemblers","title":"System matrix and vector","text":"","category":"section"},{"location":"UserAPI/Assemblers/","page":"Assemblers","title":"Assemblers","text":"In order to assemble the system matrices and residual vectors, it is necessary to define the appropriate  element routine and choose an assembler. The following assemblers can be used to assemble the system matrix and vector:","category":"page"},{"location":"UserAPI/Assemblers/","page":"Assemblers","title":"Assemblers","text":"Ferrite.start_assemble that returns\nFerrite.AssemblerSparsityPattern\nFerrite.AssemblerSymmetricSparsityPattern\nKeReAssembler\nReAssembler","category":"page"},{"location":"UserAPI/Assemblers/","page":"Assemblers","title":"Assemblers","text":"Where the ones available in FerriteAssembly have additional features,  such as the possibility of applying constraints locally (see Ferrite.apply_assemble) or calculate scaling for the residual. ","category":"page"},{"location":"UserAPI/Assemblers/#Element-routines","page":"Assemblers","title":"Element routines","text":"","category":"section"},{"location":"UserAPI/Assemblers/","page":"Assemblers","title":"Assemblers","text":"One of the element methods should be overloaded for material.  Note that cellvalues are already reinit!:ed for the current cell.","category":"page"},{"location":"UserAPI/Assemblers/","page":"Assemblers","title":"Assemblers","text":"FerriteAssembly.element_routine!(args...)\nFerriteAssembly.element_residual!","category":"page"},{"location":"UserAPI/Assemblers/#FerriteAssembly.element_routine!-Tuple","page":"Assemblers","title":"FerriteAssembly.element_routine!","text":"element_routine!(\n    Ke::AbstractMatrix, re::AbstractVector, state_new,\n    ae::AbstractVector, material, cellvalues, buffer)\n\nThe main function to be overloaded for the specific material. In most cases, the same implementation can be used for different cellvalues  (e.g. for different interpolation orders) This function should modify the element stiffness matrix Ke, the residual re, and potentially state_new. The element degree of freedom values, ae, are filled by  NaNs unless a is passed to doassemble!.\n\nThe following variables can be obtained from buffer.\n\nget_old_state(buffer)\nget_aeold(buffer)\nget_time_increment(buffer)\ndof_range(buffer, fieldname::Symbol)\ngetcoordinates(buffer)\ncelldofs(buffer)\ncellid(buffer)\nget_user_data(buffer)\nget_cache(buffer)\n\n\n\n\n\n","category":"method"},{"location":"UserAPI/Assemblers/#FerriteAssembly.element_residual!","page":"Assemblers","title":"FerriteAssembly.element_residual!","text":"element_residual!(\n    re::AbstractVector, state_new,\n    ae::AbstractVector, material, cellvalues, buffer)\n\nTo calculate the element tangent stiffness Ke automatically by using ForwardDiff, it is possible to overload element_residual! instead of element_routine!. See  element_routine! for a description of the input parameters. \n\nnote: Note\nMethodError with ForwardDiff.Dual\nWhen using automatic differentiation for elements with state variables (or other mutating values in e.g. cache), an error will be thrown if trying to change the type in many cases.  When mutating new_state, call ForwardDiff.value() on the value to be assigned after  it will no longer be used to calculate re. (If done on a value which is later affects re inside the element, the tangent, Ke, will be wrong.)\n\n\n\n\n\n","category":"function"},{"location":"UserAPI/Assemblers/#Assemblers-2","page":"Assemblers","title":"Assemblers","text":"","category":"section"},{"location":"UserAPI/Assemblers/","page":"Assemblers","title":"Assemblers","text":"KeReAssembler\nReAssembler","category":"page"},{"location":"UserAPI/Assemblers/#FerriteAssembly.KeReAssembler","page":"Assemblers","title":"FerriteAssembly.KeReAssembler","text":"KeReAssembler(K, r; fillzero=true, kwargs...)\nKeReAssembler(a::Ferrite.AbstractSparseAssembler; kwargs...)\n\nThe default KeReAssembler works just like a Ferrite.AbstractSparseAssembler: It will call element_routine! and assemble Ke and re into the global system  matrix K and vector r. However, it comes with the additional possible features, that are controllable via the keyword arguments:\n\nch::Union{Nothing,ConstraintHandler}=nothing: If a ConstraintHandler is given, local applications of constraints will be applied, using Ferrite.apply_assemble.\napply_zero: Required if a constraint handler is given, and forwarded to Ferrite.apply_assemble. \nscaling: Calculate a scaling measure locally at the residual level, see e.g.,  ElementResidualScaling\n\na=Ferrite.start_assemble(K, r; fillzero=fillzero) is passed to the second definition  if a matrix, K, and vector, r, are given as input.\n\n\n\n\n\n","category":"type"},{"location":"UserAPI/Assemblers/#FerriteAssembly.ReAssembler","page":"Assemblers","title":"FerriteAssembly.ReAssembler","text":"ReAssembler(r; fillzero=true, scaling=NoScaling())\n\nReAssembler will call element_residual! and assemble re into the system  vector r. fillzero=true implies that r is zeroed upon construction of  ReAssembler. Furthermore, remaining keyword arguments can enable the following  features:\n\nscaling: Calculate a scaling measure locally at the residual level, see e.g.,  ElementResidualScaling\n\n\n\n\n\n","category":"type"},{"location":"UserAPI/Assemblers/#Integration","page":"Assemblers","title":"Integration","text":"","category":"section"},{"location":"UserAPI/Assemblers/","page":"Assemblers","title":"Assemblers","text":"In addition to assembling system matrices and vectors, much of the internal code can be reused  to create quite efficient integration of values, given a solution vector (and potentially state variables) The general workflow assumes that setup_assembly has already been called, and that a solution  vector is available. Then, it is possible to call doassemble! with an integrator to  obtain the integrated value. The following integrators are implemented","category":"page"},{"location":"UserAPI/Assemblers/","page":"Assemblers","title":"Assemblers","text":"SimpleIntegrator\nIntegrator\nFerriteAssembly.integrate_cell!","category":"page"},{"location":"UserAPI/Assemblers/#FerriteAssembly.SimpleIntegrator","page":"Assemblers","title":"FerriteAssembly.SimpleIntegrator","text":"SimpleIntegrator(fun::Function, val)\n\nCalculate the integral\n\nint_Omega f(u nabla u s) mathrmdOmega \n\nFor single-field problems, the function signature of f is fun(u, ∇u, qp_state). u is the current function value, ∇u the current function gradient, and qp_state the  current state in the current quadrature point. This assumes that cell_state::AbstractVector,  otherwise, qp_state = cell_state.  \n\nFor multi-field problem, we have fun(u::NamedTuple, ∇u::NamedTuple, qp_state),  where the keys in u and ∇u are the fieldnames. The rest is same as for single-field  problems. \n\nIt is the user's responsibility that fun(args...)::typeof(val).  Additionally, the type of val must support\n\nval + val\nval * x (where x::Real)\nzero(val)\n\nOne exception to these requirements; val::Tuple,  if the elements of the tuple fulfills those requirements.\n\nSpecify domains to only integrate over a part of the grid. It should contain the names of the AssemblyDomains to integrate over. Single, String, or collections; Set{String}, AbstractVector{String}, or NTuple{N,String} inputs are supported. If domains=nothing, all domains are integrated. \n\nExample: Calculate the average value and gradient \nWe assume that we have done the setup: buffer, state = setup_assembly(...),\nassembled K and r, and solved a=K\\r\n\nintegrator = SimpleIntegrator((u, ∇u, state)->(1.0, u, ∇u), (0.0, 0.0, zero(Vec{dim})))\ndoassemble!(integrator, states, buffer; a=a)\narea = integrator.val[1]\nu_avg = integrator.val[2]/area \n∇u_avg = integrator.val[3]/area\n\nIf the buffer is setup to be threaded, this calculation will also be threaded. \n\n\n\n\n\n","category":"type"},{"location":"UserAPI/Assemblers/#FerriteAssembly.Integrator","page":"Assemblers","title":"FerriteAssembly.Integrator","text":"Integrator(val::V; domains=nothing)\n\nIntegrate over the domain by modifying the value val for each cell in the function  integrate_cell, which should be overloaded for the specific combination of val::V  and the material for that cell. V must be a mutable type.\n\nSpecify domains to only integrate over a part of the grid. It should contain the names of the AssemblyDomains to integrate over. Single, String, or collections; Set{String}, AbstractVector{String}, or NTuple{N,String} inputs are supported. If domains=nothing, all domains are integrated. \n\nNote: This integrator will currently only run sequentially even if a  threaded assembly is setup with setup_assembly\n\n\n\n\n\n","category":"type"},{"location":"UserAPI/Assemblers/#FerriteAssembly.integrate_cell!","page":"Assemblers","title":"FerriteAssembly.integrate_cell!","text":"integrate_cell!(val, cell_state, ae, material, cv, cellbuffer)\n\nFunction to be overloaded for val (potentially in combination with material), and will be called when using Integrator. Mutate val to add to the result.\n\nThe order of the inputs is chosen to follow the element routines\n\n\n\n\n\n","category":"function"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"EditURL = \"https://github.com/KnutAM/FerriteAssembly.jl/blob/main/docs/src/literate/plasticity.jl\"","category":"page"},{"location":"examples/plasticity/#Plasticity","page":"Plasticity","title":"Plasticity","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This example shows how to assemble a plastic material following the MaterialModelsBase.jl interface with FerriteAssembly.jl. The element_routine! function implementation for any MaterialModelsBase.AbstractMaterial is already defined. \\\nSpecifically, how to","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Assemble materials with state variables\nGiving the time increment for rate dependent elements\nUpdate state variables for the next time step","category":"page"},{"location":"examples/plasticity/#Material-modeling","page":"Plasticity","title":"Material modeling","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We start by the required packages","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"using Tensors, MaterialModelsBase, Ferrite, FerriteAssembly","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"And then we define the material_response for the plasticity material in J2Plasticity.jl, which is basically the same as in Ferrite.jl's plasticity example","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"include(\"J2Plasticity.jl\");\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Standard-Ferrite.jl-setup","page":"Plasticity","title":"Standard Ferrite.jl setup","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"With all required functions defined, we can now setup and assemble the finite element problem","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"material = J2Plasticity(200.0e9, 0.3, 200.0e6, 10.0e9);\ngrid = generate_grid(Tetrahedron, (20,2,4), zero(Vec{3}), Vec((10.0,1.0,1.0)));\ncellvalues = CellVectorValues(\n    QuadratureRule{3,RefTetrahedron}(2), Lagrange{3, RefTetrahedron, 1}());\ndh = DofHandler(grid); add!(dh, :u, 3); close!(dh); # Create dofhandler\nK = create_sparsity_pattern(dh);\nr = zeros(ndofs(dh));\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Setting-up-the-assembly","page":"Plasticity","title":"Setting up the assembly","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Using the setup_assembly function,","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"buffer, new_states, old_states = setup_assembly(dh, material, cellvalues);\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"we setup the buffer, old state variables, and new state variables. The state variables are created via the create_cell_state function that is already defined for MaterialModelsBase.AbstractMaterial","category":"page"},{"location":"examples/plasticity/#Doing-the-assembly","page":"Plasticity","title":"Doing the assembly","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We can now just provide an initial guess for the degree of freedom vector,a, and do the assembly","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"a = zeros(ndofs(dh))\nassembler = start_assemble(K, r)\ndoassemble!(assembler, new_states, buffer; a=a, old_states=old_states);\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"If we would have a rate-dependent material, such that the time increment mattered, we can also supply that (but that is not required in this example)","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"assembler = start_assemble(K, r)\ndoassemble!(assembler, new_states, buffer; a=a, old_states=old_states, Δt=1.0);\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Updating-state-variables","page":"Plasticity","title":"Updating state variables","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"In a full FE-program we iterate until convergence to find a. When converged, we go to the next time step, and would like to set the old state equal to the current state, which we can do by calling","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"update_states!(old_states, new_states);\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"If we would like to access the states in any cell, oldstates and newstates can be indexed with the cell number.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"ExampleElements/#Example-elements","page":"Example elements","title":"Example elements","text":"","category":"section"},{"location":"ExampleElements/","page":"Example elements","title":"Example elements","text":"The package includes a set of example elements inside the submodule FerriteAssembly.ExampleElements. In order to use these it is possible to import them explicitly as, e.g.,","category":"page"},{"location":"ExampleElements/","page":"Example elements","title":"Example elements","text":"import FerriteAssembly.ExampleElements: StationaryFourier","category":"page"},{"location":"ExampleElements/#Available-example-elements","page":"Example elements","title":"Available example elements","text":"","category":"section"},{"location":"ExampleElements/","page":"Example elements","title":"Example elements","text":"StationaryFourier\nTransientFourier\nElasticPlaneStrain\nPoroElasticPlaneStrain\nWeakForm","category":"page"},{"location":"ExampleElements/","page":"Example elements","title":"Example elements","text":"ExampleElements.StationaryFourier\nExampleElements.TransientFourier\nExampleElements.ElasticPlaneStrain\nExampleElements.PoroElasticPlaneStrain\nExampleElements.WeakForm","category":"page"},{"location":"ExampleElements/#FerriteAssembly.ExampleElements.StationaryFourier","page":"Example elements","title":"FerriteAssembly.ExampleElements.StationaryFourier","text":"StationaryFourier(k)\n\nFor solving stationary linear heat conduction (which uses Fourier's law) with conductivity k,  such that the heat flux is boldsymbolq=-k nabla T, where T is the temperature field. \n\nThe strong form is,\n\n nabla cdot boldsymbolq = h  quad textbfx in Omega\n\nand the corresponding weak form is \n\n   -int_Omega nabla delta T cdot boldsymbolq mathrmdOmega \n   = - int_Gamma delta T q_mathrmn mathrmdGamma \n     + int_Omega delta T h mathrmdOmega\n\nwhere, on the right hand side, q_mathrmn is a heat flux normal to the boundary Gamma, and h is a volumetric heat supply.  These contributions are not included in the element, and should be added with FerriteNeumann.jl\n\n\n\n\n\n","category":"type"},{"location":"ExampleElements/#FerriteAssembly.ExampleElements.TransientFourier","page":"Example elements","title":"FerriteAssembly.ExampleElements.TransientFourier","text":"TransientFourier(k, c)\n\nFor solving the transient linear heat equation (which uses Fourier's law) with conductivity k,  such that the heat flux is boldsymbolq=-k nabla T, where T is the temperature field. \n\nThe strong form is,\n\n    c dotT + nabla cdot boldsymbolq = h  quad textbfx in Omega\n\nand the corresponding time-discretized weak form is \n\n    int_Omega delta T c fracT - ^mathrmnTDelta t mathrmdOmega\n    - int_Omega nabla delta T cdot boldsymbolq mathrmdOmega \n   = - int_Gamma delta T q_mathrmn mathrmdGamma \n     + int_Omega delta T h mathrmdOmega\n\nwhere ^mathrmnT is the old temperature (in the previous timestep) and Delta t is the timestep.  On the right hand side, q_mathrmn is a heat flux normal to the boundary Gamma, and h is a volumetric heat supply.  These external contributions on the right hand side are not included in the element,  and should be added with FerriteNeumann.jl\n\n\n\n\n\n","category":"type"},{"location":"ExampleElements/#FerriteAssembly.ExampleElements.ElasticPlaneStrain","page":"Example elements","title":"FerriteAssembly.ExampleElements.ElasticPlaneStrain","text":"ElasticPlaneStrain(;E=2.e3, ν=0.3)\n\nFor solving linear elasticity for plane strain, where Young's modulus, E, and Poisson's ratio, ν, is used to construct the correct stiffness tensor, boldsymbolmathsfC,  such that the stress, boldsymbolsigma=boldsymbolmathsfCboldsymbolepsilon,  where the strain tensor, boldsymbolepsilon=boldsymboluotimesnabla^mathrmsym, is calculated from the displacement field, boldsymbolu(boldsymbolxt). \n\nThe strong form of the mechanical quasi-static equilibrium is\n\n    boldsymbolsigma cdot nabla + boldsymbolb = 0 quad textbfx in Omega\n\nwith the corresponding weak form, \n\n   int_Omega boldsymboldelta uotimesnabla^mathrmsym  boldsymbolsigma mathrmdOmega \n   = int_Gamma boldsymboldelta u cdot boldsymbolt mathrmdGamma \n   + int_Omega boldsymboldelta u cdot boldsymbolb mathrmdOmega\n\nThe external loading on the right hand side is not included in the element, but can be implemented  using FerriteNeumann.jl.  \n\n\n\n\n\n","category":"type"},{"location":"ExampleElements/#FerriteAssembly.ExampleElements.PoroElasticPlaneStrain","page":"Example elements","title":"FerriteAssembly.ExampleElements.PoroElasticPlaneStrain","text":"PoroElasticPlaneStrain(;E=2.e3, ν=0.3, k=0.05, α=1.0, β=1/2e3)\n\nThe strong forms are given as\n\nbeginaligned\nboldsymbolsigma(boldsymbolepsilon p) cdot boldsymbolnabla = boldsymbol0 \ndotPhi(boldsymbolepsilon p) + boldsymbolw(p) cdot boldsymbolnabla = 0\nendaligned\n\nwhere  boldsymbolepsilon = leftboldsymboluotimesboldsymbolnablaright^mathrmsym  The constitutive relationships are \n\nbeginaligned\nboldsymbolsigma = boldsymbolmathsfEboldsymbolepsilon - alpha p boldsymbolI \nboldsymbolw = - k boldsymbolnabla p \nPhi = phi + alpha mathrmtr(boldsymbolepsilon) + beta p\nendaligned\n\nwith  boldsymbolmathsfE=2G boldsymbolmathsfI^mathrmdev + 3K boldsymbolIotimesboldsymbolI. The material parameters are then the  shear modulus, G,  bulk modulus, K,  permeability, k,   Biot's coefficient, alpha, and liquid compressibility, beta. The porosity, phi, doesn't enter into the equations  (A different porosity leads to different skeleton stiffness and permeability).\n\nThe weak forms are\n\nbeginaligned\nint_Omega leftleftboldsymboldelta uotimesboldsymbolnablaright^mathrmsym\nboldsymbolmathsfEboldsymbolepsilon - boldsymboldelta u cdot boldsymbolnabla alpha pright mathrmdOmega \n= int_Gamma boldsymboldelta u cdot boldsymbolt mathrmd Gamma \nint_Omega leftdelta p leftalpha dotboldsymbolu cdot boldsymbolnabla + beta dotpright + \nboldsymbolnabla(delta p) cdot k boldsymbolnablaright mathrmdOmega \n= -int_Gamma delta p w_mathrmn mathrmd Gamma \nendaligned\n\nwhere boldsymbolt=boldsymbolncdotboldsymbolsigma is the traction and  w_mathrmn = boldsymbolncdotboldsymbolw is the normal flux.  \n\n\n\n\n\n","category":"type"},{"location":"ExampleElements/#FerriteAssembly.ExampleElements.WeakForm","page":"Example elements","title":"FerriteAssembly.ExampleElements.WeakForm","text":"WeakForm(f::Function)\n\nSolve the problem with primary variable, u, variation, delta u, and a weak form\n\n   int_Omega f(delta u delta u otimesnabla u u otimesnabla dotu dotu otimesnabla) mathrmdOmega \n   - int_Gamma delta u h(xtn) mathrmdGamma - int_Omega delta u b(xt) mathrmdOmega = 0\n\nwhere the function f is given to the weak form, and h and b are given with FerriteNeumann.\n\nnote: This element is intended for testing\nIt is not optimized for speed\n\nExamples\n\nTransient heat flow\n\nWeak form\n\n    int_Omega delta u c dotu + k nabla delta u cdot nabla u mathrmdOmega \n   + int_Gamma delta u q_mathrmn mathrmdGamma - int_Omega delta u b mathrmdOmega = 0\n\nImplementation This implementation is equivalent to TransientFourier, but it is also possible to add the body load directly in the weak form (if desired). \n\nc = 1.0; k = 1.0; # heat capacity and heat conductivity (material parameters)\nqn = 1.0; b=1.0;  # Normal boundary flux and internal heat source (external loading)\nmaterial = WeakForm((δu, ∇δu, u, ∇u, u_dot, ∇u_dot) -> δu*c*u_dot + k*(∇δu ⋅ ∇u))\nnh = NeumannHandler(dh)\nadd!(nh, Neumann(:u, 2, getfaceset(dh.grid, \"right\"), (x,t,n)->qn))\nadd!(nh, BodyLoad(:c, 1, (x,t)->b))\n\nLinear elasticity\n\nThis implementation is equivalent to ElasticPlaneStrain, but it is also possible to add the body load directly in the weak form (if desired).  Weak form\n\n   int_Omega boldsymboldelta uotimesnabla^mathrmsym  boldsymbolsigma mathrmdOmega \n   - int_Gamma boldsymboldelta u cdot boldsymbolt mathrmdGamma \n   - int_Omega boldsymboldelta u cdot boldsymbolb mathrmdOmega = 0\n\nImplementation\n\nG = 80e3; K = 160e3; # Shear and bulk modulus (material parameters)\ntn = 1.0, b=Vec((0.0, 0.0, -1.0)); # Normal traction and body force (external loading)\nmaterial = WeakForm((δu, ∇δu, u, ∇u, u_dot, ∇u_dot) -> (∇δu ⊡ (2*G*dev(symmetric(∇u)) + 3*K*vol(∇u))))\nnh = NeumannHandler(dh)\nadd!(nh, Neumann(:u, 2, getfaceset(dh.grid, \"right\"), (x,t,n)->tn*n))\nadd!(nh, BodyLoad(:c, 2, (x,t)->b))\n\n\n\n\n\n","category":"type"},{"location":"UserAPI/CellBuffer/","page":"CellBuffer","title":"CellBuffer","text":"CurrentModule = FerriteAssembly","category":"page"},{"location":"UserAPI/CellBuffer/#CellBuffer","page":"CellBuffer","title":"CellBuffer","text":"","category":"section"},{"location":"UserAPI/CellBuffer/","page":"CellBuffer","title":"CellBuffer","text":"Variables that are used and modified for each cell of a certain type,  but that don't belong to a specific cell, are collected in a CellBuffer.","category":"page"},{"location":"UserAPI/CellBuffer/","page":"CellBuffer","title":"CellBuffer","text":"Note that construction of CellBuffer happens automatically when calling setup_assembly, and to include cache or user_data, these  should be passed to setup_assembly (or AssemblyDomain).","category":"page"},{"location":"UserAPI/CellBuffer/#Access-functions","page":"CellBuffer","title":"Access functions","text":"","category":"section"},{"location":"UserAPI/CellBuffer/","page":"CellBuffer","title":"CellBuffer","text":"The following access functions can be used to extract information from  an AbstractCellBuffer.","category":"page"},{"location":"UserAPI/CellBuffer/","page":"CellBuffer","title":"CellBuffer","text":"get_old_state\nget_aeold\nget_time_increment\nFerrite.dof_range\nFerrite.getcoordinates\nFerrite.celldofs\nFerrite.cellid\nget_user_data\nget_cache","category":"page"},{"location":"UserAPI/CellBuffer/#FerriteAssembly.get_old_state","page":"CellBuffer","title":"FerriteAssembly.get_old_state","text":"get_old_state(c::CellBuffer)\n\nGet the state variables for the cell from the previous time step. \n\nnote: Note\nIf no old_state keyword is passed to doassemble!, this variable  will not be updated for the given cell, and typically contains the  initial cell state. \n\n\n\n\n\n","category":"function"},{"location":"UserAPI/CellBuffer/#FerriteAssembly.get_aeold","page":"CellBuffer","title":"FerriteAssembly.get_aeold","text":"FerriteAssembly.get_aeold(c::CellBuffer)\n\nGet the old element dof-values for the current cell  (Filled by NaNs unless aold is passed to doassemble!)\n\n\n\n\n\n","category":"function"},{"location":"UserAPI/CellBuffer/#FerriteAssembly.get_time_increment","page":"CellBuffer","title":"FerriteAssembly.get_time_increment","text":"get_time_increment(c::CellBuffer)\n\nGet the time increment, Δt, that was passed to doassemble (defaults to NaN)\n\n\n\n\n\n","category":"function"},{"location":"UserAPI/CellBuffer/#Ferrite.dof_range","page":"CellBuffer","title":"Ferrite.dof_range","text":"Ferrite.dof_range(c::CellBuffer, name::Symbol)\n\nGet the dofrange::UnitRange{Int} for the dofs pertaining to the field: name. Same output as dof_range(dh::DofHandler, name), but fully type-stable. \n\n\n\n\n\n","category":"function"},{"location":"UserAPI/CellBuffer/#Ferrite.getcoordinates","page":"CellBuffer","title":"Ferrite.getcoordinates","text":"Ferrite.getcoordinates(c::CellBuffer)\n\nFerrite.jl's getcoordinates function is overloaded on the CellBuffer to return  the current cell's nodal coordinates. \n\n\n\n\n\n","category":"function"},{"location":"UserAPI/CellBuffer/#Ferrite.celldofs","page":"CellBuffer","title":"Ferrite.celldofs","text":"Ferrite.celldofs(c::CellBuffer)\n\nFerrite.jl's celldofs function is overloaded on the CellBuffer to return  the current cell's degree of freedom indices.\n\n\n\n\n\n","category":"function"},{"location":"UserAPI/CellBuffer/#Ferrite.cellid","page":"CellBuffer","title":"Ferrite.cellid","text":"Ferrite.cellid(c::CellBuffer)\n\nGet the current cell id/nr\n\n\n\n\n\n","category":"function"},{"location":"UserAPI/CellBuffer/#FerriteAssembly.get_user_data","page":"CellBuffer","title":"FerriteAssembly.get_user_data","text":"FerriteAssembly.get_user_data(c::CellBuffer)\n\nGet the user specified user_data given to CellBuffer\n\n\n\n\n\n","category":"function"},{"location":"UserAPI/CellBuffer/#FerriteAssembly.get_cache","page":"CellBuffer","title":"FerriteAssembly.get_cache","text":"FerriteAssembly.get_cache(c::CellBuffer)\n\nGet the user-specified cache given to the CellBuffer\n\n\n\n\n\n","category":"function"},{"location":"UserAPI/Setup/#Setup","page":"Setup","title":"Setup","text":"","category":"section"},{"location":"UserAPI/Setup/","page":"Setup","title":"Setup","text":"To setup the assembly, call setup_assembly\nFor multiple domains, AssemblyDomains must be created first.","category":"page"},{"location":"UserAPI/Setup/","page":"Setup","title":"Setup","text":"setup_assembly\nAssemblyDomain","category":"page"},{"location":"UserAPI/Setup/#FerriteAssembly.setup_assembly","page":"Setup","title":"FerriteAssembly.setup_assembly","text":"setup_assembly(dh, material, cellvalues; kwargs...)\n\nSetup assembly for a single domain (i.e. the same material and interpolations everywhere). Returns the buffer, old_states, and new_states to be used in doassemble!. The state variables are created by calling the user-defined create_cell_state function.  Available keyword arguments\n\na=nothing: Give the global dof vector to pass element dofs, ae, to create_cell_state (NaN-values otherwise)\nthreaded=Val(false): Set to Val(true) to setup threaded assembly. More elaborate settings may be added in the future. \nautodiffbuffer=Val(false): Set to true or Val(true) (for type stable construction) to use AutoDiffCellBuffer instead of CellBuffer.\nuser_data=nothing: The user_data is passed to each AbstractCellBuffer by reference (when threaded)\ncache=nothing: The cache is passed to each AbstractCellBuffer, and deepcopied if threaded. \ncolors=nothing: Give colors for the grid from Ferrite.create_coloring to setup threaded colored assembly.  If nothing, Ferrite's default coloring algorithm is used.\ncellset=\"all cells in dh\": Which cells to assemble. In most cases, it is better to setup AssemblyDomains  to assemble different domains. But this option can be used to assemble only a subset of the grid.\n\n\n\n\n\nsetup_assembly(domains::Vector{<:AssemblyDomain}; kwargs...)\n\nSetup assembly for each AssemblyDomain in domains.  Returns the Dicts buffers, old_states, and new_states to be used in doassemble!. The state variables are created by calling the user-defined create_cell_state function.  Available keyword arguments\n\na=nothing: Give the global dof vector to pass element dofs, ae, to create_cell_state (NaN-values otherwise)\nautodiffbuffer=Val(false): Set to true or Val(true) (for type stable construction) to use AutoDiffCellBuffer instead of CellBuffer.\nthreading=Val(false): Set to Val(true) to setup threaded assembly. More elaborate settings may be added in the future. \n\n\n\n\n\n","category":"function"},{"location":"UserAPI/Setup/#FerriteAssembly.AssemblyDomain","page":"Setup","title":"FerriteAssembly.AssemblyDomain","text":"AssemblyDomain(name, dh, material, cellvalues; cellset, colors=nothing, user_data=nothing, cache=nothing)\n\nCreate an AssemblyDomain that can be used when calling setup_assembly to assemble multiple domains. name is used to access the corresponding DomainBuffer and state variables returned by setup_assembly.  If not given, cellset is attempted to be inferred from the DofHandler, dh. \n\n\n\n\n\n","category":"type"},{"location":"MaterialModelsBase/#MaterialModelsBase","page":"Builtin elements","title":"MaterialModelsBase","text":"","category":"section"},{"location":"MaterialModelsBase/","page":"Builtin elements","title":"Builtin elements","text":"If you have implemented your constitutive mechanical behavior following the  MaterialModelsBase.jl's API, FerriteAssembly.element_routine! and FerriteAssembly.create_cell_state  have already been implemented for this case. ","category":"page"},{"location":"MaterialModelsBase/","page":"Builtin elements","title":"Builtin elements","text":"FerriteAssembly.element_routine!(Ke, re, state_new::Vector{<:MMB.AbstractMaterialState}, ae, material::MMB.AbstractMaterial, cellvalues::CellVectorValues, buffer)\nFerriteAssembly.create_cell_state(m::MMB.AbstractMaterial, cv::CellVectorValues, args...)","category":"page"},{"location":"MaterialModelsBase/#FerriteAssembly.element_routine!-Tuple{Any, Any, Vector{<:MaterialModelsBase.AbstractMaterialState}, Any, MaterialModelsBase.AbstractMaterial, CellVectorValues, Any}","page":"Builtin elements","title":"FerriteAssembly.element_routine!","text":"FerriteAssembly.element_routine!(\n    Ke, re, state::Vector{<:MMB.AbstractMaterialState}, ae, \n    m::MMB.AbstractMaterial, cv::CellVectorValues, buffer)\n\nSolve the weak form \n\n   int_Omega boldsymboldelta uotimesnabla^mathrmsym  boldsymbolsigma mathrmdOmega \n   = int_Gamma boldsymboldelta u cdot boldsymbolt mathrmdGamma \n   + int_Omega boldsymboldelta u cdot boldsymbolb mathrmdOmega\n\nwhere sigma is calculated with the material_response function from  MaterialModelsBase.jl.  Note that create_cell_state is already implemented for <:AbstractMaterial. \n\n\n\n\n\n","category":"method"},{"location":"MaterialModelsBase/#FerriteAssembly.create_cell_state-Tuple{MaterialModelsBase.AbstractMaterial, CellVectorValues, Vararg{Any}}","page":"Builtin elements","title":"FerriteAssembly.create_cell_state","text":"FerriteAssembly.create_cell_state(m::MMB.AbstractMaterial, cv::CellVectorValues, args...)\n\nCreate a Vector{<:MMM.AbstractMaterialState} where each element is the output from  MMB.initial_material_state(m) and the length is the number of quadrature points in cv.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FerriteAssembly","category":"page"},{"location":"#FerriteAssembly","page":"Home","title":"FerriteAssembly","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The goal of FerriteAssembly  is to provide a simple structure for assembling in  Ferrite.jl.","category":"page"},{"location":"#Key-features","page":"Home","title":"Key features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Easy switching between sequential and threaded assembly\nMultiple domains with different fields, interpolations, and/or element routines.\nEfficient automatic differentiation if analytical tangent is not implemented. \nSupport for handling of (old and new) state variables\nEasy integration of a function over the domain","category":"page"},{"location":"#Typical-workflow","page":"Home","title":"Typical workflow","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Define your custom type and associated element routine (See Example elements)\nSetup Ferrite's DofHandler and CellValues as usual, and call setup_assembly\nFor each assembly, call doassemble!","category":"page"},{"location":"#Heat-equation-example","page":"Home","title":"Heat equation example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Include the example here, but modify the Literate output to suit being embedded\nusing Literate, Markdown\nfilename = \"firstexample_literate\"\nLiterate.markdown(filename*\".jl\"; execute=true)\ncontents = read(filename*\".md\", String)\nLiterate.script(filename*\".jl\"; name=\"firstexample\")\nrm(filename*\".jl\")\nrm(filename*\".md\")\nheader_end = last(findnext(\"```\", contents, 4))+1\nMarkdown.parse(replace(contents[header_end:end], \n    \"*This page was generated using [Literate.jl]\"=>\"*The examples were generated using [Literate.jl]\")\n    )","category":"page"}]
}
