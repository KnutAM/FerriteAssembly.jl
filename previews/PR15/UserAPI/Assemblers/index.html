<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Assemblers · FerriteAssembly.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://KnutAM.github.io/FerriteAssembly.jl/UserAPI/Assemblers/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">FerriteAssembly.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../ExampleElements/">Example elements</a></li><li><a class="tocitem" href="../../examples/plasticity/">Plasticity</a></li><li><a class="tocitem" href="../../examples/mixed_materials/">Multiple materials</a></li></ul></li><li><a class="tocitem" href="../../MaterialModelsBase/">Builtin elements</a></li><li><span class="tocitem">User API</span><ul><li><a class="tocitem" href="../Setup/">Setup</a></li><li><a class="tocitem" href="../StateVariables/">State variables</a></li><li class="is-active"><a class="tocitem" href>Assemblers</a><ul class="internal"><li><a class="tocitem" href="#Assembling-system-matrices-and-residual-vectors"><span>Assembling system matrices and residual vectors</span></a></li><li><a class="tocitem" href="#Integration"><span>Integration</span></a></li></ul></li><li><a class="tocitem" href="../CellBuffer/">CellBuffer</a></li><li><a class="tocitem" href="../ResidualScaling/">Residual scaling</a></li></ul></li><li><a class="tocitem" href="../../hack_api/">Hacking API</a></li><li><a class="tocitem" href="../../internals/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User API</a></li><li class="is-active"><a href>Assemblers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Assemblers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/main/docs/src/UserAPI/Assemblers.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Assemblers"><a class="docs-heading-anchor" href="#Assemblers">Assemblers</a><a id="Assemblers-1"></a><a class="docs-heading-anchor-permalink" href="#Assemblers" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.doassemble!" href="#FerriteAssembly.doassemble!"><code>FerriteAssembly.doassemble!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">doassemble!(assembler, new_states::Dict{Int}, buffer::AbstractDomainBuffer; a=nothing, aold=nothing, old_states=nothing, Δt=NaN)</code></pre><p>Use <code>assembler</code> to assemble a single domain described by <code>buffer</code>, and update <code>new_states</code> if dictated by the assembler. </p><pre><code class="nohighlight hljs">doassemble!(assembler, new_states::Dict{String}, buffers::Dict{String,AbstractDomainBuffer}; a=nothing, aold=nothing, old_states=nothing, Δt=NaN)</code></pre><p>Use <code>assembler</code> to assemble all domains described by <code>buffers</code>, and update <code>new_states</code> if dictated by the assembler.</p><p>The keyword arguments work as follows:</p><ul><li><code>a, aold</code>: If these are <code>nothing</code>, then <code>NaN</code> values are given to the element routine for the corresponding entry.</li><li><code>old_states</code>: If <code>nothing</code>, the old state in the cellbuffer will not be updated before calling the element routine </li><li><code>Δt</code>: Directly the value returned by <code>get_time_increment(cellbuffer)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/3a1b3680482a403b995d1e57ee28a51ea71ceed4/src/assembly.jl#L1-L14">source</a></section></article><h2 id="Assembling-system-matrices-and-residual-vectors"><a class="docs-heading-anchor" href="#Assembling-system-matrices-and-residual-vectors">Assembling system matrices and residual vectors</a><a id="Assembling-system-matrices-and-residual-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Assembling-system-matrices-and-residual-vectors" title="Permalink"></a></h2><h3 id="Element-routines"><a class="docs-heading-anchor" href="#Element-routines">Element routines</a><a id="Element-routines-1"></a><a class="docs-heading-anchor-permalink" href="#Element-routines" title="Permalink"></a></h3><p>One of the element methods should be overloaded for <code>material</code>.  Note that <code>cellvalues</code> are already <code>reinit!</code>:ed for the current cell.</p><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.element_routine!" href="#FerriteAssembly.element_routine!"><code>FerriteAssembly.element_routine!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">element_routine!(
    Ke::AbstractMatrix, re::AbstractVector, state_new,
    ae::AbstractVector, material, cellvalues, buffer)</code></pre><p>The main function to be overloaded for the specific <code>material</code>. In most cases, the same implementation can be used for different cellvalues  (e.g. for different interpolation orders) This function should modify the element stiffness matrix <code>Ke</code>, the residual <code>re</code>, and potentially <code>state_new</code>. The element degree of freedom values, <code>ae</code>, are filled by  <code>NaN</code>s unless <code>a</code> is passed to <a href="#FerriteAssembly.doassemble!"><code>doassemble!</code></a>.</p><p>The following variables can be obtained from <code>buffer</code>.</p><ul><li><a href="../CellBuffer/#FerriteAssembly.get_old_state"><code>get_old_state(buffer)</code></a></li><li><a href="../CellBuffer/#FerriteAssembly.get_aeold"><code>get_aeold(buffer)</code></a></li><li><a href="../CellBuffer/#FerriteAssembly.get_time_increment"><code>get_time_increment(buffer)</code></a></li><li><a href="../CellBuffer/#Ferrite.dof_range"><code>dof_range(buffer, fieldname::Symbol)</code></a></li><li><a href="../CellBuffer/#Ferrite.getcoordinates"><code>getcoordinates(buffer)</code></a></li><li><a href="../CellBuffer/#Ferrite.celldofs"><code>celldofs(buffer)</code></a></li><li><a href="../CellBuffer/#Ferrite.cellid"><code>cellid(buffer)</code></a></li><li><a href="../CellBuffer/#FerriteAssembly.get_user_data"><code>get_user_data(buffer)</code></a></li><li><a href="../CellBuffer/#FerriteAssembly.get_cache"><code>get_cache(buffer)</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/3a1b3680482a403b995d1e57ee28a51ea71ceed4/src/FerriteAssembly.jl#L25-L47">source</a></section><section><div><pre><code class="language-julia hljs">FerriteAssembly.element_routine!(Ke, re, state, ae, m::MaterialModelsBase.AbstractMaterial, args...)</code></pre><p>Solve the weak form </p><p class="math-container">\[   \int_\Omega [\boldsymbol{\delta u}\otimes\nabla]^\mathrm{sym} : \boldsymbol{\sigma}\ \mathrm{d}\Omega 
   = \int_\Gamma \boldsymbol{\delta u} \cdot \boldsymbol{t}\ \mathrm{d}\Gamma 
   + \int_\Omega \boldsymbol{\delta u} \cdot \boldsymbol{b}\ \mathrm{d}\Omega\]</p><p>where <span>$\sigma$</span> is calculated with the <code>material_response</code> function from  <a href="https://github.com/KnutAM/MaterialModelsBase.jl"><code>MaterialModelsBase.jl</code></a>.  Note that <code>create_cell_state</code> is already implemented for <code>&lt;:AbstractMaterial</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/3a1b3680482a403b995d1e57ee28a51ea71ceed4/src/MaterialModelsBase.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.element_residual!" href="#FerriteAssembly.element_residual!"><code>FerriteAssembly.element_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">element_residual!(
    re::AbstractVector, state_new,
    ae::AbstractVector, material, cellvalues, buffer)</code></pre><p>To calculate the element tangent stiffness <code>Ke</code> automatically by using <code>ForwardDiff</code>, it is possible to overload <code>element_residual!</code> instead of <code>element_routine!</code>. See  <a href="#FerriteAssembly.element_routine!"><code>element_routine!</code></a> for a description of the input parameters. </p><p>!!! note <code>MethodError</code> with <code>ForwardDiff.Dual</code>     When using automatic differentiation for elements with state variables (or other mutating values in e.g. cache),     an error will be thrown if trying to change the type in many cases.      When mutating <code>new_state</code>, call <code>ForwardDiff.value()</code> on the value to be assigned <strong>after</strong>      it will no longer be used to calculate <code>re</code>. (If done on a value which is later affects <code>re</code> inside the element,     the tangent, <code>Ke</code>, will be wrong.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/3a1b3680482a403b995d1e57ee28a51ea71ceed4/src/FerriteAssembly.jl#L50-L65">source</a></section></article><h3 id="Assemblers-2"><a class="docs-heading-anchor" href="#Assemblers-2">Assemblers</a><a class="docs-heading-anchor-permalink" href="#Assemblers-2" title="Permalink"></a></h3><p><code>Ferrite.AssemblerSparsityPattern</code> and <code>Ferrite.AssemblerSymmetricSparsityPattern</code>  are supported. These are created as described in <code>Ferrite.jl</code>&#39;s documentation, and when passed to <code>doassemble!</code>, they assemble <code>K</code> and <code>r</code> as in <code>Ferrite.jl</code>. In addition, the following assemblers are provided by <code>FerriteAssemble.jl</code>,</p><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.KeReAssembler" href="#FerriteAssembly.KeReAssembler"><code>FerriteAssembly.KeReAssembler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KeReAssembler(K, r; fillzero=true, kwargs...)
KeReAssembler(a::Ferrite.AbstractSparseAssembler; kwargs...)</code></pre><p>The default <code>KeReAssembler</code> works just like a <code>Ferrite.AbstractSparseAssembler</code>: It will call <code>element_routine!</code> and assemble <code>Ke</code> and <code>re</code> into the global system  matrix <code>K</code> and vector <code>r</code>. However, it comes with the additional possible features, that are controllable via the keyword arguments:</p><ul><li><code>ch::Union{Nothing,ConstraintHandler}=nothing</code>: If a <code>ConstraintHandler</code> is given, local applications of constraints will be applied, using <code>Ferrite.apply_assemble</code>.</li><li><code>apply_zero</code>: Required if a constraint handler is given, and forwarded to <code>Ferrite.apply_assemble</code>. </li><li><code>scaling</code>: Calculate a scaling measure locally at the residual level, see e.g.,  <a href="../ResidualScaling/#FerriteAssembly.ElementResidualScaling"><code>ElementResidualScaling</code></a></li></ul><p><code>a=Ferrite.start_assemble(K, r; fillzero=fillzero)</code> is passed to the second definition  if a matrix, <code>K</code>, and vector, <code>r</code>, are given as input.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/3a1b3680482a403b995d1e57ee28a51ea71ceed4/src/Assemblers.jl#L81-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.ReAssembler" href="#FerriteAssembly.ReAssembler"><code>FerriteAssembly.ReAssembler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReAssembler(r; fillzero=true, scaling=NoScaling())</code></pre><p><code>ReAssembler</code> will call <code>element_residual!</code> and assemble <code>re</code> into the system  vector <code>r</code>. <code>fillzero=true</code> implies that <code>r</code> is zeroed upon construction of  <code>ReAssembler</code>. Furthermore, remaining keyword arguments can enable the following  features:</p><ul><li><code>scaling</code>: Calculate a scaling measure locally at the residual level, see e.g.,  <a href="../ResidualScaling/#FerriteAssembly.ElementResidualScaling"><code>ElementResidualScaling</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/3a1b3680482a403b995d1e57ee28a51ea71ceed4/src/Assemblers.jl#L29-L38">source</a></section></article><h2 id="Integration"><a class="docs-heading-anchor" href="#Integration">Integration</a><a id="Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Integration" title="Permalink"></a></h2><p>In addition to assembling system matrices and vectors, much of the internal code can be reused  to create quite efficient integration of values, given a solution vector (and potentially state variables) The general workflow assumes that <a href="../Setup/#FerriteAssembly.setup_assembly"><code>setup_assembly</code></a> has already been called, and that a solution  vector is available. Then, it is possible to call <a href="#FerriteAssembly.doassemble!"><code>doassemble!</code></a> with an <code>Integrator</code> to obtain  the integrated value. The following integrators are implemented</p><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.Integrator" href="#FerriteAssembly.Integrator"><code>FerriteAssembly.Integrator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Integrator(fun::Function, val)</code></pre><p>Calculate the integral</p><p class="math-container">\[\int_\Omega f(u, \nabla u, s)\, \mathrm{d}\Omega \]</p><p>For single-field problems, the function signature of <span>$f$</span> is <code>fun(u, ∇u, qp_state)</code>. <code>u</code> is the current function value, <code>∇u</code> the current function gradient, and <code>qp_state</code> the  current state in the current quadrature point. This assumes that <code>cell_state::AbstractVector</code>,  otherwise, <code>qp_state = cell_state</code>.  </p><p>For multi-field problem, we have <code>fun(u::NamedTuple, ∇u::NamedTuple, qp_state)</code>,  where the keys in <code>u</code> and <code>∇u</code> are the fieldnames. The rest is same as for single-field  problems. </p><p>It is the user&#39;s responsibility that <code>fun(args...)::typeof(val)</code>.  Additionally, the type of <code>val</code> must support</p><ul><li><code>val + val</code></li><li><code>val * x</code> (where <code>x::Real</code>)</li><li><code>zero(val)</code></li></ul><p>One exception to these requirements; <code>val::Tuple</code>,  if the elements of the tuple fulfills those requirements.</p><p><strong>Example:</strong> <em>Calculate the average value and gradient</em> <br/>We assume that we have done the setup: <code>buffer, state = setup_assembly(...)</code>,<br/>assembled <code>K</code> and <code>r</code>, and solved <code>a=K\r</code></p><pre><code class="language-julia hljs">integrator = Integrator((u, ∇u, state)-&gt;(1.0, u, ∇u), (0.0, 0.0, zero(Vec{dim})))
doassemble!(integrator, states, buffer; a=a)
area = integrator.val[1]
u_avg = integrator.val[2]/area 
∇u_avg = integrator.val[3]/area</code></pre><p>If the <code>buffer</code> is setup to be threaded, this calculation will also be threaded. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/3a1b3680482a403b995d1e57ee28a51ea71ceed4/src/Integrators.jl#L4-L39">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../StateVariables/">« State variables</a><a class="docs-footer-nextpage" href="../CellBuffer/">CellBuffer »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 12 May 2023 15:42">Friday 12 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
