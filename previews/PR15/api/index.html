<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · FerriteAssembly.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://KnutAM.github.io/FerriteAssembly.jl/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FerriteAssembly.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/plasticity/">Plasticity</a></li><li><a class="tocitem" href="../examples/mixed_materials/">Multiple materials</a></li></ul></li><li><a class="tocitem" href="../ExampleElements/">Example elements</a></li><li><a class="tocitem" href="../MaterialModelsBase/">MaterialModelsBase.jl</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Setting-up-and-doing-the-assembly"><span>Setting up and doing the assembly</span></a></li><li><a class="tocitem" href="#Element-routines"><span>Element routines</span></a></li><li><a class="tocitem" href="#State-variables"><span>State variables</span></a></li><li><a class="tocitem" href="#CellBuffer"><span>CellBuffer</span></a></li><li><a class="tocitem" href="#Residual-scaling"><span>Residual scaling</span></a></li></ul></li><li><a class="tocitem" href="../internals/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/main/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>Methods that should be overloaded and exported functions are described on this page.</p><h2 id="Setting-up-and-doing-the-assembly"><a class="docs-heading-anchor" href="#Setting-up-and-doing-the-assembly">Setting up and doing the assembly</a><a id="Setting-up-and-doing-the-assembly-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-and-doing-the-assembly" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.setup_assembly" href="#FerriteAssembly.setup_assembly"><code>FerriteAssembly.setup_assembly</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setup_assembly(dh, material, cellvalues; kwargs...)</code></pre><p>Setup assembly for a single domain (i.e. the same material and interpolations everywhere). Returns the <code>buffer</code>, <code>old_states</code>, and <code>new_states</code> to be used in <a href="#FerriteAssembly.doassemble!"><code>doassemble!</code></a>. The state variables are created by calling the user-defined <a href="#FerriteAssembly.create_cell_state"><code>create_cell_state</code></a> function.  Available keyword arguments</p><ul><li><code>a=nothing</code>: Give the global dof vector to pass element dofs, <code>ae</code>, to <code>create_cell_state</code> (<code>NaN</code>-values otherwise)</li><li><code>colors=nothing</code>: Give colors for the grid from <code>Ferrite.create_coloring</code> to setup threaded assembly.  If <code>nothing</code>, the assembly is sequential.</li><li><code>autodiffbuffer=Val(false)</code>: Set to <code>true</code> or <code>Val(true)</code> (for type stable construction) to use <code>AutoDiffCellBuffer</code> instead of <code>CellBuffer</code>.</li><li><code>user_data=nothing</code>: The <code>user_data</code> is passed to each <code>AbstractCellBuffer</code> by reference (when threaded)</li><li><code>cache=nothing</code>: The <code>cache</code> is passed to each <code>AbstractCellBuffer</code>, and deepcopied if threaded. </li><li><code>scaling=nothing</code>: The scaling to be calculated, see e.g. <a href="#FerriteAssembly.ElementResidualScaling"><code>ElementResidualScaling</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/839c5b50f9b6bd1f2e9486e8689aa6c415205274/src/setup.jl#L54-L69">source</a></section><section><div><pre><code class="nohighlight hljs">setup_assembly(domains::Vector{&lt;:AssemblyDomain}; kwargs...)</code></pre><p>Setup assembly for each <a href="#FerriteAssembly.AssemblyDomain"><code>AssemblyDomain</code></a> in <code>domains</code>.  Returns the <code>Dict</code>s <code>buffers</code>, <code>old_states</code>, and <code>new_states</code> to be used in <a href="#FerriteAssembly.doassemble!"><code>doassemble!</code></a>. The state variables are created by calling the user-defined <a href="#FerriteAssembly.create_cell_state"><code>create_cell_state</code></a> function.  Available keyword arguments</p><ul><li><code>a=nothing</code>: Give the global dof vector to pass element dofs, <code>ae</code>, to <code>create_cell_state</code> (<code>NaN</code>-values otherwise)</li><li><code>colors=nothing</code>: Give colors for the grid from <code>Ferrite.create_coloring</code> to setup threaded assembly.  If <code>nothing</code>, the assembly is sequential.</li><li><code>autodiffbuffer=Val(false)</code>: Set to <code>true</code> or <code>Val(true)</code> (for type stable construction) to use <code>AutoDiffCellBuffer</code> instead of <code>CellBuffer</code>.</li><li><code>scaling=nothing</code>: The scaling to be calculated, see e.g. <a href="#FerriteAssembly.ElementResidualScaling"><code>ElementResidualScaling</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/839c5b50f9b6bd1f2e9486e8689aa6c415205274/src/setup.jl#L86-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.AssemblyDomain" href="#FerriteAssembly.AssemblyDomain"><code>FerriteAssembly.AssemblyDomain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AssemblyDomain(name, dh, material, cellvalues; cellset, user_data=nothing, cache=nothing)</code></pre><p>Create an <code>AssemblyDomain</code> that can be used when calling <a href="#FerriteAssembly.setup_assembly"><code>setup_assembly</code></a> to assemble multiple domains. <code>name</code> is used to access the corresponding <code>DomainBuffer</code> and state variables returned by <code>setup_assembly</code>.  If not given, <code>cellset</code> is attempted to be inferred from the DofHandler, <code>dh</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/839c5b50f9b6bd1f2e9486e8689aa6c415205274/src/setup.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.doassemble!" href="#FerriteAssembly.doassemble!"><code>FerriteAssembly.doassemble!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">doassemble!([K::AbstractMatrix,] r::AbstractVector, new_states, old_states, buffer; kwargs...)</code></pre><p>Assemble <code>K</code> and <code>r</code> (<code>element_residual</code> must be defined to only assemble <code>r</code>), given the <code>new_states</code>, <code>old_states</code>, and <code>buffer</code> returned from <code>setup_assembly</code>. The available keyword arguments are </p><ul><li><code>a=nothing</code>: The current degree of freedom vector. If nothing, <code>ae</code> with <code>NaN</code> values is passed to <code>element_routine!</code></li><li><code>aold=nothing</code>: The old degree of freedom vector. If <code>nothing</code>, <code>get_aeold(buffer) gives a</code>NaN`-filled vector.</li><li><code>Δt=NaN</code>: The time increment that can be accessed as <code>get_time_increment(buffer)</code> in the element routines. </li><li><code>fillzero=true</code>: Should <code>K</code> and <code>r</code> be zeroed before starting the assembly?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/839c5b50f9b6bd1f2e9486e8689aa6c415205274/src/assembly.jl#L10-L21">source</a></section></article><h2 id="Element-routines"><a class="docs-heading-anchor" href="#Element-routines">Element routines</a><a id="Element-routines-1"></a><a class="docs-heading-anchor-permalink" href="#Element-routines" title="Permalink"></a></h2><p>One of the element methods should be overloaded for a given combination of <code>cellvalues</code> and <code>material</code>.  Note that the <code>cellvalues</code> are already <code>reinit!</code>:ed when passed to the element routines. </p><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.element_routine!" href="#FerriteAssembly.element_routine!"><code>FerriteAssembly.element_routine!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">element_routine!(
    Ke::AbstractMatrix, re::AbstractVector, state_new,
    ae::AbstractVector, material, cellvalues, buffer)</code></pre><p>The main function to be overloaded for the specific <code>material</code>. In most cases, the same implementation can be used for different cellvalues  (e.g. for different interpolation orders) This function should modify the element stiffness matrix <code>Ke</code>, the residual <code>re</code>, and potentially <code>state_new</code>. The element degree of freedom values, <code>ae</code>, are filled by  <code>NaN</code>s unless <code>a</code> is passed to <a href="#FerriteAssembly.doassemble!"><code>doassemble!</code></a>.</p><p>The following variables can be obtained from <code>buffer</code>.</p><ul><li><a href="#FerriteAssembly.get_state_old"><code>get_state_old(buffer)</code></a></li><li><a href="#FerriteAssembly.get_aeold"><code>get_aeold(buffer)</code></a></li><li><a href="#FerriteAssembly.get_time_increment"><code>get_time_increment(buffer)</code></a></li><li><a href="#Ferrite.dof_range"><code>dof_range(buffer, fieldname::Symbol)</code></a></li><li><a href="#Ferrite.getcoordinates"><code>getcoordinates(buffer)</code></a></li><li><a href="#Ferrite.celldofs"><code>celldofs(buffer)</code></a></li><li><a href="#Ferrite.cellid"><code>cellid(buffer)</code></a></li><li><a href="#FerriteAssembly.get_user_data"><code>get_user_data(buffer)</code></a></li><li><a href="#FerriteAssembly.get_cache"><code>get_cache(buffer)</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/839c5b50f9b6bd1f2e9486e8689aa6c415205274/src/FerriteAssembly.jl#L21-L43">source</a></section><section><div><pre><code class="language-julia hljs">FerriteAssembly.element_routine!(Ke, re, state, ae, m::MaterialModelsBase.AbstractMaterial, args...)</code></pre><p>Solve the weak form </p><p class="math-container">\[   \int_\Omega [\boldsymbol{\delta u}\otimes\nabla]^\mathrm{sym} : \boldsymbol{\sigma}\ \mathrm{d}\Omega 
   = \int_\Gamma \boldsymbol{\delta u} \cdot \boldsymbol{t}\ \mathrm{d}\Gamma 
   + \int_\Omega \boldsymbol{\delta u} \cdot \boldsymbol{b}\ \mathrm{d}\Omega\]</p><p>where <span>$\sigma$</span> is calculated with the <code>material_response</code> function from  <a href="https://github.com/KnutAM/MaterialModelsBase.jl"><code>MaterialModelsBase.jl</code></a>.  Note that <code>create_cell_state</code> is already implemented for <code>&lt;:AbstractMaterial</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/839c5b50f9b6bd1f2e9486e8689aa6c415205274/src/MaterialModelsBase.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.element_residual!" href="#FerriteAssembly.element_residual!"><code>FerriteAssembly.element_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">element_residual!(
    re::AbstractVector, state_new,
    ae::AbstractVector, material, cellvalues, buffer)</code></pre><p>To calculate the element tangent stiffness <code>Ke</code> automatically by using <code>ForwardDiff</code>, it is possible to overload <code>element_residual!</code> instead of <code>element_routine!</code>. See  <a href="#FerriteAssembly.element_routine!"><code>element_routine!</code></a> for a description of the input parameters. </p><p>!!! note <code>MethodError</code> with <code>ForwardDiff.Dual</code>     When using automatic differentiation for elements with state variables (or other mutating values in e.g. cache),     an error will be thrown if trying to change the type in many cases.      When mutating <code>new_state</code>, call <code>ForwardDiff.value()</code> on the value to be assigned <strong>after</strong>      it will no longer be used to calculate <code>re</code>. (If done on a value which is later affects <code>re</code> inside the element,     the tangent, <code>Ke</code>, will be wrong.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/839c5b50f9b6bd1f2e9486e8689aa6c415205274/src/FerriteAssembly.jl#L46-L61">source</a></section></article><h2 id="State-variables"><a class="docs-heading-anchor" href="#State-variables">State variables</a><a id="State-variables-1"></a><a class="docs-heading-anchor-permalink" href="#State-variables" title="Permalink"></a></h2><p>The initial state variables may vary depending on the position in the grid. Furthermore, the datastructure depends on the type of dof handler, so a convenience function exists that creates the correct variable structure. </p><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.create_cell_state" href="#FerriteAssembly.create_cell_state"><code>FerriteAssembly.create_cell_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_cell_state(material, cellvalues, x, ae, dofrange)</code></pre><p>Defaults to returning <code>nothing</code>.</p><p>Overload this function to create the state which should be passed into the  <code>element_routine!</code>/<code>element_residual!</code> for the given <code>material</code> and <code>cellvalues</code>.  <code>x</code> is the cell&#39;s coordinates, <code>ae</code> the element degree of freedom values, and  <code>dofrange::NamedTuple</code> containing the local dof range for each field.  As for the element routines, <code>ae</code>, is filled with <code>NaN</code> unless the global degree  of freedom vector is given to the <a href="#FerriteAssembly.setup_assembly"><code>setup_assembly</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/839c5b50f9b6bd1f2e9486e8689aa6c415205274/src/states.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.update_states!" href="#FerriteAssembly.update_states!"><code>FerriteAssembly.update_states!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_states!(old_states, new_states)</code></pre><p>Update <code>old_states</code> with the values from <code>new_states</code>. This is typically done after a converged time increment.</p><p>This method tries to avoid allocating new values where possible.  Currently, if <a href="#FerriteAssembly.create_cell_state"><code>create_cell_state</code></a> returns <code>T</code> or <code>Vector{T}</code> where <code>isbitstype(T)</code>, this works.</p><p>If needed/wanted, it should be relatively easy to provide an interface to make it possible to have allocation free  for custom cell states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/839c5b50f9b6bd1f2e9486e8689aa6c415205274/src/states.jl#L44-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.create_states" href="#FerriteAssembly.create_states"><code>FerriteAssembly.create_states</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_states(sdh::SubDofHandler, material, cellvalues, a, cellset, dofrange)</code></pre><p>Create a <code>Dict</code> of states for the cells in <code>cellset</code>, where the user should  define the <a href="#FerriteAssembly.create_cell_state"><code>create_cell_state</code></a> function for their <code>material</code> (and corresponding <code>cellvalues</code>) <code>dofrange::NamedTuple</code> is passed onto <code>create_cell_state</code> and contains the local dof ranges for each field. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/839c5b50f9b6bd1f2e9486e8689aa6c415205274/src/states.jl#L31-L37">source</a></section></article><h2 id="CellBuffer"><a class="docs-heading-anchor" href="#CellBuffer">CellBuffer</a><a id="CellBuffer-1"></a><a class="docs-heading-anchor-permalink" href="#CellBuffer" title="Permalink"></a></h2><p>Variables that are used and modified for each cell of a certain type,  but that don&#39;t belong to a specific cell, are collected in a <code>CellBuffer</code>.</p><h3 id="Access-functions"><a class="docs-heading-anchor" href="#Access-functions">Access functions</a><a id="Access-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Access-functions" title="Permalink"></a></h3><p>The following access functions can be used to extract information from the  <code>CellBuffer</code></p><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.get_state_old" href="#FerriteAssembly.get_state_old"><code>FerriteAssembly.get_state_old</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_state_old(c::CellBuffer)</code></pre><p>Get the state variables for the cell from the previous time step. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/839c5b50f9b6bd1f2e9486e8689aa6c415205274/src/CellBuffer.jl#L116-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.get_aeold" href="#FerriteAssembly.get_aeold"><code>FerriteAssembly.get_aeold</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteAssembly.get_aeold(c::CellBuffer)</code></pre><p>Get the old element dof-values for the current cell  (Filled by <code>NaN</code>s unless <code>aold</code> is passed to <code>doassemble!</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/839c5b50f9b6bd1f2e9486e8689aa6c415205274/src/CellBuffer.jl#L91-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.get_time_increment" href="#FerriteAssembly.get_time_increment"><code>FerriteAssembly.get_time_increment</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_time_increment(c::CellBuffer)</code></pre><p>Get the time increment, <code>Δt</code>, that was passed to <code>doassemble</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/839c5b50f9b6bd1f2e9486e8689aa6c415205274/src/CellBuffer.jl#L123-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ferrite.dof_range" href="#Ferrite.dof_range"><code>Ferrite.dof_range</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Ferrite.dof_range(c::CellBuffer, name::Symbol)</code></pre><p>Get the <code>dofrange::UnitRange{Int}</code> for the dofs pertaining to the field: <code>name</code>. Same output as dof_range(dh::DofHandler, name), but fully type-stable. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/839c5b50f9b6bd1f2e9486e8689aa6c415205274/src/CellBuffer.jl#L106-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ferrite.getcoordinates" href="#Ferrite.getcoordinates"><code>Ferrite.getcoordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Ferrite.getcoordinates(c::CellBuffer)</code></pre><p><code>Ferrite.jl</code>&#39;s <code>getcoordinates</code> function is overloaded on the <code>CellBuffer</code> to return  the current cell&#39;s nodal coordinates. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/839c5b50f9b6bd1f2e9486e8689aa6c415205274/src/CellBuffer.jl#L83-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ferrite.celldofs" href="#Ferrite.celldofs"><code>Ferrite.celldofs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Ferrite.celldofs(c::CellBuffer)</code></pre><p><code>Ferrite.jl</code>&#39;s <code>celldofs</code> function is overloaded on the <code>CellBuffer</code> to return  the current cell&#39;s degree of freedom indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/839c5b50f9b6bd1f2e9486e8689aa6c415205274/src/CellBuffer.jl#L74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Ferrite.cellid" href="#Ferrite.cellid"><code>Ferrite.cellid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Ferrite.cellid(c::CellBuffer)</code></pre><p>Get the current cell id/nr</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/839c5b50f9b6bd1f2e9486e8689aa6c415205274/src/CellBuffer.jl#L99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.get_user_data" href="#FerriteAssembly.get_user_data"><code>FerriteAssembly.get_user_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteAssembly.get_user_data(c::CellBuffer)</code></pre><p>Get the user specified <code>user_data</code> given to <code>CellBuffer</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/839c5b50f9b6bd1f2e9486e8689aa6c415205274/src/CellBuffer.jl#L130-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.get_cache" href="#FerriteAssembly.get_cache"><code>FerriteAssembly.get_cache</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">FerriteAssembly.get_cache(c::CellBuffer)</code></pre><p>Get the user-specified <code>cache</code> given to the <code>CellBuffer</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/839c5b50f9b6bd1f2e9486e8689aa6c415205274/src/CellBuffer.jl#L137-L141">source</a></section></article><h2 id="Residual-scaling"><a class="docs-heading-anchor" href="#Residual-scaling">Residual scaling</a><a id="Residual-scaling-1"></a><a class="docs-heading-anchor-permalink" href="#Residual-scaling" title="Permalink"></a></h2><p>There are many options for how to scale the residual in finite element simulations. This package does not intend to implement many different options, but does give the  user the option to calculate scaling contributions from each cell, which may be useful. By defining a <code>scaling</code> that is passed to <a href="#FerriteAssembly.setup_assembly"><code>setup_assembly</code></a>, it can be updated  based on the output from each cell. </p><p>One type of scaling, <a href="#FerriteAssembly.ElementResidualScaling"><code>ElementResidualScaling</code></a>, is included as described below. Its code can be used as a template for how to include custom scaling that works on  the element level.</p><p>In general, a scaling must support the following functions</p><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.update_scaling!" href="#FerriteAssembly.update_scaling!"><code>FerriteAssembly.update_scaling!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_scaling!(scaling, re, cellbuffer)</code></pre><p>This function should add the contribution from the element residual vector <code>re</code> to the scaling factors in <code>scaling</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/839c5b50f9b6bd1f2e9486e8689aa6c415205274/src/scaling.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.reset_scaling!" href="#FerriteAssembly.reset_scaling!"><code>FerriteAssembly.reset_scaling!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reset_scaling!(scaling)</code></pre><p>This function should reset the scaling factors, such that the values don&#39;t accumulate if used  in multiple iterations/time steps. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/839c5b50f9b6bd1f2e9486e8689aa6c415205274/src/scaling.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.add_to_scaling!" href="#FerriteAssembly.add_to_scaling!"><code>FerriteAssembly.add_to_scaling!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_to_scaling!(base_scaling, scaling)</code></pre><p>Add the scaling values from <code>scaling</code> to <code>base_scaling</code>. This function is used after  threaded assembly to put all the scaling values together into the object initially sent to <code>setup_assembly</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/839c5b50f9b6bd1f2e9486e8689aa6c415205274/src/scaling.jl#L17-L23">source</a></section></article><h3 id="ElementResidualScaling"><a class="docs-heading-anchor" href="#ElementResidualScaling">ElementResidualScaling</a><a id="ElementResidualScaling-1"></a><a class="docs-heading-anchor-permalink" href="#ElementResidualScaling" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FerriteAssembly.ElementResidualScaling" href="#FerriteAssembly.ElementResidualScaling"><code>FerriteAssembly.ElementResidualScaling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ElementResidualScaling(dh::AbstractDofHandler, p=Val(2), T=Float64)</code></pre><p>Create tolerance scaling based on the sum of the p-norm of each cell&#39;s residual vector,  separately for each field. I.e. pseudo-code for field <code>:u</code> the scaling <code>factor::T</code> is</p><pre><code class="nohighlight hljs">for each cell
    element_routine!(Ke, re, args...) # Calculate re
    factor += sum(abs.(re[dof_range(dh, :u)]).^p)^(1/p)</code></pre><p>Note that <code>p=Val(2)</code> is a special case that is supported, for different values  it should be given as a <code>Real</code>. <code>p=2</code> is equivalent to <code>Val(2)</code>, but is less efficient. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/FerriteAssembly.jl/blob/839c5b50f9b6bd1f2e9486e8689aa6c415205274/src/scaling.jl#L32-L44">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../MaterialModelsBase/">« MaterialModelsBase.jl</a><a class="docs-footer-nextpage" href="../internals/">Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 7 May 2023 19:28">Sunday 7 May 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
